
/* ==== IN√çCIO: data/builders/ui-folder/machine-renderer.js ==== */
import { buildMachinesSection, addMachine } from '../../modules/machines/machines-core.js';

/**
 * Encontra se√ß√£o de m√°quinas pelo t√≠tulo
 */
function findMachinesSection(roomElement) {
    if (!roomElement) return null;
    
    // Buscar todas as se√ß√µes .section-block
    const allSections = roomElement.querySelectorAll('.section-block');
    
    // Encontrar a que tem "M√°quinas" no t√≠tulo
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes('M√°quinas')) {
            return section;
        }
    }
    
    return null;
}

/**
 * ‚úÖ FUN√á√ÉO AUXILIAR: Encontrar se√ß√£o por t√≠tulo
 */
function findSectionByTitle(roomElement, titleText) {
    if (!roomElement) return null;
    
    const allSections = roomElement.querySelectorAll('.section-block');
    
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes(titleText)) {
            return section;
        }
    }
    
    return null;
}

/**
 * Garante que a se√ß√£o de m√°quinas existe e est√° inicializada - VERS√ÉO CORRIGIDA
 */
async function ensureMachinesSection(roomElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala inv√°lido');
        return null;
    }

    const obraId = roomElement.dataset.obraId;
    const projectId = roomElement.dataset.projectId;
    const roomName = roomElement.dataset.roomName;
    const roomId = roomElement.dataset.roomId;

    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido: "${roomId}" para sala ${roomName}`);
        return null;
    }

    console.log(`üî® Garantindo se√ß√£o de m√°quinas para sala ${roomName} (ID: ${roomId})`);

    // Primeiro garantir que todas as se√ß√µes existem
    const sectionsReady = await ensureAllRoomSections(roomElement);
    if (!sectionsReady) {
        console.error(`‚ùå N√£o foi poss√≠vel garantir todas as se√ß√µes para sala ${roomName}`);
        return null;
    }

    // ‚úÖ CORRE√á√ÉO: Buscar por .section-block que contenha "M√°quinas" no t√≠tulo
    let machinesSection = findMachinesSection(roomElement);
    
    if (machinesSection) {
        console.log(`‚úÖ Se√ß√£o de m√°quinas encontrada para sala ${roomName}`);
        return machinesSection;
    }

    // Se ainda n√£o existe, tentar criar apenas a se√ß√£o de m√°quinas
    console.log(`üîÑ Tentando criar apenas se√ß√£o de m√°quinas para sala ${roomName}`);

    // Encontrar a √∫ltima se√ß√£o para inserir ap√≥s ela
    const lastSection = roomElement.querySelector('.section-block:last-child') || 
                       roomElement.querySelector('.room-content > :last-child');

    if (!lastSection) {
        console.error(`‚ùå Nenhuma se√ß√£o encontrada para inserir m√°quinas`);
        return null;
    }

    if (typeof buildMachinesSection !== 'function') {
        console.error('‚ùå Fun√ß√£o buildMachinesSection n√£o dispon√≠vel');
        return null;
    }

    try {
        const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
        if (!machinesHTML) {
            console.error('‚ùå HTML da se√ß√£o de m√°quinas n√£o gerado');
            return null;
        }

        lastSection.insertAdjacentHTML('afterend', machinesHTML);
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // ‚úÖ CORRE√á√ÉO: Usar a nova fun√ß√£o para encontrar a se√ß√£o
        machinesSection = findMachinesSection(roomElement);
        if (machinesSection) {
            console.log(`‚úÖ Se√ß√£o de m√°quinas criada com sucesso para sala ${roomName}`);
            return machinesSection;
        } else {
            console.error(`‚ùå Se√ß√£o de m√°quinas n√£o encontrada ap√≥s cria√ß√£o`);
            return null;
        }

    } catch (error) {
        console.error(`‚ùå Erro ao criar se√ß√£o de m√°quinas:`, error);
        return null;
    }
}

/**
 * Preenche os dados das m√°quinas de uma sala - VERS√ÉO CORRIGIDA
 */
async function fillMachinesData(roomElement, machinesData) {
    if (!roomElement || !machinesData || !Array.isArray(machinesData)) {
        console.error('‚ùå Elemento da sala ou dados de m√°quinas inv√°lidos');
        return false;
    }

    const roomId = roomElement.dataset.roomId;
    const roomName = roomElement.dataset.roomName;
    
    console.log(`üîÑ Preenchendo ${machinesData.length} m√°quina(s) para sala ${roomName} (ID: ${roomId})`);

    // ‚úÖ CORRE√á√ÉO: Verificar se h√° m√°quinas para preencher
    if (machinesData.length === 0) {
        console.log(`‚ÑπÔ∏è Nenhuma m√°quina para preencher na sala ${roomName}`);
        return true; // Retorna true porque n√£o h√° erro, s√≥ n√£o h√° m√°quinas
    }

    try {
        const machinesSection = await ensureMachinesSection(roomElement);
        if (!machinesSection) {
            console.error(`‚ùå N√£o foi poss√≠vel criar/obter se√ß√£o de m√°quinas para sala ${roomName}`);
            return false;
        }

        const machinesContainer = machinesSection.querySelector('.machines-container');
        if (!machinesContainer) {
            console.error(`‚ùå Container de m√°quinas n√£o encontrado para sala ${roomName}`);
            return false;
        }

        console.log(`‚úÖ Container de m√°quinas encontrado`);

        // Limpar m√°quinas existentes
        const existingMachines = machinesContainer.querySelectorAll('.climatization-machine, .machine-block');
        if (existingMachines.length > 0) {
            console.log(`üóëÔ∏è Removendo ${existingMachines.length} m√°quina(s) existente(s)`);
            existingMachines.forEach(machine => machine.remove());
        }

        let successCount = 0;

        // Adicionar cada m√°quina
        for (let i = 0; i < machinesData.length; i++) {
            const machineData = machinesData[i];
            
            if (!machineData || !machineData.tipo) {
                console.warn(`‚ö†Ô∏è Dados da m√°quina ${i} inv√°lidos:`, machineData);
                continue;
            }

            console.log(`ü§ñ [${i + 1}/${machinesData.length}] Adicionando m√°quina: ${machineData.tipo}`);

            try {
                // ‚úÖ CORRE√á√ÉO: Usar addMachine com retry
                let machineAdded = false;
                let retryCount = 0;
                
                while (!machineAdded && retryCount < 3) {
                    machineAdded = await addMachine(roomId, machineData.tipo);
                    
                    if (!machineAdded) {
                        retryCount++;
                        console.log(`üîÑ Tentativa ${retryCount}/3 para adicionar m√°quina ${machineData.tipo}`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                if (!machineAdded) {
                    console.error(`‚ùå Falha ao adicionar m√°quina ${machineData.tipo} ap√≥s ${retryCount} tentativas`);
                    continue;
                }

                console.log(`‚úÖ M√°quina ${machineData.tipo} adicionada, aguardando renderiza√ß√£o...`);

                // Aguardar renderiza√ß√£o completa
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Encontrar a m√°quina mais recente
                const machineElements = machinesContainer.querySelectorAll('.climatization-machine');
                const lastMachine = machineElements[machineElements.length - 1];
                
                if (!lastMachine) {
                    console.error(`‚ùå Elemento da m√°quina n√£o encontrado ap√≥s adi√ß√£o`);
                    continue;
                }

                console.log(`‚úÖ Elemento da m√°quina encontrado, preenchendo dados...`);

                // Preencher dados da m√°quina
                const populated = await populateMachineData(lastMachine, machineData);
                if (populated) {
                    successCount++;
                    console.log(`üéâ M√°quina ${machineData.tipo} preenchida com sucesso`);
                } else {
                    console.error(`‚ùå Falha ao preencher dados da m√°quina ${machineData.tipo}`);
                }

            } catch (error) {
                console.error(`‚ùå Erro ao processar m√°quina ${machineData.tipo}:`, error);
            }

            // Pequena pausa entre m√°quinas
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        console.log(`‚úÖ ${successCount}/${machinesData.length} m√°quina(s) preenchida(s) com sucesso para sala ${roomName}`);
        
        // ‚úÖ CORRE√á√ÉO: Retorna true se pelo menos uma m√°quina foi preenchida, ou se n√£o havia m√°quinas
        return successCount > 0 || machinesData.length === 0;

    } catch (error) {
        console.error(`‚ùå Erro cr√≠tico ao preencher m√°quinas para sala ${roomName}:`, error);
        return false;
    }
}

/**
 * Preenche os dados individuais de uma m√°quina
 */
async function populateMachineData(machineElement, machineData) {
    if (!machineElement || !machineData) {
        console.error('‚ùå Elemento da m√°quina ou dados inv√°lidos');
        return false;
    }

    console.log(`üîß Preenchendo dados da m√°quina:`, machineData);

    try {
        const machineId = machineElement.dataset.machineId;

        // 1. DEFINIR TIPO (se dispon√≠vel)
        const typeSelect = machineElement.querySelector('.machine-type-select');
        if (typeSelect && machineData.tipo) {
            typeSelect.value = machineData.tipo;
            const typeEvent = new Event('change', { bubbles: true });
            typeSelect.dispatchEvent(typeEvent);
            console.log(`‚úÖ Tipo definido: ${machineData.tipo}`);
            
            // Aguardar processamento do tipo
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // 2. DEFINIR CAPACIDADE (se dispon√≠vel e habilitado)
        const powerSelect = machineElement.querySelector('.machine-power-select');
        if (powerSelect && machineData.potencia) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (powerSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da capacidade... (${attempts}/6)`);
            }
            
            if (!powerSelect.disabled) {
                const powerOption = Array.from(powerSelect.options).find(opt => 
                    opt.text.includes(machineData.potencia) || 
                    opt.value.includes(machineData.potencia) ||
                    opt.text.toLowerCase().includes(machineData.potencia.toLowerCase())
                );
                
                if (powerOption) {
                    powerSelect.value = powerOption.value;
                    const powerEvent = new Event('change', { bubbles: true });
                    powerSelect.dispatchEvent(powerEvent);
                    console.log(`‚úÖ Capacidade definida: ${powerOption.value}`);
                    
                    // Aguardar processamento da capacidade
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    console.log(`‚ö†Ô∏è Capacidade "${machineData.potencia}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de capacidade permanece desabilitado`);
            }
        }

        // 3. DEFINIR TENS√ÉO (se dispon√≠vel e habilitado)
        const voltageSelect = machineElement.querySelector('.machine-voltage-select');
        if (voltageSelect && machineData.tensao) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (voltageSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da tens√£o... (${attempts}/6)`);
            }
            
            if (!voltageSelect.disabled) {
                const voltageOption = Array.from(voltageSelect.options).find(opt => 
                    opt.text.includes(machineData.tensao) || 
                    opt.value.includes(machineData.tensao) ||
                    opt.text.toLowerCase().includes(machineData.tensao.toLowerCase())
                );
                
                if (voltageOption) {
                    voltageSelect.value = voltageOption.value;
                    const voltageEvent = new Event('change', { bubbles: true });
                    voltageSelect.dispatchEvent(voltageEvent);
                    console.log(`‚úÖ Tens√£o definida: ${voltageOption.value}`);
                } else {
                    console.log(`‚ö†Ô∏è Tens√£o "${machineData.tensao}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de tens√£o permanece desabilitado`);
            }
        }

        // 4. DEFINIR OP√á√ïES SELECIONADAS (se dispon√≠veis)
        if (machineData.opcoesSelecionadas && Array.isArray(machineData.opcoesSelecionadas)) {
            // Aguardar carregamento das op√ß√µes
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const optionsContainer = machineElement.querySelector('.options-grid');
            
            if (optionsContainer) {
                const allCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                console.log(`üîç Encontrados ${allCheckboxes.length} checkboxes de op√ß√µes`);

                let optionsMarked = 0;
                machineData.opcoesSelecionadas.forEach(optionObj => {
                    // ‚úÖ CORRE√á√ÉO: Suporta tanto array de strings quanto array de objetos
                    let optionName;
                    if (typeof optionObj === 'string') {
                        optionName = optionObj;
                    } else if (typeof optionObj === 'object') {
                        optionName = optionObj.name || optionObj.originalName;
                    }
                    
                    if (!optionName) {
                        console.log(`‚ö†Ô∏è Op√ß√£o inv√°lida:`, optionObj);
                        return;
                    }

                    console.log(`Procurando op√ß√£o: "${optionName}"`);
                    
                    // Buscar pelo data-option-name (mais confi√°vel)
                    const checkbox = Array.from(allCheckboxes).find(cb => {
                        const dataName = cb.getAttribute('data-option-name');
                        return dataName === optionName;
                    });
                    
                    if (checkbox) {
                        checkbox.checked = true;
                        const checkboxEvent = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(checkboxEvent);
                        optionsMarked++;
                        console.log(`‚úÖ Op√ß√£o marcada: ${optionName}`);
                    } else {
                        console.log(`‚ùå Op√ß√£o n√£o encontrada: "${optionName}"`);
                        
                        // Debug: tentar encontrar por texto do label
                        const allOptions = optionsContainer.querySelectorAll('.option-item');
                        const foundByText = Array.from(allOptions).find(optionItem => {
                            const nameElement = optionItem.querySelector('.option-name');
                            return nameElement && nameElement.textContent.includes(optionName);
                        });
                        
                        if (foundByText) {
                            const checkboxInItem = foundByText.querySelector('input[type="checkbox"]');
                            if (checkboxInItem) {
                                checkboxInItem.checked = true;
                                const checkboxEvent = new Event('change', { bubbles: true });
                                checkboxInItem.dispatchEvent(checkboxEvent);
                                optionsMarked++;
                                console.log(`‚úÖ Op√ß√£o marcada (por texto): ${optionName}`);
                            }
                        }
                    }
                });
                
                console.log(`üìä Op√ß√µes marcadas: ${optionsMarked}/${machineData.opcoesSelecionadas.length}`);
            } else {
                console.log(`‚ö†Ô∏è Container de op√ß√µes n√£o encontrado`);
            }
        }

        // 5. DEFINIR PRE√áOS (se dispon√≠veis)
        if (machineData.precoBase !== undefined) {
            const basePriceElement = document.getElementById(`base-price-${machineId}`);
            if (basePriceElement) {
                basePriceElement.textContent = `R$ ${machineData.precoBase.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo base definido: R$ ${machineData.precoBase}`);
            }
        }

        if (machineData.precoTotal !== undefined) {
            const totalPriceElement = document.getElementById(`total-price-${machineId}`);
            if (totalPriceElement) {
                totalPriceElement.textContent = `R$ ${machineData.precoTotal.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo total definido: R$ ${machineData.precoTotal}`);
            }
        }

        // 6. DEFINIR NOME (se dispon√≠vel)
        if (machineData.nome) {
            const nameInput = machineElement.querySelector('.machine-title-editable');
            if (nameInput) {
                nameInput.value = machineData.nome;
                console.log(`‚úÖ Nome definido: ${machineData.nome}`);
            }
        }

        // 7. DISPARAR C√ÅLCULO FINAL
        setTimeout(() => {
            if (typeof calculateMachinePrice === 'function') {
                calculateMachinePrice(machineId);
                console.log('‚úÖ C√°lculo de pre√ßo finalizado');
            }
        }, 500);

        console.log(`‚úÖ Dados da m√°quina preenchidos com sucesso`);
        return true;

    } catch (error) {
        console.error(`‚ùå Erro ao preencher dados da m√°quina:`, error);
        return false;
    }
}

// EXPORTS NO FINAL
export {
    findMachinesSection,
    findSectionByTitle,
    ensureMachinesSection,
    fillMachinesData,
    populateMachineData
};
/* ==== FIM: data/builders/ui-folder/machine-renderer.js ==== */

/* ==== IN√çCIO: data/modules/machines/machines-core.js ==== */
/**
 * data/modules/machines/machines-core.js
 * Sistema unificado de m√°quinas - COM NOMENCLATURA AUTOM√ÅTICA
 * Vers√£o COMPLETA E CORRIGIDA com gera√ß√£o autom√°tica de nomes
 */

import { buildCapacityCalculationTable } from './capacity-calculator.js';
import { updateElementText, safeNumber } from '../../utils/core-utils.js';
import { generateMachineId } from '../../utils/id-generator.js';

// =============================================================================
// CACHE E ESTADO GLOBAL
// =============================================================================

if (typeof window !== 'undefined' && !window.machinesDataCache) {
    window.machinesDataCache = null;
}

// =============================================================================
// FUN√á√ïES CORE UNIFICADAS
// =============================================================================

/**
 * Carrega dados das m√°quinas com cache
 */
async function loadMachinesData() {
    if (window.machinesDataCache?.machines?.length) {
        return window.machinesDataCache;
    }

    try {
        const response = await fetch('/machines');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        const machinesData = { machines: Array.isArray(data) ? data : data.machines };

        window.machinesDataCache = machinesData;
        window.machinesData = machinesData.machines;
        return machinesData;

    } catch (error) {
        console.error("‚ùå Erro ao carregar m√°quinas:", error);
        return window.machinesDataCache || { machines: [] };
    }
}

// =============================================================================
// SISTEMA DE NOMENCLATURA AUTOM√ÅTICA
// =============================================================================

/**
 * üÜï GERA NOME AUTOM√ÅTICO APENAS QUANDO TIPO E CAPACIDADE EST√ÉO SELECIONADOS
 */
function generateMachineName(machineType, roomId, currentMachineId = null) {
    console.log(`üî§ Gerando nome autom√°tico para ${machineType} na sala ${roomId}`);
    
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return machineType; // üÜï RETORNA APENAS O TIPO SE N√ÉO H√Å CAPACIDADE

    // Buscar apenas m√°quinas que TENHAM TIPO E CAPACIDADE SELECIONADOS
    const existingMachines = Array.from(container.querySelectorAll('.climatization-machine'));
    
    const allMachinesData = [];
    
    existingMachines.forEach(machine => {
        const machineId = machine.dataset.machineId;
        const typeSelect = machine.querySelector('.machine-type-select');
        const powerSelect = machine.querySelector('.machine-power-select');
        const titleInput = machine.querySelector('.machine-title-editable');
        
        // üÜï S√ì INCLUI NA L√ìGICA SE TIVER TIPO E CAPACIDADE SELECIONADOS
        if (typeSelect && typeSelect.value === machineType && powerSelect && powerSelect.value) {
            allMachinesData.push({
                machineId: machineId,
                element: machine,
                type: typeSelect.value,
                power: powerSelect.value,
                capacity: powerSelect.value,
                currentName: titleInput ? titleInput.value : '',
                capacityValue: getGenericCapacityValue(powerSelect.value)
            });
        }
    });

    // Adicionar a nova m√°quina (se for o caso) - S√ì SE TIVER CAPACIDADE
    if (currentMachineId && machineType) {
        const currentMachineElement = document.querySelector(`[data-machine-id="${currentMachineId}"]`);
        const powerSelect = currentMachineElement?.querySelector('.machine-power-select');
        const currentPower = powerSelect ? powerSelect.value : '';
        
        if (currentPower) {
            allMachinesData.push({
                machineId: currentMachineId,
                type: machineType,
                power: currentPower,
                capacity: currentPower,
                capacityValue: getGenericCapacityValue(currentPower),
                isNew: true
            });
        } else {
            // üÜï SE N√ÉO TEM CAPACIDADE, RETORNA APENAS O TIPO
            return machineType;
        }
    }

    // üÜï SE N√ÉO H√Å M√ÅQUINAS COM TIPO E CAPACIDADE SELECIONADOS, RETORNA APENAS O TIPO
    if (allMachinesData.length === 0) {
        return machineType;
    }

    // Ordenar por capacidade (decrescente)
    allMachinesData.sort((a, b) => b.capacityValue - a.capacityValue);

    // Agrupar por capacidade
    const capacityGroups = {};
    allMachinesData.forEach(machine => {
        const capacityKey = machine.capacity;
        if (!capacityGroups[capacityKey]) {
            capacityGroups[capacityKey] = [];
        }
        capacityGroups[capacityKey].push(machine);
    });

    // Ordenar grupos por capacidade (decrescente)
    const sortedGroups = Object.entries(capacityGroups)
        .sort(([,groupA], [,groupB]) => {
            const capacityA = groupA[0].capacityValue;
            const capacityB = groupB[0].capacityValue;
            return capacityB - capacityA;
        });

    // Atribuir n√∫meros e letras
    let groupNumber = 1;
    const newNames = {};

    sortedGroups.forEach(([capacityKey, machines]) => {
        // Ordenar m√°quinas dentro do grupo (para consist√™ncia)
        machines.sort((a, b) => a.machineId.localeCompare(b.machineId));
        
        // Atribuir letras
        machines.forEach((machine, index) => {
            const letter = String.fromCharCode(65 + index); // A, B, C...
            const newName = `${machineType}-${groupNumber.toString().padStart(2, '0')}${letter} (${machine.capacity})`;
            newNames[machine.machineId] = newName;
        });
        
        groupNumber++;
    });

    // Retornar o nome para a m√°quina atual ou atualizar todos
    if (currentMachineId) {
        return newNames[currentMachineId] || machineType;
    } else {
        // Atualizar todos os nomes
        Object.entries(newNames).forEach(([machineId, newName]) => {
            const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
            if (machineElement) {
                const titleInput = machineElement.querySelector('.machine-title-editable');
                if (titleInput && titleInput.value !== newName) {
                    titleInput.value = newName;
                }
            }
        });
    }
}

/**
 * üÜï OBT√âM VALOR NUM√âRICO DA CAPACIDADE PARA ORDENA√á√ÉO
 */
function getGenericCapacityValue(powerText) {
    if (!powerText) return 0;
    
    try {
        // Extrair n√∫meros do texto (funciona para BTU, kW, CFM, m¬≥/h, etc.)
        const numericMatch = powerText.match(/(\d+[.,]?\d*)/);
        if (numericMatch) {
            return parseFloat(numericMatch[0].replace(',', '.'));
        }
        return 0;
    } catch (error) {
        console.error('Erro ao obter capacidade:', error);
        return 0;
    }
}

/**
 * üÜï ATUALIZA NOME QUANDO A CAPACIDADE √â ALTERADA
 */
function updateMachineNameOnPowerChange(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');
    const roomId = machineElement.dataset.roomId;
    
    if (typeSelect && typeSelect.value && roomId) {
        // ATUALIZAR TODOS OS NOMES DO MESMO TIPO
        generateMachineName(typeSelect.value, roomId);
    }
}

/**
 * üÜï ATUALIZA TODOS OS NOMES DAS M√ÅQUINAS NA SALA
 */
function updateAllMachineNamesInRoom(roomId) {
    console.log(`üîÑ Atualizando todos os nomes das m√°quinas na sala ${roomId}`);
    
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return;

    // Para cada tipo de m√°quina existente, atualizar os nomes
    const machines = Array.from(container.querySelectorAll('.climatization-machine'));
    const machineTypes = new Set();
    
    machines.forEach(machine => {
        const typeSelect = machine.querySelector('.machine-type-select');
        if (typeSelect && typeSelect.value) {
            machineTypes.add(typeSelect.value);
        }
    });

    // Atualizar nomes para cada tipo
    machineTypes.forEach(type => {
        generateMachineName(type, roomId);
    });
}

// =============================================================================
// CONSTRU√á√ÉO DE UI UNIFICADA
// =============================================================================

/**
 * Constr√≥i se√ß√£o completa de m√°quinas
 */
function buildMachinesSection(obraId, projectId, roomName, finalRoomId) {
    if (!finalRoomId) return '';

    return `
    <div class="section-block">
      <div class="section-header-machine">
        <button class="minimizer" onclick="toggleSection('${finalRoomId}-maquinas')">+</button>
        <h4 class="section-title">M√°quinas</h4>
      </div>
      <div class="section-content collapsed" id="section-content-${finalRoomId}-maquinas">
        ${buildCapacityCalculationTable(finalRoomId)}
        <div class="machines-container" id="machines-${finalRoomId}">
          <p class="empty-message">Nenhuma m√°quina adicionada ainda.</p>
        </div>
        <div class="add-machine">
            <button class="btn btn-add-secondary" onclick="addMachine('${finalRoomId}')">+ Adicionar M√°quina</button> 
        </div>
        <div class="all-machines-total-price">
          <strong>Total de Maquinas: <span id="total-all-machines-price-${finalRoomId}">R$ 0,00</span></strong>
        </div>
      </div>
    </div>`;
}

/**
 * Constr√≥i HTML de m√°quina individual
 */
function buildMachineHTML(machineId, displayName, machines, roomId) {
    const machineTypes = machines.map(m => m.type);

    return `
    <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${roomId}">
      <div class="machine-header">
        <button class="minimizer" onclick="toggleMachineSection(this)">‚àí</button>
        <input type="text" class="machine-title-editable" value="${displayName}" 
               onchange="updateMachineTitle(this, '${machineId}')" onclick="this.select()">
        <button class="btn btn-delete-small" onclick="deleteMachine('${machineId}')">Remover</button>
      </div>
      <div class="machine-content" id="machine-content-${machineId}">
        <div class="climatization-form-grid">
          ${buildFormGroup("Tipo:", buildSelect(machineTypes, machineId, "machine-type-select", "updateMachineOptions(this)"))}
          ${buildFormGroup("Capacidade:", buildSelect([], machineId, "machine-power-select", `handlePowerChange('${machineId}')`, true))}
          ${buildFormGroup("Tens√£o:", buildSelect([], machineId, "machine-voltage-select", `calculateMachinePrice('${machineId}')`, true))}
          ${buildFormGroup("Pre√ßo Base:", `<div class="price-display" id="base-price-${machineId}">R$ 0,00</div>`)}
          ${buildFormGroup("Pre√ßo Total:", `<div class="price-display" id="total-price-${machineId}">R$ 0,00</div>`)}
        </div>
        <div class="machine-options-section">
          <h6>Op√ß√µes Adicionais:</h6>
          <div class="options-grid" id="options-container-${machineId}">
            <p class="empty-options-message">Selecione tipo e capacidade</p>
          </div>
        </div>
        <!-- üÜï SE√á√ÉO DE CONFIGURA√á√ïES -->
        <div class="machine-config-section">
            <h6>Configura√ß√µes de Instala√ß√£o:</h6>
            <div class="config-grid" id="config-container-${machineId}">
                <p class="empty-config-message">Selecione tipo e capacidade</p>
            </div>
        </div>
      </div>
    </div>`;
}

/**
 * Constr√≥i m√°quina a partir de dados salvos
 */
function buildMachineFromSavedData(machineId, savedMachine, allMachines) {
    const machineType = allMachines.find(m => m.type === savedMachine.tipo);
    if (!machineType) return '';

    const potencies = Object.keys(machineType.baseValues || {});
    const voltages = (machineType.voltages || []).map(v => v.name);

    return `
    <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${savedMachine.roomId || ''}">
      <div class="machine-header">
        <input type="text" class="machine-title-editable" value="${savedMachine.nome || 'Maquina'}"
               onchange="updateMachineTitle(this, '${machineId}')" onclick="this.select()">
        <button class="btn btn-delete-small" onclick="deleteMachine('${machineId}')">Remover</button>
      </div>
      <div class="machine-content" id="machine-content-${machineId}">
        <div class="climatization-form-grid">
          ${buildFormGroup("Tipo:", buildSelect(allMachines.map(m => m.type), machineId, "machine-type-select", "updateMachineOptions(this)", false, savedMachine.tipo))}
          ${buildFormGroup("Capacidade:", buildSelect(potencies, machineId, "machine-power-select", `handlePowerChange('${machineId}')`, false, savedMachine.potencia))}
          ${buildFormGroup("Tens√£o:", buildSelect(voltages, machineId, "machine-voltage-select", `calculateMachinePrice('${machineId}')`, false, savedMachine.tensao))}
          ${buildFormGroup("Pre√ßo Base:", `<div class="price-display" id="base-price-${machineId}">R$ 0,00</div>`)}
          ${buildFormGroup("Pre√ßo Total:", `<div class="price-display" id="total-price-${machineId}">R$ ${savedMachine.precoTotal?.toLocaleString("pt-BR") || '0,00'}</div>`)}
        </div>
        <div class="machine-options-section">
          <h6>Op√ß√µes Adicionais:</h6>
          <div class="options-grid" id="options-container-${machineId}">
            ${buildOptionsHTML(machineType.options, machineId, savedMachine.opcoesSelecionadas, savedMachine.potencia)}
          </div>
        </div>
        <!-- üÜï SE√á√ÉO DE CONFIGURA√á√ïES -->
        <div class="machine-config-section">
          <h6>Configura√ß√µes de Instala√ß√£o:</h6>
          <div class="config-grid" id="config-container-${machineId}">
            ${buildConfigHTML(machineType.configuracoes_instalacao, machineId, savedMachine.configuracoesSelecionadas, savedMachine.potencia)}
          </div>
        </div>
      </div>
    </div>`;
}

// =============================================================================
// COMPONENTES UI REUTILIZ√ÅVEIS
// =============================================================================

/**
 * Constr√≥i grupo de formul√°rio
 */
function buildFormGroup(label, content) {
    return `<div class="form-group"><label>${label}</label>${content}</div>`;
}

/**
 * Constr√≥i elemento select
 */
function buildSelect(options, machineId, className, onchangeHandler, disabled = false, selectedValue = '') {
    const disabledAttr = disabled ? 'disabled' : '';
    const optionsHTML = options.map(opt =>
        `<option value="${opt}" ${opt === selectedValue ? 'selected' : ''}>${opt}</option>`
    ).join('');

    return `
    <select class="form-input ${className}" data-machine-id="${machineId}" 
            onchange="${onchangeHandler}" ${disabledAttr}>
      <option value="">Selecionar</option>${optionsHTML}
    </select>`;
}

/**
 * Constr√≥i op√ß√µes da m√°quina
 */
function buildOptionsHTML(options, machineId, selectedOptions = [], selectedPower = null) {
    if (!options?.length) return '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel</p>';

    return options.map(option => {
        const isChecked = selectedOptions.some(selected => selected.id === option.id);
        const optionValue = selectedPower && option.values?.[selectedPower] || 0;
        const displayValue = `+R$ ${optionValue.toLocaleString("pt-BR")}`;

        return `
        <div class="option-item ${isChecked ? 'option-selected' : ''}" onclick="toggleOption('${machineId}', ${option.id})">
          <div class="option-checkbox">
            <input type="checkbox" value="${optionValue}" data-option-id="${option.id}" 
                   data-option-name="${option.name}" id="option-${machineId}-${option.id}"
                   onchange="updateOptionSelection('${machineId}', ${option.id}); calculateMachinePrice('${machineId}')"
                   ${isChecked ? 'checked' : ''}>
            <div class="option-content">
              <div class="option-name">${option.name}</div>
              <div class="option-price">${displayValue}</div>
            </div>
          </div>
        </div>`;
    }).join('');
}

/**
 * CONSTR√ìI HTML DAS CONFIGURA√á√ïES DE INSTALA√á√ÉO
 */
function buildConfigHTML(configuracoes, machineId, configuracoesSelecionadas = [], potencia = '') {
    console.log(`üî® buildConfigHTML: ${configuracoes?.length || 0} configura√ß√µes para ${machineId}`);

    if (!configuracoes || !Array.isArray(configuracoes) || configuracoes.length === 0) {
        return '<p class="empty-config-message">Nenhuma configura√ß√£o dispon√≠vel</p>';
    }
    
    console.log(`‚úÖ Gerando HTML para ${configuracoes.length} configura√ß√µes`);
    
    const html = configuracoes.map(config => {
        const isChecked = Array.isArray(configuracoesSelecionadas) 
            ? configuracoesSelecionadas.some(selected => selected.id === config.id)
            : false;
        
        // IDENTIFICAR CONFIGURA√á√ïES EXCLUSIVAS
        const configName = config.nome;
        const isBocalInsuflamento = configName === "Bocal de insuflamento protegido por grelha diretamente no ambiente";
        const isBocalAcoplado = configName === "Bocal acoplado √† rede de dutos por lona flex√≠vel. Distribui√ß√£o por grelhas";
        const isExclusiveGroup = isBocalInsuflamento || isBocalAcoplado;
        
        const configElement = `
        <div class="config-option ${isChecked ? 'config-selected' : ''} ${isExclusiveGroup ? 'exclusive-group' : ''}" 
             onclick="toggleConfig('${machineId}', ${config.id})">
            <div class="config-checkbox">
                <input type="checkbox" data-config-id="${config.id}" 
                       data-config-name="${configName}" 
                       data-exclusive-group="${isExclusiveGroup ? 'bocal-distribuicao' : ''}"
                       id="config-${machineId}-${config.id}"
                       onchange="handleConfigChange('${machineId}', ${config.id})"
                       ${isChecked ? 'checked' : ''}>
                <div class="config-content">
                    <div class="config-name">${configName}</div>
                </div>
            </div>
        </div>`;
        
        console.log(`   Config ${config.id}: "${configName}" ${isExclusiveGroup ? '(EXCLUSIVA)' : ''}`);
        return configElement;
    }).join('');
    
    console.log(`üì¶ HTML final gerado com ${configuracoes.length} configura√ß√µes`);
    return html;
}

// =============================================================================
// GERENCIAMENTO DE M√ÅQUINAS
// =============================================================================

/**
 * Adiciona nova m√°quina COM NOME SIMPLES INICIAL
 */
async function addMachine(roomId) {
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return;

    const machineId = generateMachineId(roomId);
    const machineCount = container.querySelectorAll(".climatization-machine").length;

    try {
        const machinesData = await loadMachinesData();
        if (!machinesData.machines.length) throw new Error("Nenhum dado dispon√≠vel");

        // üÜï NOME SIMPLES INICIAL - SEM TIPO DEFINIDO
        const autoName = `Maquina ${machineCount + 1}`;

        const machineHTML = buildMachineHTML(machineId, autoName, machinesData.machines, roomId);
        container.insertAdjacentHTML("beforeend", machineHTML);

        // Remove mensagem de vazio
        const emptyMsg = container.querySelector('.empty-message');
        if (emptyMsg) emptyMsg.remove();

        updateAllMachinesTotal(roomId);
        console.log(`‚úÖ M√°quina ${autoName} adicionada √† sala ${roomId}`);
        return true;
    } catch (error) {
        console.error("‚ùå Erro ao adicionar m√°quina:", error);
        showEmptyMessage(container, "Erro ao carregar dados");
    }
}

/**
 * Carrega m√°quinas salvas
 */
async function loadSavedMachines(roomId, savedMachines) {
    if (!savedMachines?.length || !roomId) return;

    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return;

    try {
        const machinesData = await loadMachinesData();

        savedMachines.forEach((savedMachine, index) => {
            const machineId = generateMachineId(roomId);
            const machineHTML = buildMachineFromSavedData(machineId, savedMachine, machinesData.machines);
            container.insertAdjacentHTML("beforeend", machineHTML);
        });

        // Atualiza valores ap√≥s carregamento
        setTimeout(() => {
            container.querySelectorAll('.climatization-machine').forEach((element, index) => {
                const machineId = element.dataset.machineId;
                const savedMachine = savedMachines[index];
                if (savedMachine?.potencia) {
                    updateOptionValues(machineId);
                    calculateMachinePrice(machineId);
                }
            });
            updateAllMachinesTotal(roomId);
        }, 200);

    } catch (error) {
        console.error("‚ùå Erro ao carregar m√°quinas salvas:", error);
    }
}

// =============================================================================
// ATUALIZA√á√ÉO DE UI
// =============================================================================

/**
 * Atualiza op√ß√µes da m√°quina - APENAS ATUALIZA NOME SE TIVER CAPACIDADE
 */
async function updateMachineOptions(selectElement) {
    const machineId = selectElement.dataset.machineId;
    const selectedType = selectElement.value;

    console.log(`üîÑ updateMachineOptions: ${selectedType} para ${machineId}`);

    if (!selectedType) {
        resetMachineFields(machineId);
        
        // SE DESSELECIONOU O TIPO, VOLTA PARA NOME SIMPLES
        const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
        if (machineElement) {
            const titleInput = machineElement.querySelector('.machine-title-editable');
            const container = document.getElementById(`machines-${machineElement.dataset.roomId}`);
            const machineCount = container ? container.querySelectorAll(".climatization-machine").length : 1;
            
            if (titleInput && !titleInput.value.includes('Maquina')) {
                titleInput.value = `Maquina ${machineCount}`;
            }
        }
        return;
    }

    try {
        const machinesData = window.machinesData || [];
        const machine = machinesData.find(m => m.type === selectedType);

        if (machine) {
            console.log(`‚úÖ M√°quina encontrada: ${machine.type}`);
            
            // üÜï ATUALIZA A UI MAS N√ÉO APLICA NOME AUTOM√ÅTICO AINDA
            updateMachineUI(machineId, machine);
            
            // üÜï S√ì APLICA NOME AUTOM√ÅTICO SE J√Å TIVER CAPACIDADE SELECIONADA
            const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
            if (machineElement) {
                const powerSelect = machineElement.querySelector('.machine-power-select');
                if (powerSelect && powerSelect.value) {
                    const roomId = machineElement.dataset.roomId;
                    const newName = generateMachineName(selectedType, roomId, machineId);
                    
                    const titleInput = machineElement.querySelector('.machine-title-editable');
                    if (titleInput) {
                        titleInput.value = newName;
                    }
                } else {
                    // üÜï SE N√ÉO TEM CAPACIDADE, APENAS COLOCA O TIPO
                    const titleInput = machineElement.querySelector('.machine-title-editable');
                    if (titleInput) {
                        titleInput.value = selectedType;
                    }
                }
            }
            
        } else {
            console.log(`‚ùå M√°quina n√£o encontrada: ${selectedType}`);
            resetMachineFields(machineId);
        }
    } catch (error) {
        console.error("‚ùå Erro em updateMachineOptions:", error);
        resetMachineFields(machineId);
    }
}

/**
 * ATUALIZA UI COMPLETA DA M√ÅQUINA
 */
function updateMachineUI(machineId, machine) {
    console.log(`üé® updateMachineUI: ${machine.type} para ${machineId}`);
    
    const potencies = Object.keys(machine.baseValues || {});
    const voltages = (machine.voltages || []).map(v => v.name);

    // Atualizar selects
    updateSelectUI(`.machine-power-select[data-machine-id="${machineId}"]`, potencies, false);
    updateSelectUI(`.machine-voltage-select[data-machine-id="${machineId}"]`, voltages, false);

    // Atualizar op√ß√µes
    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.innerHTML = machine.options?.length
            ? buildOptionsHTML(machine.options, machineId)
            : '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel</p>';
    }

    // ATUALIZAR CONFIGURA√á√ïES
    const configContainer = document.getElementById(`config-container-${machineId}`);
    console.log(`üîç Container encontrado:`, configContainer);

    if (configContainer) {
        if (machine.configuracoes_instalacao?.length) {
            console.log(`üöÄ Inserindo ${machine.configuracoes_instalacao.length} configura√ß√µes`);
            
            const configHTML = buildConfigHTML(machine.configuracoes_instalacao, machineId);
            console.log(`üìù HTML gerado:`, configHTML);
            
            configContainer.innerHTML = '';
            configContainer.insertAdjacentHTML('beforeend', configHTML);
            
            setTimeout(() => {
                const insertedOptions = configContainer.querySelectorAll('.config-option');
                console.log(`‚úÖ Configura√ß√µes inseridas: ${insertedOptions.length} op√ß√µes`);
            }, 50);
            
        } else {
            configContainer.innerHTML = '<p class="empty-config-message">Nenhuma configura√ß√£o dispon√≠vel</p>';
        }
    } else {
        console.error(`‚ùå Container config-container-${machineId} n√£o encontrado`);
    }

    updateElementText(`base-price-${machineId}`, 'R$ 0,00');
    updateElementText(`total-price-${machineId}`, 'R$ 0,00');
}

/**
 * Atualiza select na UI
 */
function updateSelectUI(selector, options, disabled = false) {
    const select = document.querySelector(selector);
    if (select) {
        select.innerHTML = `<option value="">Selecionar</option>${options.map(opt => `<option value="${opt}">${opt}</option>`).join('')}`;
        select.disabled = disabled;
    }
}

/**
 * RESETA CAMPOS DA M√ÅQUINA
 */
function resetMachineFields(machineId) {
    updateSelectUI(`.machine-power-select[data-machine-id="${machineId}"]`, [], true);
    updateSelectUI(`.machine-voltage-select[data-machine-id="${machineId}"]`, [], true);

    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.innerHTML = '<p class="empty-options-message">Selecione um tipo de m√°quina</p>';
    }

    const configContainer = document.getElementById(`config-container-${machineId}`);
    if (configContainer) {
        configContainer.innerHTML = '<p class="empty-config-message">Selecione um tipo de m√°quina</p>';
    }

    updateElementText(`base-price-${machineId}`, 'R$ 0,00');
    updateElementText(`total-price-${machineId}`, 'R$ 0,00');
}

// =============================================================================
// C√ÅLCULOS DE PRE√áO
// =============================================================================

/**
 * Calcula pre√ßo da m√°quina
 */
function calculateMachinePrice(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');
    const voltageSelect = machineElement.querySelector('.machine-voltage-select');

    const selectedType = typeSelect?.value;
    const selectedPower = powerSelect?.value;
    const selectedVoltage = voltageSelect?.value;

    let basePrice = 0, voltageValue = 0;

    // Pre√ßo base
    if (selectedType && selectedPower && window.machinesData) {
        const machine = window.machinesData.find(m => m.type === selectedType);
        basePrice = machine?.baseValues?.[selectedPower] || 0;
    }

    // Valor da tens√£o
    if (selectedType && selectedVoltage && window.machinesData) {
        const machine = window.machinesData.find(m => m.type === selectedType);
        const voltageObj = machine?.voltages?.find(v => v.name === selectedVoltage);
        voltageValue = voltageObj?.value || 0;
    }

    // Total das op√ß√µes
    let optionsTotal = 0;
    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(option => {
            optionsTotal += safeNumber(option.value);
        });
    }

    const totalPrice = basePrice + optionsTotal + voltageValue;

    updateElementText(`base-price-${machineId}`, `R$ ${basePrice.toLocaleString("pt-BR")}`);
    updateElementText(`total-price-${machineId}`, `R$ ${totalPrice.toLocaleString("pt-BR")}`);

    // Atualiza total geral
    const roomId = machineElement.dataset.roomId;
    if (roomId) updateAllMachinesTotal(roomId);
}

/**
 * Atualiza valores das op√ß√µes
 */
function updateOptionValues(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');

    const selectedType = typeSelect?.value;
    const selectedPower = powerSelect?.value;

    if (!selectedType || !selectedPower || !window.machinesData) return;

    const machine = window.machinesData.find(m => m.type === selectedType);
    if (!machine?.options) return;

    machine.options.forEach(option => {
        const checkbox = document.getElementById(`option-${machineId}-${option.id}`);
        if (checkbox) {
            const optionValue = selectedPower && option.values?.[selectedPower] || 0;
            checkbox.value = optionValue;

            const priceDisplay = checkbox.closest('.option-item')?.querySelector('.option-price');
            if (priceDisplay) {
                priceDisplay.textContent = `+R$ ${optionValue.toLocaleString("pt-BR")}`;
            }
        }
    });

    calculateMachinePrice(machineId);
}

// =============================================================================
// GERENCIAMENTO DE TOTAL GERAL
// =============================================================================

/**
 * Calcula total de todas as m√°quinas
 */
function calculateAllMachinesTotal(roomId) {
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return 0;

    let total = 0;
    container.querySelectorAll('.climatization-machine').forEach(machineElement => {
        const machineId = machineElement.dataset.machineId;
        const priceElement = document.getElementById(`total-price-${machineId}`);
        if (priceElement) {
            const priceText = priceElement.textContent;
            const cleanText = priceText.replace('R$', '').replace(/\./g, '').replace(',', '.').trim();
            total += safeNumber(cleanText);
        }
    });

    return total;
}

/**
 * Atualiza display do total geral
 */
function updateAllMachinesTotal(roomId) {
    const total = calculateAllMachinesTotal(roomId);
    const display = document.getElementById(`total-all-machines-price-${roomId}`);
    if (display) {
        display.textContent = `R$ ${total.toLocaleString('pt-BR')}`;
    }
    saveTotalToRoom(roomId, total);
}

/**
 * Salva total no servidor
 */
function saveTotalToRoom(roomId, total) {
    fetch('/obras')
        .then(response => response.ok ? response.json() : [])
        .then(obras => {
            for (const obra of obras) {
                for (const projeto of obra.projetos || []) {
                    for (const sala of projeto.salas || []) {
                        if (sala.id === roomId) {
                            sala.somavaloresmaquinatotal = total;
                            return fetch(`/obras/${obra.id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(obra)
                            });
                        }
                    }
                }
            }
        })
        .catch(error => console.error('‚ùå Erro ao salvar total:', error));
}

// =============================================================================
// FUN√á√ïES DE INTERA√á√ÉO DO USU√ÅRIO
// =============================================================================

function toggleMachineSection(button) {
    const content = button.closest(".climatization-machine").querySelector(".machine-content");
    const isCollapsed = content.classList.toggle("collapsed");
    button.textContent = isCollapsed ? "+" : "‚àí";
}

function updateMachineTitle(input, machineId) {
    if (!input.value.trim()) {
        // üÜï SE O USU√ÅRIO APAGAR O NOME, VOLTA PARA NOME SIMPLES
        const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
        const container = document.getElementById(`machines-${machineElement.dataset.roomId}`);
        const machineCount = container ? container.querySelectorAll(".climatization-machine").length : 1;
        input.value = `Maquina ${machineCount}`;
    }
}

function toggleOption(machineId, optionId) {
    const checkbox = document.getElementById(`option-${machineId}-${optionId}`);
    if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
    }
}

function updateOptionSelection(machineId, optionId) {
    const checkbox = document.getElementById(`option-${machineId}-${optionId}`);
    const item = checkbox?.closest('.option-item');
    if (item) {
        item.classList.toggle('option-selected', checkbox.checked);
    }
}

/**
 * Atualiza quando a capacidade muda - AGORA SIM APLICA A L√ìGICA COMPLETA
 */
function handlePowerChange(machineId) {
    calculateMachinePrice(machineId);
    updateOptionValues(machineId);
    
    // üÜï ATUALIZAR NOME QUANDO A CAPACIDADE MUDAR - AGORA COM L√ìGICA COMPLETA
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (machineElement) {
        const typeSelect = machineElement.querySelector('.machine-type-select');
        const powerSelect = machineElement.querySelector('.machine-power-select');
        const roomId = machineElement.dataset.roomId;
        
        if (typeSelect && typeSelect.value && powerSelect && powerSelect.value) {
            // ATUALIZAR TODOS OS NOMES DO MESMO TIPO
            generateMachineName(typeSelect.value, roomId);
        } else if (typeSelect && typeSelect.value && (!powerSelect || !powerSelect.value)) {
            // üÜï SE TEM TIPO MAS N√ÉO TEM CAPACIDADE, VOLTA PARA APENAS O TIPO
            const titleInput = machineElement.querySelector('.machine-title-editable');
            if (titleInput) {
                titleInput.value = typeSelect.value;
            }
        }
    }
}

function deleteMachine(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const roomId = machineElement.dataset.roomId;
    const container = machineElement.closest(".machines-container");

    machineElement.remove();

    // ATUALIZAR NOMES DAS M√ÅQUINAS RESTANTES
    if (roomId) {
        updateAllMachineNamesInRoom(roomId);
        updateAllMachinesTotal(roomId);
    }

    // Mostra mensagem se n√£o houver m√°quinas
    if (container && container.querySelectorAll('.climatization-machine').length === 0) {
        showEmptyMessage(container, "Nenhuma m√°quina adicionada ainda.");
    }
}

// =============================================================================
// FUN√á√ïES DE INTERA√á√ÉO PARA CONFIGURA√á√ïES
// =============================================================================

/**
 * Alterna o estado de uma configura√ß√£o
 */
function toggleConfig(machineId, configId) {
    const checkbox = document.getElementById(`config-${machineId}-${configId}`);
    if (checkbox) {
        checkbox.checked = !checkbox.checked;
        handleConfigChange(machineId, configId);
    }
}

/**
 * Atualiza a sele√ß√£o visual da configura√ß√£o
 */
function updateConfigSelection(machineId, configId) {
    const checkbox = document.getElementById(`config-${machineId}-${configId}`);
    const item = checkbox?.closest('.config-option');
    if (item) {
        item.classList.toggle('config-selected', checkbox.checked);
    }
}

/**
 * MANIPULA MUDAN√áAS NAS CONFIGURA√á√ïES COM L√ìGICA EXCLUSIVA
 */
function handleConfigChange(machineId, configId) {
    console.log(`üîÑ handleConfigChange: m√°quina ${machineId}, config ${configId}`);
    
    const checkbox = document.getElementById(`config-${machineId}-${configId}`);
    if (!checkbox) return;
    
    const configName = checkbox.getAttribute('data-config-name');
    const isExclusiveGroup = checkbox.getAttribute('data-exclusive-group') === 'bocal-distribuicao';
    
    console.log(`üîç Configura√ß√£o: "${configName}", Exclusiva: ${isExclusiveGroup}, Marcada: ${checkbox.checked}`);
    
    // ATUALIZA√á√ÉO VISUAL
    updateConfigSelection(machineId, configId);
    
    // L√ìGICA DE SELE√á√ÉO EXCLUSIVA
    if (isExclusiveGroup && checkbox.checked) {
        console.log(`üö´ Aplicando l√≥gica exclusiva para configura√ß√£o "${configName}"`);
        deselectOtherBocalOptions(machineId, configId);
    }
    
    // RECALCULAR PRE√áO (se necess√°rio)
    calculateMachinePrice(machineId);
}

/**
 * DESMARCA OUTRAS OP√á√ïES DO GRUPO EXCLUSIVO "BOCAL"
 */
function deselectOtherBocalOptions(machineId, selectedConfigId) {
    console.log(`üö´ Desmarcando outras op√ß√µes do grupo bocal, exceto ${selectedConfigId}`);
    
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;
    
    const bocalCheckboxes = machineElement.querySelectorAll('input[data-exclusive-group="bocal-distribuicao"]');
    
    console.log(`üîç Encontradas ${bocalCheckboxes.length} checkboxes do grupo bocal`);
    
    bocalCheckboxes.forEach(checkbox => {
        const configId = parseInt(checkbox.getAttribute('data-config-id'));
        const configName = checkbox.getAttribute('data-config-name');
        
        if (configId !== selectedConfigId && checkbox.checked) {
            console.log(`‚ùå Desmarcando configura√ß√£o ${configId}: "${configName}"`);
            checkbox.checked = false;
            updateConfigSelection(machineId, configId);
        }
    });
}

// =============================================================================
// FUN√á√ïES AUXILIARES
// =============================================================================

function showEmptyMessage(container, message) {
    const existing = container.querySelector('.empty-message');
    if (existing) existing.remove();
    container.insertAdjacentHTML('beforeend', `<p class="empty-message">${message}</p>`);
}

function removeEmptyMessage(container) {
    const emptyMsg = container.querySelector('.empty-message');
    if (emptyMsg) emptyMsg.remove();
}

// =============================================================================
// EXPORTA√á√ïES E GLOBAIS
// =============================================================================

export {
    buildMachinesSection,
    loadMachinesData,
    loadSavedMachines,
    addMachine,
    buildMachineHTML,
    toggleMachineSection,
    updateMachineTitle,
    updateMachineOptions,
    updateMachineUI,
    resetMachineFields,
    calculateMachinePrice,
    deleteMachine,
    toggleOption,
    updateOptionSelection,
    updateOptionValues,
    handlePowerChange,
    calculateAllMachinesTotal,
    updateAllMachinesTotal,
    generateMachineId,
    buildConfigHTML,
    toggleConfig,
    updateConfigSelection,
    handleConfigChange, 
    deselectOtherBocalOptions, 
    buildOptionsHTML,
    updateSelectUI,
    showEmptyMessage,
    removeEmptyMessage,
    // üÜï FUN√á√ïES DE NOMENCLATURA AUTOM√ÅTICA
    generateMachineName,
    getGenericCapacityValue,
    updateAllMachineNamesInRoom,
    updateMachineNameOnPowerChange
};

// üÜï DISPONIBILIZA√á√ÉO GLOBAL COMPLETA
if (typeof window !== 'undefined') {
    const functions = {
        // Fun√ß√µes principais
        addMachine,
        toggleMachineSection,
        updateMachineTitle,
        updateMachineOptions,
        updateMachineUI,
        resetMachineFields,
        calculateMachinePrice,
        deleteMachine,
        
        // Op√ß√µes
        toggleOption,
        updateOptionSelection,
        updateOptionValues,
        handlePowerChange,
        
        // CONFIGURA√á√ïES 
        buildConfigHTML,
        toggleConfig,
        updateConfigSelection,
        handleConfigChange, 
        deselectOtherBocalOptions, 
        
        // Totais
        calculateAllMachinesTotal,
        updateAllMachinesTotal,
        
        // Utilit√°rios
        loadSavedMachines,
        generateMachineId,
        buildOptionsHTML,
        updateSelectUI,
        showEmptyMessage,
        removeEmptyMessage,
        
        // üÜï NOMENCLATURA AUTOM√ÅTICA
        generateMachineName,
        getGenericCapacityValue,
        updateAllMachineNamesInRoom,
        updateMachineNameOnPowerChange
    };

    Object.assign(window, functions);
    console.log('‚úÖ Todas as fun√ß√µes de m√°quinas carregadas no escopo global (incluindo nomenclatura autom√°tica)');
}

// ‚úÖ GARANTIR QUE AS FUN√á√ïES ESTEJAM DISPON√çVEIS
setTimeout(() => {
    if (typeof window !== 'undefined') {
        if (!window.generateMachineName) {
            window.generateMachineName = generateMachineName;
            console.log('‚úÖ generateMachineName for√ßada no escopo global');
        }
        if (!window.updateAllMachineNamesInRoom) {
            window.updateAllMachineNamesInRoom = updateAllMachineNamesInRoom;
            console.log('‚úÖ updateAllMachineNamesInRoom for√ßada no escopo global');
        }
    }
}, 2000);
/* ==== FIM: data/modules/machines/machines-core.js ==== */

/* ==== IN√çCIO: data/builders/data-builders-folder/machines-data-extractors.js ==== */
import { getMachineName, parseMachinePrice } from '../../utils/data-utils.js';

/**
 * Extrai dados das m√°quinas de climatiza√ß√£o de uma sala
 */
function extractMachinesData(roomElement) {
    const machines = [];
    
    if (!roomElement?.dataset.roomId) {
        console.error('‚ùå Elemento da sala inv√°lido para extra√ß√£o de m√°quinas');
        return machines;
    }
    
    const machineElements = roomElement.querySelectorAll('.climatization-machine');
    
    machineElements.forEach(machineElement => {
        const machineData = extractClimatizationMachineData(machineElement);
        if (machineData) {
            machines.push(machineData);
        }
    });
    
    console.log(`ü§ñ ${machines.length} m√°quina(s) extra√≠da(s) da sala ${roomElement.dataset.roomId}`);
    return machines;
}

/**
 * Extrai dados de uma m√°quina de climatiza√ß√£o individual
 */
function extractClimatizationMachineData(machineElement) {
    if (!machineElement) {
        console.error('‚ùå Elemento da m√°quina √© nulo');
        return null;
    }

    const machineId = machineElement.getAttribute('data-machine-id') || `machine-${Date.now()}`;
    const roomId = machineElement.getAttribute('data-room-id');

    console.log(`üîß Extraindo dados da m√°quina ${machineId} na sala ${roomId}`);

    const machineData = {
        nome: getMachineName(machineElement, machineId),
        tipo: machineElement.querySelector('.machine-type-select')?.value || '',
        potencia: machineElement.querySelector('.machine-power-select')?.value || '',
        tensao: machineElement.querySelector('.machine-voltage-select')?.value || '',
        precoBase: 0,
        opcoesSelecionadas: [],
        configuracoesSelecionadas: [], // üÜï NOVO CAMPO
        precoTotal: 0,
        potenciaSelecionada: machineElement.querySelector('.machine-power-select')?.value || '',
        tipoSelecionado: machineElement.querySelector('.machine-type-select')?.value || ''
    };

    try {
        // Pre√ßo base
        const basePriceElement = document.getElementById(`base-price-${machineId}`);
        if (basePriceElement) {
            machineData.precoBase = parseMachinePrice(basePriceElement.textContent);
        }

        // Op√ß√µes selecionadas
        const selectedOptions = [];
        const optionCheckboxes = machineElement.querySelectorAll('#options-container-' + machineId + ' input[type="checkbox"]:checked');
        
        optionCheckboxes.forEach((checkbox, index) => {
            const optionId = checkbox.getAttribute('data-option-id') || (index + 1).toString();
            const optionValue = parseFloat(checkbox.value) || 0;
            const optionName = checkbox.getAttribute('data-option-name') || `Op√ß√£o ${optionId}`;
            
            selectedOptions.push({
                id: parseInt(optionId) || (index + 1),
                name: optionName.replace(/\s*R\$\s*[\d.,]+/, '').trim(),
                value: optionValue,
                originalName: optionName,
                potenciaAplicada: machineData.potencia
            });
        });

        machineData.opcoesSelecionadas = selectedOptions;

        // üÜï CONFIGURA√á√ïES SELECIONADAS (SEM VALORES)
        const selectedConfigs = [];
        const configCheckboxes = machineElement.querySelectorAll('#config-container-' + machineId + ' input[type="checkbox"]:checked');
        
        configCheckboxes.forEach((checkbox, index) => {
            const configId = checkbox.getAttribute('data-config-id') || (index + 1).toString();
            const configName = checkbox.getAttribute('data-config-name') || `Configura√ß√£o ${configId}`;
            
            selectedConfigs.push({
                id: parseInt(configId) || (index + 1),
                nome: configName,
            });
        });

        machineData.configuracoesSelecionadas = selectedConfigs;

        // Pre√ßo total
        const totalPriceElement = document.getElementById(`total-price-${machineId}`);
        if (totalPriceElement) {
            machineData.precoTotal = parseMachinePrice(totalPriceElement.textContent);
        } else {
            machineData.precoTotal = machineData.precoBase + 
                selectedOptions.reduce((sum, option) => sum + option.value, 0);
            // üÜï CONFIGURA√á√ïES N√ÉO AFETAM O PRE√áO
        }

        console.log(`‚úÖ M√°quina ${machineId} extra√≠da:`, {
            nome: machineData.nome,
            tipo: machineData.tipo,
            potencia: machineData.potencia,
            precoBase: machineData.precoBase,
            opcoes: machineData.opcoesSelecionadas.length,
            configuracoes: machineData.configuracoesSelecionadas.length,
            precoTotal: machineData.precoTotal
        });

        return machineData;

    } catch (error) {
        console.error(`‚ùå Erro ao extrair dados da m√°quina ${machineId}:`, error);
        return machineData;
    }
}

// EXPORTS NO FINAL
export {
    extractMachinesData,
    extractClimatizationMachineData
};
/* ==== FIM: data/builders/data-builders-folder/machines-data-extractors.js ==== */
