
/* ==== IN√çCIO: data/builders/empresa-cadastro-inline.js ==== */
/**
 * features/empresa-cadastro-inline.js
 * Sistema de cadastro inline de empresas para P√°gina 1
 * Integra√ß√£o com dados.json (empresas) e backup.json (obras)
 */

import { showSystemStatus } from '../../ui/components/status.js';
import { extractNumberFromText } from '../../data/utils/data-utils.js';

class EmpresaCadastroInline {
    constructor() {
        this.empresas = [];
        this.obrasExistentes = [];
        this.container = null;
        this.isActive = false;
        
        this.init();
    }

    async init() {
        await this.carregarDados();
        this.vincularEventos();
    }

    async carregarDados() {
        try {
            // Carregar empresas do dados.json
            const responseEmpresas = await fetch('/api/dados/empresas');
            if (responseEmpresas.ok) {
                const dados = await responseEmpresas.json();
                this.empresas = dados.empresas || [];
            }

            // Carregar obras existentes do backup.json
            const responseBackup = await fetch('/api/backup-completo');
            if (responseBackup.ok) {
                const backup = await responseBackup.json();
                this.obrasExistentes = backup.obras || [];
            }

            console.log(`üìä Dados carregados: ${this.empresas.length} empresas, ${this.obrasExistentes.length} obras`);
        } catch (error) {
            console.error('‚ùå Erro ao carregar dados:', error);
        }
    }

    vincularEventos() {
        // Encontrar todos os spans de cadastro de empresas e transformar em bot√µes
        const spansCadastro = document.querySelectorAll('.projetc-header-record.very-dark span');
        
        spansCadastro.forEach(span => {
            // Transformar span em bot√£o
            const button = document.createElement('button');
            button.className = 'btn-empresa-cadastro';
            button.textContent = span.textContent;
            button.setAttribute('type', 'button');
            
            // Substituir span por bot√£o
            span.parentNode.replaceChild(button, span);
            
            // Vincular eventos
            button.addEventListener('click', (e) => this.ativarCadastro(e));
            button.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.ativarCadastro(e);
                }
            });
        });
    }

    ativarCadastro(event) {
        if (this.isActive) return;

        const span = event.target;
        this.container = span.closest('.projetc-header-record');
        
        if (!this.container) {
            console.error('‚ùå Container n√£o encontrado');
            return;
        }

        // Ocultar span e mostrar formul√°rio inline
        span.style.display = 'none';
        this.renderizarFormulario();
        this.isActive = true;

        console.log('‚úÖ Cadastro inline ativado');
    }

    /**
     * üÜï RENDERIZAR FORMUL√ÅRIO COM CAMPOS CORRETAMENTE LIBERADOS/BLOQUEADOS
     */
    renderizarFormulario() {
        const formHTML = this.criarHTMLFormulario();
        this.container.insertAdjacentHTML('beforeend', formHTML);
        
        // üÜï CONFIGURAR ESTADO DOS CAMPOS AP√ìS RENDERIZA√á√ÉO
        this.configurarEstadoCampos();
        
        // Vincular eventos do formul√°rio
        this.vincularEventosFormulario();
        
        // Focar no primeiro campo
        setTimeout(() => {
            const empresaInput = this.container.querySelector('#empresa-input');
            if (empresaInput) empresaInput.focus();
        }, 100);
    }

    /**
     * üÜï CONFIGURAR ESTADO CORRETO DOS CAMPOS - LIBERADOS vs BLOQUEADOS
     */
    configurarEstadoCampos() {
        // üü¢ CAMPOS QUE DEVEM FICAR SEMPRE LIBERADOS (edit√°veis)
        const camposLiberados = [
            'empresa-input',
            'cliente-final', 
            'codigo-cliente',
            'data-cadastro',
            'orcamentista-responsavel'
        ];
        
        camposLiberados.forEach(campoId => {
            const campo = this.container.querySelector(`#${campoId}`);
            if (campo) {
                // üü¢ REMOVER COMPLETAMENTE READONLY E DISABLED
                campo.removeAttribute('readonly');
                campo.removeAttribute('disabled');
                
                // üü¢ GARANTIR QUE ESTEJAM EDIT√ÅVEIS
                campo.readOnly = false;
                campo.disabled = false;
                
                // üü¢ ESTILOS VISUAIS DE CAMPO EDIT√ÅVEL
                campo.style.backgroundColor = '#ffffff';
                campo.style.borderColor = '#007bff';
                campo.style.cursor = 'text';
                campo.style.color = '#000000';
                
                console.log(`üü¢ Campo LIBERADO: ${campoId}`);
            }
        });
        
        // üî¥ CAMPOS QUE DEVEM FICAR BLOQUEADOS (somente leitura)
        const camposBloqueados = [
            'numero-cliente-final'
        ];
        
        camposBloqueados.forEach(campoId => {
            const campo = this.container.querySelector(`#${campoId}`);
            if (campo) {
                // üî¥ MANTER COMO SOMENTE LEITURA
                campo.readOnly = true;
                campo.setAttribute('readonly', 'true');
                
                // üî¥ ESTILOS VISUAIS DE CAMPO BLOQUEADO
                campo.style.backgroundColor = '#f8f9fa';
                campo.style.borderColor = '#ced4da';
                campo.style.cursor = 'not-allowed';
                campo.style.color = '#6c757d';
                
                console.log(`üî¥ Campo BLOQUEADO: ${campoId}`);
            }
        });
        
        // üü¢ CONFIGURA√á√ÉO ESPECIAL PARA O CAMPO DE DATA
        this.configurarCampoData();
    }

    /**
     * üÜï CONFIGURAR CAMPO DE DATA COMO EDIT√ÅVEL
     */
    configurarCampoData() {
        const dataCampo = this.container.querySelector('#data-cadastro');
        if (dataCampo) {
            // üü¢ REMOVER COMPLETAMENTE O READONLY
            dataCampo.removeAttribute('readonly');
            dataCampo.readOnly = false;
            
            // üü¢ TORNAR EDIT√ÅVEL
            dataCampo.disabled = false;
            
            // üü¢ MELHORAR USABILIDADE
            dataCampo.title = "Clique para editar a data (DD/MM/AAAA)";
            dataCampo.placeholder = "DD/MM/AAAA";
            
            // üü¢ ESTILOS DE CAMPO EDIT√ÅVEL
            dataCampo.style.backgroundColor = '#ffffff';
            dataCampo.style.borderColor = '#007bff';
            dataCampo.style.cursor = 'text';
            dataCampo.style.color = '#000000';
            
            // üü¢ ADICIONAR M√ÅSCARA DE DATA EM TEMPO REAL
            dataCampo.addEventListener('input', (e) => {
                this.aplicarMascaraData(e.target);
            });
            
            // üü¢ VALIDAR DATA AO PERDER O FOCO
            dataCampo.addEventListener('blur', (e) => {
                this.validarData(e.target);
            });
            
            console.log('üü¢ Campo de DATA configurado como edit√°vel');
        }
    }

    /**
     * üÜï APLICAR M√ÅSCARA DE DATA EM TEMPO REAL
     */
    aplicarMascaraData(input) {
        let value = input.value.replace(/\D/g, '');
        
        // Limitar a 8 d√≠gitos (DDMMAAAA)
        if (value.length > 8) {
            value = value.substring(0, 8);
        }
        
        // Aplicar m√°scara
        if (value.length > 4) {
            value = value.substring(0, 2) + '/' + value.substring(2, 4) + '/' + value.substring(4);
        } else if (value.length > 2) {
            value = value.substring(0, 2) + '/' + value.substring(2);
        }
        
        input.value = value;
    }

    /**
     * üÜï VALIDAR DATA AO PERDER FOCO
     */
    validarData(input) {
        const valor = input.value.trim();
        
        if (!valor) return true; // Campo vazio √© v√°lido
        
        // Validar formato DD/MM/AAAA
        const regexData = /^(\d{2})\/(\d{2})\/(\d{4})$/;
        const match = valor.match(regexData);
        
        if (!match) {
            showSystemStatus('Formato de data inv√°lido. Use DD/MM/AAAA', 'warning');
            input.focus();
            return false;
        }
        
        const dia = parseInt(match[1], 10);
        const mes = parseInt(match[2], 10);
        const ano = parseInt(match[3], 10);
        
        // Validar valores
        if (mes < 1 || mes > 12) {
            showSystemStatus('M√™s deve estar entre 01 e 12', 'warning');
            input.focus();
            return false;
        }
        
        if (dia < 1 || dia > 31) {
            showSystemStatus('Dia deve estar entre 01 e 31', 'warning');
            input.focus();
            return false;
        }
        
        // Validar fevereiro e meses com 30 dias
        const data = new Date(ano, mes - 1, dia);
        if (data.getDate() !== dia || data.getMonth() + 1 !== mes || data.getFullYear() !== ano) {
            showSystemStatus('Data inv√°lida para o m√™s especificado', 'warning');
            input.focus();
            return false;
        }
        
        return true;
    }

    criarHTMLFormulario() {
        return `
        <div class="empresa-cadastro-inline" id="empresa-cadastro-inline">
            <div class="empresa-form-grid">
                <!-- Empresa üü¢ EDIT√ÅVEL -->
                <div class="form-group">
                    <label for="empresa-input">Empresa *</label>
                    <input type="text" 
                        id="empresa-input" 
                        class="empresa-input" 
                        placeholder="Digite sigla ou nome..."
                        autocomplete="off">
                    <div class="autocomplete-suggestions" id="empresa-suggestions"></div>
                </div>

                <!-- N√∫mero Cliente Final üî¥ SOMENTE LEITURA -->
                <div class="form-group">
                    <label for="numero-cliente-final">N√∫mero Cliente Final</label>
                    <input type="text" 
                        id="numero-cliente-final" 
                        class="numero-cliente-final" 
                        readonly
                        placeholder="Ser√° calculado automaticamente">
                </div>

                <!-- Cliente Final üü¢ EDIT√ÅVEL -->
                <div class="form-group">
                    <label for="cliente-final">Cliente Final</label>
                    <input type="text" 
                        id="cliente-final" 
                        class="cliente-final" 
                        placeholder="Nome do cliente final">
                </div>

                <!-- C√≥digo Cliente üü¢ EDIT√ÅVEL -->
                <div class="form-group">
                    <label for="codigo-cliente">C√≥digo Cliente</label>
                    <input type="text" 
                        id="codigo-cliente" 
                        class="codigo-cliente" 
                        placeholder="C√≥digo interno do cliente">
                </div>

                <!-- Data do Cadastro üü¢ EDIT√ÅVEL -->
                <div class="form-group">
                    <label for="data-cadastro">Data do Cadastro</label>
                    <input type="text" 
                        id="data-cadastro" 
                        class="data-cadastro" 
                        placeholder="DD/MM/AAAA"
                        value="${new Date().toLocaleDateString('pt-BR')}">
                </div>

                <!-- Or√ßamentista Respons√°vel üü¢ EDIT√ÅVEL -->
                <div class="form-group">
                    <label for="orcamentista-responsavel">Or√ßamentista Respons√°vel</label>
                    <input type="text" 
                        id="orcamentista-responsavel" 
                        class="orcamentista-responsavel" 
                        placeholder="Nome do or√ßamentista">
                </div>
            </div>

            <div class="empresa-form-actions">
                <button type="button" class="btn btn-cancel" onclick="window.empresaCadastro.cancelarCadastro()">
                    Cancelar
                </button>
                <button type="button" class="btn btn-confirm" onclick="window.empresaCadastro.prepararDados()">
                    Confirmar Dados
                </button>
            </div>
        </div>
        `;
    }

    vincularEventosFormulario() {
        const empresaInput = this.container.querySelector('#empresa-input');
        if (empresaInput) {
            empresaInput.addEventListener('input', (e) => this.buscarEmpresas(e.target.value));
            empresaInput.addEventListener('blur', () => {
                setTimeout(() => this.ocultarSugestoes(), 200);
            });
            empresaInput.addEventListener('keydown', (e) => this.tratarTecladoAutocomplete(e));
        }
    }

    async buscarEmpresas(termo) {
        if (!termo || termo.length < 2) {
            this.ocultarSugestoes();
            return;
        }

        const termoNormalizado = this.normalizarTermo(termo);
        const sugestoes = this.filtrarEmpresas(termoNormalizado);
        
        this.exibirSugestoes(sugestoes);
    }

    normalizarTermo(termo) {
        return termo.trim().toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    filtrarEmpresas(termo) {
        return this.empresas.filter(empresaObj => {
            const [sigla, nome] = Object.entries(empresaObj)[0];
            const nomeNormalizado = nome.toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const primeiroNome = nome.split(' ')[0].toUpperCase();
            
            return sigla === termo || 
                   nomeNormalizado.includes(termo) ||
                   primeiroNome.includes(termo);
        });
    }

    exibirSugestoes(sugestoes) {
        const containerSugestoes = this.container.querySelector('#empresa-suggestions');
        if (!containerSugestoes) return;

        if (sugestoes.length === 0) {
            this.ocultarSugestoes();
            return;
        }

        const html = sugestoes.map(empresaObj => {
            const [sigla, nome] = Object.entries(empresaObj)[0];
            const primeiroNome = nome.split(' ')[0];

            return `
                <div class="dropdown-option" data-sigla="${sigla}" data-nome="${nome}">
                    <strong>${sigla}</strong> - ${primeiroNome}
                </div>
            `;
        }).join('');

        containerSugestoes.innerHTML = html;
        containerSugestoes.style.display = 'block';

        // Vincular eventos de clique nas sugest√µes
        containerSugestoes.querySelectorAll('.suggestion-item').forEach(item => {
            item.addEventListener('click', () => {
                const sigla = item.dataset.sigla;
                const nome = item.dataset.nome;
                this.selecionarEmpresa(sigla, nome);
            });
        });
    }

    ocultarSugestoes() {
        const containerSugestoes = this.container.querySelector('#empresa-suggestions');
        if (containerSugestoes) {
            containerSugestoes.style.display = 'none';
        }
    }

    tratarTecladoAutocomplete(event) {
        const sugestoes = this.container.querySelectorAll('.suggestion-item');
        if (sugestoes.length === 0) return;

        const sugestaoAtiva = this.container.querySelector('.suggestion-item.active');
        
        switch (event.key) {
            case 'ArrowDown':
                event.preventDefault();
                this.navegarSugestoes(sugestoes, sugestaoAtiva, 1);
                break;
            case 'ArrowUp':
                event.preventDefault();
                this.navegarSugestoes(sugestoes, sugestaoAtiva, -1);
                break;
            case 'Enter':
                event.preventDefault();
                if (sugestaoAtiva) {
                    const sigla = sugestaoAtiva.dataset.sigla;
                    const nome = sugestaoAtiva.dataset.nome;
                    this.selecionarEmpresa(sigla, nome);
                }
                break;
            case 'Escape':
                this.ocultarSugestoes();
                break;
        }
    }

    navegarSugestoes(sugestoes, atual, direcao) {
        let index = Array.from(sugestoes).indexOf(atual);
        
        if (index === -1) index = direcao > 0 ? -1 : sugestoes.length;
        
        index = (index + direcao + sugestoes.length) % sugestoes.length;
        
        sugestoes.forEach(s => s.classList.remove('active'));
        sugestoes[index].classList.add('active');
    }

    selecionarEmpresa(sigla, nome) {
        const empresaInput = this.container.querySelector('#empresa-input');
        if (empresaInput) {
            empresaInput.value = `${sigla} - ${nome}`;
            empresaInput.dataset.siglaSelecionada = sigla;
            empresaInput.dataset.nomeSelecionado = nome;
        }

        this.ocultarSugestoes();
        this.calcularNumeroClienteFinal(sigla);
    }

    calcularNumeroClienteFinal(sigla) {
        // Filtrar obras existentes pela sigla
        const obrasDaEmpresa = this.obrasExistentes.filter(obra => {
            return obra.empresaSigla === sigla || 
                   (obra.idGerado && obra.idGerado.startsWith(`obra_${sigla}_`));
        });

        // Encontrar maior n√∫mero existente
        let maiorNumero = 0;
        obrasDaEmpresa.forEach(obra => {
            if (obra.numeroClienteFinal && obra.numeroClienteFinal > maiorNumero) {
                maiorNumero = obra.numeroClienteFinal;
            }
            
            // Tamb√©m tentar extrair do ID gerado
            if (obra.idGerado) {
                const match = obra.idGerado.match(new RegExp(`obra_${sigla}_(\\d+)`));
                if (match) {
                    const numero = parseInt(match[1]);
                    if (numero > maiorNumero) maiorNumero = numero;
                }
            }
        });

        const novoNumero = maiorNumero + 1;
        
        const numeroInput = this.container.querySelector('#numero-cliente-final');
        if (numeroInput) {
            numeroInput.value = novoNumero;
        }

        // Atualizar preview do ID da obra
        this.atualizarPreviewIdObra(sigla, novoNumero);
    }

    atualizarPreviewIdObra(sigla, numero) {
        const idObraValue = this.container.querySelector('#obra-id-value');
        
        if (idObraContainer && idObraValue) {
            const idObra = `obra_${sigla}_${numero}`;
            idObraValue.textContent = idObra;
            idObraContainer.style.display = 'block';
        }
    }

    async prepararDados() {
        const dados = this.coletarDadosFormulario();
        
        if (!this.validarDados(dados)) {
            return;
        }

        // Verificar se precisa cadastrar nova empresa
        if (!dados.empresaExistente) {
            const sucesso = await this.cadastrarNovaEmpresa(dados.sigla, dados.nomeEmpresa);
            if (!sucesso) return;
        }

        // Preparar dados para a obra
        this.prepararDadosObra(dados);
        
        showSystemStatus('Dados da empresa preparados! Agora salve a obra.', 'success');
        
        // Ocultar formul√°rio mas manter dados preparados
        this.ocultarFormulario();
    }

    coletarDadosFormulario() {
        const empresaInput = this.container.querySelector('#empresa-input');
        const siglaSelecionada = empresaInput?.dataset.siglaSelecionada;
        const nomeSelecionado = empresaInput?.dataset.nomeSelecionado;
        
        return {
            empresaInput: empresaInput?.value || '',
            sigla: siglaSelecionada,
            nomeEmpresa: nomeSelecionado,
            empresaExistente: !!siglaSelecionada,
            numeroClienteFinal: this.container.querySelector('#numero-cliente-final')?.value || '',
            clienteFinal: this.container.querySelector('#cliente-final')?.value || '',
            codigoCliente: this.container.querySelector('#codigo-cliente')?.value || '',
            dataCadastro: this.container.querySelector('#data-cadastro')?.value || '',
            orcamentistaResponsavel: this.container.querySelector('#orcamentista-responsavel')?.value || ''
        };
    }

    /**
     * üÜï VALIDA√á√ÉO CORRIGIDA DA SIGLA - COM REGEX E TOOLTIP
     */
    validarDados(dados) {
        if (!dados.empresaInput.trim()) {
            showSystemStatus('Por favor, informe a empresa', 'error');
            return false;
        }

        if (!dados.empresaExistente) {
            // üÜï VALIDA√á√ÉO CORRIGIDA DA SIGLA - REGEX MELHORADO
            const regexSigla = /^[A-Z]{2,6}$/; // 2 a 6 letras mai√∫sculas
            
            // Verificar se usu√°rio digitou apenas sigla
            if (regexSigla.test(dados.empresaInput)) {
                // Usu√°rio digitou apenas sigla - solicitar nome completo
                const nomeCompleto = prompt(`Voc√™ digitou apenas a sigla "${dados.empresaInput}". Por favor, informe o nome completo da empresa:`);
                if (!nomeCompleto || !nomeCompleto.trim()) {
                    showSystemStatus('Nome completo da empresa √© obrigat√≥rio', 'error');
                    return false;
                }
                
                // üÜï VALIDAR FORMATO DO NOME
                if (nomeCompleto.trim().length < 3) {
                    showSystemStatus('Nome da empresa deve ter pelo menos 3 caracteres', 'error');
                    return false;
                }
                
                dados.nomeEmpresa = nomeCompleto.trim();
                dados.sigla = dados.empresaInput.toUpperCase();
                
            } else {
                // Usu√°rio digitou nome - sugerir sigla v√°lida
                const primeiraPalavra = dados.empresaInput.split(' ')[0];
                const siglaSugerida = primeiraPalavra.substring(0, 3).toUpperCase();
                
                // üÜï GARANTIR QUE SIGLA TENHA FORMATO V√ÅLIDO
                let siglaConfirmada = prompt(`Empresa n√£o encontrada. Sugerimos a sigla "${siglaSugerida}". Confirme ou digite outra sigla (2-6 letras mai√∫sculas):`, siglaSugerida);
                
                if (!siglaConfirmada) {
                    showSystemStatus('Sigla √© obrigat√≥ria', 'error');
                    return false;
                }
                
                // üÜï NORMALIZAR SIGLA
                siglaConfirmada = siglaConfirmada.trim().toUpperCase().replace(/[^A-Z]/g, '');
                
                // üÜï VALIDAR FORMATO DA SIGLA
                if (!regexSigla.test(siglaConfirmada)) {
                    showSystemStatus('Sigla deve conter 2 a 6 letras mai√∫sculas, sem espa√ßos ou caracteres especiais', 'error');
                    return false;
                }
                
                dados.sigla = siglaConfirmada;
                dados.nomeEmpresa = dados.empresaInput;
            }
        }

        return true;
    }

    async cadastrarNovaEmpresa(sigla, nome) {
        try {
            // Verificar se sigla j√° existe
            const siglaExistente = this.empresas.find(empresaObj => {
                const [siglaExistente] = Object.keys(empresaObj);
                return siglaExistente === sigla;
            });

            if (siglaExistente) {
                showSystemStatus(`Sigla ${sigla} j√° est√° em uso. Escolha outra sigla.`, 'error');
                return false;
            }

            // Adicionar nova empresa
            const novaEmpresa = { [sigla]: nome };
            this.empresas.push(novaEmpresa);

            // Salvar no dados.json
            const response = await fetch('/api/dados/empresas', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(novaEmpresa)
            });

            if (!response.ok) {
                throw new Error('Erro ao salvar empresa');
            }

            showSystemStatus(`Empresa ${sigla} - ${nome} cadastrada com sucesso!`, 'success');
            return true;

        } catch (error) {
            console.error('‚ùå Erro ao cadastrar nova empresa:', error);
            showSystemStatus('Erro ao cadastrar empresa', 'error');
            return false;
        }
    }

    /**
     * Atualiza o header da obra com a sigla e numera√ß√£o
     * @param {HTMLElement} obraElement - Elemento da obra
     * @param {Object} dadosEmpresa - Dados da empresa
     */

    atualizarHeaderObra(obraElement, dadosEmpresa) {
        try {
            const headerSpacer = obraElement.querySelector('.obra-header-spacer');
            if (!headerSpacer) {
                console.error('‚ùå Elemento .obra-header-spacer n√£o encontrado');
                return;
            }

            // Limpar conte√∫do atual
            headerSpacer.innerHTML = '';

            if (dadosEmpresa.empresaSigla && dadosEmpresa.numeroClienteFinal) {
                // üÜï CRIAR SPAN COM IDENTIFICADOR DA EMPRESA (n√£o bot√£o)
                const span = document.createElement('span');
                span.className = 'empresa-identifier-display';
                const textoHeader = `${dadosEmpresa.empresaSigla}-${dadosEmpresa.numeroClienteFinal}`;
                span.textContent = textoHeader;
                span.setAttribute('data-tooltip', this.criarTooltipEmpresa(dadosEmpresa));
                
                // üÜï ADICIONAR SISTEMA DE TOOLTIP VIA JAVASCRIPT
                this.inicializarTooltipJavaScript(span);
                
                headerSpacer.appendChild(span);
                console.log(`‚úÖ Header da obra atualizado para SPAN: ${textoHeader}`);
            } else {
                // Bot√£o padr√£o para cadastro
                this.resetHeaderObra(headerSpacer);
            }
        } catch (error) {
            console.error('‚ùå Erro ao atualizar header da obra:', error);
        }
    }

    /**
     * üÜï INICIALIZAR TOOLTIP - VERS√ÉO COM AUTO-CLOSE NO MOBILE
     */
    inicializarTooltipJavaScript(element) {
        console.log('üîß Inicializando tooltip RESPONSIVO com auto-close');
        
        // üÜï DETECTAR SE √â MOBILE
        const isMobile = window.innerWidth <= 768;
        
        // üÜï VARI√ÅVEL PARA CONTROLAR O TIMER
        let autoCloseTimer = null;
        
        // FOR√áAR ESTILOS PARA GARANTIR VISIBILIDADE
        element.style.position = 'relative';
        element.style.overflow = 'visible';
        element.style.zIndex = '100';
        
        // Criar tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'empresa-tooltip';
        
        // üÜï ADICIONAR CLASSE PARA MOBILE
        if (isMobile) {
            tooltip.classList.add('empresa-tooltip-mobile');
            
            // üÜï ADICIONAR BOT√ÉO DE FECHAR NO MOBILE
            const closeButton = document.createElement('button');
            closeButton.className = 'empresa-tooltip-close';
            closeButton.innerHTML = '√ó';
            closeButton.setAttribute('aria-label', 'Fechar tooltip');
            tooltip.appendChild(closeButton);
            
            // üÜï EVENTO PARA FECHAR COM BOT√ÉO
            closeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                esconderTooltip();
            });
        }
        
        // üÜï POSICIONAR O TOOLTIP FORA DA HIERARQUIA DO ELEMENTO
        document.body.appendChild(tooltip);
        
        // üÜï FUN√á√ÉO PARA INICIAR TIMER DE AUTO-CLOSE
        const iniciarAutoCloseTimer = () => {
            if (autoCloseTimer) {
                clearTimeout(autoCloseTimer);
            }
            // üÜï FECHAR AUTOMATICAMENTE AP√ìS 5 SEGUNDOS NO MOBILE
            autoCloseTimer = setTimeout(() => {
                console.log('‚è∞ Auto-close do tooltip no mobile');
                esconderTooltip();
            }, 5000); // 5 segundos
        };
        
        // üÜï FUN√á√ÉO PARA CANCELAR TIMER
        const cancelarAutoCloseTimer = () => {
            if (autoCloseTimer) {
                clearTimeout(autoCloseTimer);
                autoCloseTimer = null;
            }
        };
        
        // üÜï FUN√á√ÉO PARA ATUALIZAR POSI√á√ÉO DO TOOLTIP - VERS√ÉO RESPONSIVA
        const atualizarPosicaoTooltip = () => {
            const rect = element.getBoundingClientRect();
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            const isMobileNow = window.innerWidth <= 768;
            
            if (isMobileNow) {
                // üÜï POSICIONAMENTO PARA MOBILE
                tooltip.style.position = 'fixed';
                tooltip.style.left = '50%';
                tooltip.style.top = '50%';
                tooltip.style.transform = 'translate(-50%, -50%)';
                tooltip.style.bottom = 'auto';
                tooltip.style.right = 'auto';
                tooltip.style.width = '90vw';
                tooltip.style.maxWidth = '320px';
                tooltip.style.maxHeight = '70vh';
                tooltip.style.overflowY = 'auto';
                tooltip.style.zIndex = '100000';
            } else {
                // üÜï POSICIONAMENTO PARA DESKTOP
                tooltip.style.position = 'fixed';
                tooltip.style.left = (rect.left + scrollX + (rect.width / 2)) + 'px';
                tooltip.style.bottom = (window.innerHeight - rect.top - scrollY + 8) + 'px';
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.style.width = 'auto';
                tooltip.style.maxWidth = '380px';
                tooltip.style.maxHeight = 'none';
            }
        };
        
        // üÜï FUN√á√ÉO PARA MOSTRAR TOOLTIP
        const mostrarTooltip = () => {
            console.log('üê≠ Mouse ENTER/TAP no span');
            const tooltipText = element.getAttribute('data-tooltip');
            if (tooltipText) {
                // üÜï ATUALIZAR CONTE√öDO (exceto bot√£o de fechar se existir)
                const closeBtn = tooltip.querySelector('.empresa-tooltip-close');
                tooltip.innerHTML = tooltipText;
                if (closeBtn && isMobile) {
                    tooltip.appendChild(closeBtn);
                }
                
                tooltip.classList.add('show');
                atualizarPosicaoTooltip();
                
                // üÜï INICIAR TIMER DE AUTO-CLOSE NO MOBILE
                if (isMobile) {
                    iniciarAutoCloseTimer();
                }
                
                console.log('üî¶ Tooltip mostrado:', tooltipText);
            }
        };
        
        // üÜï FUN√á√ÉO PARA ESCONDER TOOLTIP
        const esconderTooltip = () => {
            console.log('üê≠ Escondendo tooltip');
            tooltip.classList.remove('show');
            cancelarAutoCloseTimer(); // üÜï CANCELAR TIMER AO ESCONDER
        };
        
        // üÜï EVENT LISTENERS DIFERENCIADOS PARA MOBILE/DESKTOP
        if (isMobile) {
            // üÜï PARA MOBILE: USAR CLICK/TOUCH
            element.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (tooltip.classList.contains('show')) {
                    esconderTooltip();
                } else {
                    mostrarTooltip();
                }
            });
            
            // üÜï FECHAR TOOLTIP AO CLICAR FORA (MOBILE)
            document.addEventListener('click', (e) => {
                if (!element.contains(e.target) && !tooltip.contains(e.target)) {
                    esconderTooltip();
                }
            });
            
            // üÜï FECHAR TOOLTIP AO ROLAR (MOBILE)
            window.addEventListener('scroll', esconderTooltip);
            
            // üÜï FECHAR TOOLTIP AO MUDAR ORIENTA√á√ÉO (MOBILE)
            window.addEventListener('orientationchange', esconderTooltip);
            
        } else {
            // üÜï PARA DESKTOP: USAR HOVER
            element.addEventListener('mouseenter', mostrarTooltip);
            element.addEventListener('mouseleave', esconderTooltip);
        }
        
        // üÜï REINICIAR TIMER SE O USU√ÅRIO INTERAGIR COM O TOOLTIP (MOBILE)
        if (isMobile) {
            tooltip.addEventListener('touchstart', () => {
                cancelarAutoCloseTimer(); // Cancelar timer atual
                iniciarAutoCloseTimer();  // Reiniciar timer
            });
            
            tooltip.addEventListener('click', () => {
                cancelarAutoCloseTimer(); // Cancelar timer atual  
                iniciarAutoCloseTimer();  // Reiniciar timer
            });
        }
        
        // üÜï ATUALIZAR POSI√á√ÉO AO ROLAR/REDIMENSIONAR
        window.addEventListener('scroll', () => {
            if (tooltip.classList.contains('show')) {
                atualizarPosicaoTooltip();
            }
        });
        
        window.addEventListener('resize', () => {
            if (tooltip.classList.contains('show')) {
                atualizarPosicaoTooltip();
            }
            
            // üÜï RECARREGAR COMPORTAMENTO AO REDIMENSIONAR ENTRE MOBILE/DESKTOP
            const novaCondicaoMobile = window.innerWidth <= 768;
            if (isMobile !== novaCondicaoMobile) {
                console.log('üîÑ Mudan√ßa entre mobile/desktop detectada');
                esconderTooltip();
                // Recriar tooltip com novo comportamento
                tooltip.remove();
                this.inicializarTooltipJavaScript(element);
            }
        });
        
        // üÜï LIMPAR EVENT LISTENERS QUANDO ELEMENTO FOR REMOVIDO
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.removedNodes.length > 0) {
                    const removed = Array.from(mutation.removedNodes);
                    if (removed.includes(element) || element.parentNode === null) {
                        tooltip.remove();
                        cancelarAutoCloseTimer();
                        window.removeEventListener('scroll', atualizarPosicaoTooltip);
                        window.removeEventListener('resize', atualizarPosicaoTooltip);
                        document.removeEventListener('click', esconderTooltip);
                        window.removeEventListener('orientationchange', esconderTooltip);
                        observer.disconnect();
                    }
                }
            });
        });
        
        observer.observe(document.body, { childList: true, subtree: true });
        
        console.log('‚úÖ Tooltip inicializado (com auto-close) - Mobile:', isMobile);
    }



    /**
     * Cria texto de tooltip com informa√ß√µes completas da empresa
     * @param {Object} dadosEmpresa - Dados da empresa
     * @returns {string} Texto do tooltip
     */
    criarTooltipEmpresa(dadosEmpresa) {
        const partes = [];
        
        if (dadosEmpresa.empresaNome) {
            partes.push(`Empresa: ${dadosEmpresa.empresaNome}`);
        }
        if (dadosEmpresa.clienteFinal) {
            partes.push(`Cliente: ${dadosEmpresa.clienteFinal}`);
        }
        if (dadosEmpresa.codigoCliente) {
            partes.push(`C√≥digo: ${dadosEmpresa.codigoCliente}`);
        }
        if (dadosEmpresa.dataCadastro) {
            // üÜï FORMATAR DATA PARA dd/mm/aaaa
            const dataFormatada = this.formatarDataParaTooltip(dadosEmpresa.dataCadastro);
            partes.push(`Data: ${dataFormatada}`);
        }
        if (dadosEmpresa.orcamentistaResponsavel) {
            partes.push(`Or√ßamentista: ${dadosEmpresa.orcamentistaResponsavel}`);
        }
        
        return partes.join('\n');
    }

    /**
     * Formata data para o formato dd/mm/aaaa no tooltip
     * @param {string} dataString - Data em qualquer formato
     * @returns {string} Data formatada como dd/mm/aaaa
     */
    formatarDataParaTooltip(dataString) {
        if (!dataString) return '';
        
        try {
            // Se j√° estiver no formato dd/mm/aaaa, retornar como est√°
            if (typeof dataString === 'string' && dataString.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                return dataString;
            }
            
            // Tentar converter para Date
            const data = new Date(dataString);
            
            if (isNaN(data.getTime())) {
                console.warn(`‚ö†Ô∏è Data inv√°lida no tooltip: ${dataString}`);
                return dataString;
            }
            
            // Formatar para dd/mm/aaaa
            const dia = String(data.getDate()).padStart(2, '0');
            const mes = String(data.getMonth() + 1).padStart(2, '0');
            const ano = data.getFullYear();
            
            return `${dia}/${mes}/${ano}`;
            
        } catch (error) {
            console.error(`‚ùå Erro ao formatar data para tooltip ${dataString}:`, error);
            return dataString;
        }
    }

    /**
     * Reseta o header para o estado original
     * @param {HTMLElement} headerSpacer - Elemento do header
     */
    resetHeaderObra(headerSpacer) {
        const button = document.createElement('button');
        button.className = 'btn-empresa-cadastro';
        button.textContent = 'Adicionar campos de cadastro de empresas';
        button.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const obraBlock = headerSpacer.closest('.obra-block');
            if (obraBlock && obraBlock.dataset.obraId) {
                window.ativarCadastroEmpresa(obraBlock.dataset.obraId);
            }
        };
        
        headerSpacer.innerHTML = '';
        headerSpacer.appendChild(button);
    }

    /**
     * Prepara dados da obra e atualiza o header
     * @param {Object} dados - Dados coletados do formul√°rio
     */
    prepararDadosObra(dados) {
        // Armazenar dados no container da obra para uso posterior
        const obraBlock = this.container.closest('.obra-block');
        if (obraBlock) {
            obraBlock.dataset.empresaSigla = dados.sigla;
            obraBlock.dataset.empresaNome = dados.nomeEmpresa;
            obraBlock.dataset.numeroClienteFinal = dados.numeroClienteFinal;
            obraBlock.dataset.clienteFinal = dados.clienteFinal;
            obraBlock.dataset.codigoCliente = dados.codigoCliente;
            
            // üÜï USAR DATA FORMATADA
            const dataFormatada = this.formatarData(dados.dataCadastro);
            obraBlock.dataset.dataCadastro = dataFormatada;
            
            obraBlock.dataset.orcamentistaResponsavel = dados.orcamentistaResponsavel;
            obraBlock.dataset.idGerado = `obra_${dados.sigla}_${dados.numeroClienteFinal}`;
            
            // üÜï ATUALIZAR HEADER DA OBRA
            this.atualizarHeaderObra(obraBlock, {
                empresaSigla: dados.sigla,
                empresaNome: dados.nomeEmpresa,
                numeroClienteFinal: dados.numeroClienteFinal,
                clienteFinal: dados.clienteFinal,
                codigoCliente: dados.codigoCliente,
                dataCadastro: dataFormatada, // üÜï DATA FORMATADA
                orcamentistaResponsavel: dados.orcamentistaResponsavel
            });
            
            console.log('üì¶ Dados da obra preparados:', obraBlock.dataset);
        }
    }

    cancelarCadastro() {
        this.ocultarFormulario();
        this.mostrarSpanOriginal();
        
        // üÜï RESETAR HEADER SE N√ÉO HOUVER DADOS DE EMPRESA
        const obraBlock = this.container.closest('.obra-block');
        if (obraBlock) {
            const headerSpacer = obraBlock.querySelector('.obra-header-spacer span');
            if (headerSpacer && !obraBlock.dataset.empresaSigla) {
                this.resetHeaderObra(headerSpacer);
            }
        }
    }

    ocultarFormulario() {
        const form = this.container.querySelector('#empresa-cadastro-inline');
        if (form) {
            form.remove();
        }
        this.isActive = false;
    }

    mostrarSpanOriginal() {
        const span = this.container.querySelector('span');
        if (span) {
            span.style.display = 'inline';
        }
    }

    // M√©todo para obter dados preparados (usado pelo sistema de salvamento)
    obterDadosPreparados(obraId) {
        const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
        if (!obraBlock) return null;

        return {
            empresaSigla: obraBlock.dataset.empresaSigla,
            empresaNome: obraBlock.dataset.empresaNome,
            numeroClienteFinal: obraBlock.dataset.numeroClienteFinal ? parseInt(obraBlock.dataset.numeroClienteFinal) : null,
            clienteFinal: obraBlock.dataset.clienteFinal,
            codigoCliente: obraBlock.dataset.codigoCliente,
            dataCadastro: obraBlock.dataset.dataCadastro,
            orcamentistaResponsavel: obraBlock.dataset.orcamentistaResponsavel,
            idGerado: obraBlock.dataset.idGerado
        };
    }
    /**
     * Formata data para dd/mm/aaaa
     */
    formatarData(dataString) {
        if (!dataString) return '';
        
        try {
            // Se j√° estiver no formato dd/mm/aaaa, retornar como est√°
            if (typeof dataString === 'string' && dataString.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                return dataString;
            }
            
            const data = new Date(dataString);
            
            if (isNaN(data.getTime())) {
                console.warn(`‚ö†Ô∏è Data inv√°lida: ${dataString}`);
                return dataString;
            }
            
            const dia = String(data.getDate()).padStart(2, '0');
            const mes = String(data.getMonth() + 1).padStart(2, '0');
            const ano = data.getFullYear();
            
            return `${dia}/${mes}/${ano}`;
            
        } catch (error) {
            console.error(`‚ùå Erro ao formatar data ${dataString}:`, error);
            return dataString;
        }
    }
}

// Exporta√ß√£o e inicializa√ß√£o
export default EmpresaCadastroInline;

if (typeof window !== 'undefined') {
    window.EmpresaCadastroInline = EmpresaCadastroInline;
    
    // Inicializar quando DOM estiver pronto
    document.addEventListener('DOMContentLoaded', () => {
        window.empresaCadastro = new EmpresaCadastroInline();
    });
}


/* ==== FIM: data/builders/empresa-cadastro-inline.js ==== */

/* ==== IN√çCIO: data/builders/data-builders-folder/empresa-data-extractor.js ==== */
// data/builders/data-builders-folder/empresa-data-extractor.js

/**
 * Extrai dados de empresa cadastrados inline
 */


function extractEmpresaData(obraElement) {
    const empresaData = {};
    
    if (!obraElement) {
        console.error('‚ùå Elemento da obra √© nulo para extra√ß√£o de empresa');
        return empresaData;
    }

    console.log('üîç [EXTRACT EMPRESA] INICIANDO extra√ß√£o para obra:', obraElement.dataset.obraId);

    const camposEmpresa = [
        'empresaSigla', 'empresaNome', 'numeroClienteFinal', 
        'clienteFinal', 'codigoCliente', 'dataCadastro', 
        'orcamentistaResponsavel', 'idGerado'
    ];

    // üÜï ESTRAT√âGIA: PRIMEIRO buscar nos INPUTS ATUAIS (valores mais recentes)
    console.log('üîç [EXTRACT EMPRESA] FASE 1 - Buscando nos INPUTS ATUAIS do formul√°rio...');
    
    const formEmpresa = obraElement.querySelector('.empresa-formulario-ativo');
    if (formEmpresa) {
        console.log('üìã [EXTRACT EMPRESA] Formul√°rio ativo encontrado, extraindo dados atuais...');
        
        const mapeamentoCampos = {
            // üÜï PRIORIDADE: Inputs de cadastro/edi√ß√£o (valores mais recentes)
            'empresa-input-cadastro': ['empresaSigla', 'empresaNome'],
            'numero-cliente-final-cadastro': ['numeroClienteFinal'], 
            'cliente-final-cadastro': ['clienteFinal'],
            'codigo-cliente-cadastro': ['codigoCliente'],
            'data-cadastro-cadastro': ['dataCadastro'],
            'orcamentista-responsavel-cadastro': ['orcamentistaResponsavel'],
            
            // üÜï Inputs de visualiza√ß√£o/readonly
            'empresa-input-readonly': ['empresaSigla', 'empresaNome'],
            'numero-cliente-final-readonly': ['numeroClienteFinal'],
            'cliente-final-input': ['clienteFinal'],
            'codigo-cliente-input': ['codigoCliente'], 
            'data-cadastro-readonly': ['dataCadastro'],
            'orcamentista-responsavel-input': ['orcamentistaResponsavel']
        };

        Object.entries(mapeamentoCampos).forEach(([inputClass, camposAlvo]) => {
            const input = formEmpresa.querySelector(`.${inputClass}`);
            
            if (input && input.value && input.value.trim() !== '') {
                let valor = input.value.trim();
                console.log(`‚úÖ [EXTRACT EMPRESA] Input ${inputClass} encontrado: "${valor}"`);
                
                camposAlvo.forEach(campo => {
                    if (!empresaData[campo]) { // S√≥ preenche se ainda n√£o tem valor
                        if (campo === 'numeroClienteFinal') {
                            empresaData[campo] = parseInt(valor) || 0;
                            console.log(`üî¢ [EXTRACT EMPRESA] ${campo} convertido para n√∫mero: ${empresaData[campo]}`);
                        } else if (campo === 'empresaSigla' && valor.includes(' - ')) {
                            // Extrair sigla e nome do formato "SIGLA - Nome"
                            const partes = valor.split(' - ');
                            empresaData.empresaSigla = partes[0];
                            if (partes[1]) {
                                empresaData.empresaNome = partes[1];
                            }
                            console.log(`üè¢ [EXTRACT EMPRESA] Empresa extra√≠da: ${empresaData.empresaSigla} - ${empresaData.empresaNome}`);
                        } else if (campo === 'empresaNome' && !valor.includes(' - ')) {
                            // Se for apenas o nome, sem sigla
                            empresaData[campo] = valor;
                        } else if (campo !== 'empresaSigla') {
                            // Para outros campos
                            empresaData[campo] = valor;
                        }
                    }
                });
            }
        });

        // üÜï BUSCAR DADOS DO AUTOCOMPLETE (prioridade m√°xima)
        const empresaInput = formEmpresa.querySelector('.empresa-input-cadastro');
        if (empresaInput && empresaInput.dataset.siglaSelecionada) {
            console.log('üéØ [EXTRACT EMPRESA] Dados do autocomplete encontrados:', {
                sigla: empresaInput.dataset.siglaSelecionada,
                nome: empresaInput.dataset.nomeSelecionado
            });
            
            // üÜï SOBRESCREVER com dados do autocomplete (s√£o os mais confi√°veis)
            empresaData.empresaSigla = empresaInput.dataset.siglaSelecionada;
            empresaData.empresaNome = empresaInput.dataset.nomeSelecionado;
        }
    } else {
        console.log('‚ùå [EXTRACT EMPRESA] Formul√°rio ativo n√£o encontrado');
    }

    // üÜï FASE 2: S√≥ buscar nos data attributes os campos que ainda est√£o faltando
    console.log('üîç [EXTRACT EMPRESA] FASE 2 - Buscando campos faltantes nos data attributes...');
    
    const camposFaltantes = camposEmpresa.filter(campo => !empresaData[campo]);
    console.log(`üìã [EXTRACT EMPRESA] Campos ainda faltantes: ${camposFaltantes.join(', ')}`);
    
    camposFaltantes.forEach(campo => {
        const valorDataAttr = obraElement.dataset[campo];
        if (valorDataAttr) {
            if (campo === 'numeroClienteFinal') {
                empresaData[campo] = parseInt(valorDataAttr) || 0;
            } else {
                empresaData[campo] = valorDataAttr;
            }
            console.log(`üì¶ [EXTRACT EMPRESA] ${campo} extra√≠do do data-attribute: ${empresaData[campo]}`);
        }
    });

    // üÜï VALIDA√á√ÉO FINAL E CORRE√á√ïES
    console.log('üîç [EXTRACT EMPRESA] FASE 3 - Valida√ß√£o final...');
    
    // üÜï CORRIGIR: Se temos empresaSigla mas n√£o temos empresaNome (ou vice-versa)
    if (empresaData.empresaSigla && !empresaData.empresaNome) {
        console.log('‚ö†Ô∏è [EXTRACT EMPRESA] Temos sigla mas n√£o nome, buscando nome...');
        // Tentar buscar o nome de outra fonte
        const empresaInput = formEmpresa?.querySelector('.empresa-input-cadastro, .empresa-input-readonly');
        if (empresaInput?.value && empresaInput.value.includes(' - ')) {
            const partes = empresaInput.value.split(' - ');
            if (partes[0] === empresaData.empresaSigla && partes[1]) {
                empresaData.empresaNome = partes[1];
                console.log(`‚úÖ [EXTRACT EMPRESA] Nome recuperado: ${empresaData.empresaNome}`);
            }
        }
    }

    // üÜï CORRIGIR: Formatar data se necess√°rio
    if (empresaData.dataCadastro && !empresaData.dataCadastro.includes('T')) {
        console.log(`üìÖ [EXTRACT EMPRESA] Data no formato local: ${empresaData.dataCadastro}`);
        // Manter formato local se n√£o for ISO
    }

    console.log('üè¢ [EXTRACT EMPRESA] DADOS FINAIS EXTRA√çDOS:', empresaData);
    
    // üÜï VERIFICA√á√ÉO CR√çTICA
    const statusCampos = {};
    camposEmpresa.forEach(campo => {
        statusCampos[campo] = empresaData[campo] 
            ? `‚úÖ ${empresaData[campo]}` 
            : '‚ùå AUSENTE';
    });
    
    console.log('üìã [EXTRACT EMPRESA] STATUS FINAL:', statusCampos);
    
    return empresaData;
}



// EXPORTS NO FINAL
export {
    extractEmpresaData
};
/* ==== FIM: data/builders/data-builders-folder/empresa-data-extractor.js ==== */

/* ==== IN√çCIO: data/adapters/obra-adapter-folder/empresa-form-manager.js ==== */
// empresa-form-manager.js
import { formatarData } from './ui-helpers-obra-adapter.js'
import { inicializarInputEmpresaHibrido } from './empresa-autocomplete.js'

/**
 * üÜï ATUALIZA A INTERFACE COM OS DADOS DA EMPRESA
 */
async function atualizarInterfaceComEmpresa(obraElement, obraData) {
    try {
        // Encontrar o container de cadastro de empresas
        const empresaContainer = obraElement.querySelector('.projetc-header-record.very-dark');
        if (!empresaContainer) {
            console.log(`‚ùå [EMPRESA] Container de empresa n√£o encontrado na obra "${obraData.nome}"`);
            return;
        }
        
        // üÜï ATUALIZAR HEADER DA OBRA COM SPAN (n√£o bot√£o)
        if (window.empresaCadastro && typeof window.empresaCadastro.atualizarHeaderObra === 'function') {
            window.empresaCadastro.atualizarHeaderObra(obraElement, obraData);
        }
        
        console.log(`‚úÖ [EMPRESA] Interface atualizada com SPAN no header`);
        
    } catch (error) {
        console.error(`‚ùå [EMPRESA] Erro ao atualizar interface:`, error);
    }
}

/**
 * üÜï ATUALIZA CAMPOS DO FORMUL√ÅRIO DE EMPRESA EXISTENTE - COM DATA FORMATADA
 */
function atualizarCamposEmpresaForm(obraData, formElement) {
    const camposMapping = {
        'empresaSigla': 'empresa-input',
        'numeroClienteFinal': 'numero-cliente-final',
        'clienteFinal': 'cliente-final',
        'codigoCliente': 'codigo-cliente',
        'dataCadastro': 'data-cadastro',
        'orcamentistaResponsavel': 'orcamentista-responsavel'
    };
    
    Object.entries(camposMapping).forEach(([dataField, inputId]) => {
        const input = formElement.querySelector(`#${inputId}`);
        if (input && obraData[dataField]) {
            // üÜï FORMATAR DATA SE FOR O CAMPO dataCadastro
            if (dataField === 'dataCadastro') {
                input.value = formatarData(obraData[dataField]);
            } else {
                input.value = obraData[dataField];
            }
            
            // Configurar dados adicionais para empresa
            if (dataField === 'empresaSigla' && obraData.empresaNome) {
                input.dataset.siglaSelecionada = obraData.empresaSigla;
                input.dataset.nomeSelecionado = obraData.empresaNome;
            }
        }
    });
    
    // Atualizar preview do ID da obra
    const idObraValue = formElement.querySelector('#obra-id-value');
    if (idObraContainer && idObraValue && obraData.idGerado) {
        idObraValue.textContent = obraData.idGerado;
        idObraContainer.style.display = 'block';
    }
}

/**
 * üÜï CRIA FORMUL√ÅRIO DE EMPRESA COM DADOS EXISTENTES - COM DATA FORMATADA E DATEPICKER DIN√ÇMICO
 */
function criarVisualizacaoEmpresa(obraData, container) {
    // Ocultar bot√£o se existir
    const botao = container.querySelector('.btn-empresa-cadastro');
    if (botao) {
        botao.style.display = 'none';
    }
    
    // üÜï FORMATAR DATA
    const dataFormatada = formatarData(obraData.dataCadastro);
    
    // Criar formul√°rio
    const formularioHTML = `
    <div class="empresa-formulario-ativo">
        <h4>Dados da Empresa</h4>

        <div class="empresa-form-grid-horizontal">
            <div class="form-group-horizontal">
                <label>Empresa</label>
                <input type="text" class="empresa-input-readonly" 
                    value="${obraData.empresaSigla || ''} - ${obraData.empresaNome || ''}" readonly>
            </div>

            <div class="form-group-horizontal">
                <label>N¬∫ Cliente</label>
                <input type="text" class="numero-cliente-final-readonly" 
                    value="${obraData.numeroClienteFinal || ''}" readonly>
            </div>

            <div class="form-group-horizontal">
                <label>Cliente Final</label>
                <input type="text" class="cliente-final-input" 
                    value="${obraData.clienteFinal || ''}" 
                    onchange="atualizarDadosEmpresa(this, 'clienteFinal', '${obraData.id}')">
            </div>

            <div class="form-group-horizontal">
                <label>C√≥digo</label>
                <input type="text" class="codigo-cliente-input" 
                    value="${obraData.codigoCliente || ''}" 
                    onchange="atualizarDadosEmpresa(this, 'codigoCliente', '${obraData.id}')">
            </div>

            <!-- üÜï CAMPO DE DATA COM DATEPICKER DIN√ÇMICO -->
            <div class="form-group-horizontal">
                <label>Data</label>
                <div class="date-input-container">
                    <input type="text" 
                           class="data-cadastro-input" 
                           id="data-cadastro-edit-${obraData.id}"
                           value="${dataFormatada}" 
                           placeholder="DD/MM/AAAA"
                           maxlength="10"
                           onchange="atualizarDadosEmpresa(this, 'dataCadastro', '${obraData.id}')">
                    <span class="calendar-icon" onclick="alternarDatePicker('${obraData.id}', 'edit')">üìÖ</span>
                </div>
            </div>

            <div class="form-group-horizontal">
                <label>Or√ßamentista</label>
                <input type="text" class="orcamentista-responsavel-input" 
                    value="${obraData.orcamentistaResponsavel || ''}" 
                    onchange="atualizarDadosEmpresa(this, 'orcamentistaResponsavel', '${obraData.id}')">
            </div>
        </div>

        <div class="empresa-form-actions">
            <button type="button" class="btn-cancel" 
                    onclick="window.ocultarFormularioEmpresa(this, '${obraData.id}')">
                Ocultar
            </button>
        </div>
    </div>
    `;
    
    container.insertAdjacentHTML('beforeend', formularioHTML);
    
    // üÜï CONFIGURAR AUTO-FORMATA√á√ÉO PARA O CAMPO DE DATA
    setTimeout(() => {
        const dataCampo = container.querySelector(`#data-cadastro-edit-${obraData.id}`);
        if (dataCampo) {
            configurarCampoDataEspecifico(dataCampo);
        }
    }, 100);
    
    console.log(`‚úÖ [EMPRESA] Formul√°rio criado para obra ${obraData.id} com data: ${dataFormatada}`);
}

/**
 * üÜï CRIA FORMUL√ÅRIO VAZIO DE EMPRESA COM DATEPICKER DIN√ÇMICO
 */
function criarFormularioVazioEmpresa(obraId, container) {
    const dataAtual = new Date().toLocaleDateString('pt-BR');
    
    const formularioHTML = `
    <div class="empresa-formulario-ativo">
        <h4>Cadastro de Empresa</h4>

        <div class="empresa-form-grid-horizontal">
            <!-- Empresa üü¢ EDIT√ÅVEL -->
            <div class="form-group-horizontal">
                <label>Empresa *</label>
                <div class="empresa-input-container">
                    <input type="text" 
                           class="empresa-input-cadastro" 
                           id="empresa-input-${obraId}"
                           placeholder="Digite sigla ou nome ou selecione..."
                           autocomplete="off">
                    <div class="empresa-dropdown" id="empresa-dropdown-${obraId}">
                        <div class="dropdown-options" id="empresa-options-${obraId}"></div>
                    </div>
                </div>
            </div>

            <!-- N¬∫ Cliente üî¥ SOMENTE LEITURA -->
            <div class="form-group-horizontal">
                <label>N¬∫ Cliente</label>
                <input type="text" class="numero-cliente-final-cadastro" readonly
                    placeholder="Ser√° gerado automaticamente">
            </div>

            <!-- Cliente Final üü¢ EDIT√ÅVEL -->
            <div class="form-group-horizontal">
                <label>Cliente Final</label>
                <input type="text" class="cliente-final-cadastro" 
                    placeholder="Nome do cliente final">
            </div>

            <!-- C√≥digo üü¢ EDIT√ÅVEL -->
            <div class="form-group-horizontal">
                <label>C√≥digo</label>
                <input type="text" class="codigo-cliente-cadastro" 
                    placeholder="C√≥digo do cliente">
            </div>

            <!-- Data üü¢ EDIT√ÅVEL COM DATEPICKER DIN√ÇMICO -->
            <div class="form-group-horizontal">
                <label>Data</label>
                <div class="date-input-container">
                    <input type="text" 
                           class="data-cadastro-cadastro" 
                           id="data-cadastro-${obraId}"
                           placeholder="DD/MM/AAAA"
                           value="${dataAtual}"
                           maxlength="10">
                    <span class="calendar-icon" onclick="alternarDatePicker('${obraId}', 'cadastro')">üìÖ</span>
                </div>
            </div>

            <!-- Or√ßamentista üü¢ EDIT√ÅVEL -->
            <div class="form-group-horizontal">
                <label>Or√ßamentista</label>
                <input type="text" class="orcamentista-responsavel-cadastro" 
                    placeholder="Nome do or√ßamentista">
            </div>
        </div>

        <div class="empresa-form-actions">
            <button type="button" class="btn-cancel" 
                    onclick="window.ocultarFormularioEmpresa(this, '${obraId}')">
                Cancelar
            </button>
        </div>
    </div>
    `;
    
    container.insertAdjacentHTML('beforeend', formularioHTML);
    
    // üî• INICIALIZAR COM TIMEOUT
    setTimeout(() => {
        inicializarInputEmpresaHibrido(obraId);
        
        // üÜï CONFIGURAR AUTO-FORMATA√á√ÉO PARA O CAMPO DE DATA
        const dataCampo = container.querySelector(`#data-cadastro-${obraId}`);
        if (dataCampo) {
            configurarCampoDataEspecifico(dataCampo);
            console.log('‚úÖ Auto-formata√ß√£o de data configurada');
        }
        
    }, 300);
}

/**
 * üÜï ALTERNA ENTRE INPUT TEXT E DATE QUANDO CLICA NO √çCONE
 */
function alternarDatePicker(obraId, tipo) {
    const textInput = document.getElementById(`data-cadastro-${tipo === 'edit' ? 'edit-' : ''}${obraId}`);
    const container = textInput.closest('.date-input-container');
    
    if (!textInput) return;
    
    // üÜï N√ÉO ESCONDE O √çCONE - apenas o texto
    textInput.style.display = 'none';
    
    // üÜï CRIA UM INPUT DATE VIS√çVEL MAS COM FORMATA√á√ÉO BRASILEIRA
    const datePickerHTML = `
        <div class="date-picker-visible-wrapper" id="date-picker-wrapper-${obraId}">
            <input type="date" 
                   class="date-picker-visible"
                   id="date-picker-temp-${obraId}"
                   onchange="aplicarDataDoDatePicker('${obraId}', '${tipo}', this.value)"
                   onblur="restaurarInputTexto('${obraId}', '${tipo}')">
            <div class="date-display-overlay" id="date-display-${obraId}"></div>
        </div>
    `;
    
    container.insertAdjacentHTML('beforeend', datePickerHTML);
    
    const datePicker = container.querySelector('.date-picker-visible');
    const dateDisplay = container.querySelector(`#date-display-${obraId}`);
    
    // Define valor inicial baseado no texto atual
    let dataInicial = 'DD/MM/AAAA';
    if (textInput.value && /^\d{2}\/\d{2}\/\d{4}$/.test(textInput.value)) {
        const [dia, mes, ano] = textInput.value.split('/');
        datePicker.value = `${ano}-${mes}-${dia}`;
        dataInicial = textInput.value;
    }
    
    // üÜï ATUALIZA O DISPLAY VISUAL COM FORMATA√á√ÉO BRASILEIRA
    atualizarDisplayData(dateDisplay, dataInicial);
    
    // üÜï OBSERVA MUDAN√áAS NO DATE PICKER PARA ATUALIZAR O DISPLAY
    datePicker.addEventListener('input', function() {
        if (this.value) {
            const [ano, mes, dia] = this.value.split('-');
            const dataBrasileira = `${dia}/${mes}/${ano}`;
            atualizarDisplayData(dateDisplay, dataBrasileira);
        } else {
            atualizarDisplayData(dateDisplay, 'DD/MM/AAAA');
        }
    });
    
    datePicker.addEventListener('change', function() {
        if (this.value) {
            const [ano, mes, dia] = this.value.split('-');
            const dataBrasileira = `${dia}/${mes}/${ano}`;
            atualizarDisplayData(dateDisplay, dataBrasileira);
        }
    });
    
    // Foca e abre o calend√°rio
    setTimeout(() => {
        datePicker.focus();
        datePicker.showPicker();
    }, 100);
    
    console.log('‚úÖ Date picker com formata√ß√£o brasileira ativado para obra:', obraId);
}

/**
 * üÜï APLICA A DATA SELECIONADA NO DATEPICKER AO CAMPO DE TEXTO
 */
function aplicarDataDoDatePicker(obraId, tipo, dataISO) {
    const container = document.querySelector(`#data-cadastro-${tipo === 'edit' ? 'edit-' : ''}${obraId}`).closest('.date-input-container');
    const textInput = container.querySelector(`#data-cadastro-${tipo === 'edit' ? 'edit-' : ''}${obraId}`);
    
    // üÜï VERIFICA√á√ÉO MAIS ROBUSTA PARA REMOVER O DATE PICKER
    const datePickerWrapper = document.getElementById(`date-picker-wrapper-${obraId}`);
    if (datePickerWrapper && datePickerWrapper.parentNode) {
        try {
            datePickerWrapper.remove();
            console.log('‚úÖ Date picker removido com sucesso');
        } catch (error) {
            console.log('‚ö†Ô∏è Date picker j√° foi removido:', error.message);
        }
    }
    
    if (dataISO) {
        // Converte YYYY-MM-DD para DD/MM/AAAA
        const [ano, mes, dia] = dataISO.split('-');
        const dataBrasileira = `${dia}/${mes}/${ano}`;
        
        // Aplica ao campo de texto
        textInput.value = dataBrasileira;
    }
    
    // Restaura a visualiza√ß√£o normal
    if (textInput) {
        textInput.style.display = 'block';
        // Foca no campo de texto para continuar a digita√ß√£o
        setTimeout(() => {
            textInput.focus();
            // Posiciona o cursor no final do texto
            textInput.setSelectionRange(textInput.value.length, textInput.value.length);
        }, 50);
    }
    
    // Dispara evento change se houve altera√ß√£o
    if (dataISO) {
        const event = new Event('change', { bubbles: true });
        textInput.dispatchEvent(event);
        validarDataInput(textInput);
        console.log('‚úÖ Data do date picker aplicada:', textInput.value);
    } else {
        console.log('‚úÖ Date picker cancelado');
    }
}

/**
 * üÜï RESTAURA O INPUT DE TEXTO SE O USU√ÅRIO CANCELAR
 */
function restaurarInputTexto(obraId, tipo) {
    const container = document.querySelector(`#data-cadastro-${tipo === 'edit' ? 'edit-' : ''}${obraId}`).closest('.date-input-container');
    const textInput = container.querySelector(`#data-cadastro-${tipo === 'edit' ? 'edit-' : ''}${obraId}`);
    
    // üÜï VERIFICA√á√ÉO MAIS ROBUSTA PARA REMOVER O DATE PICKER
    const datePickerWrapper = document.getElementById(`date-picker-wrapper-${obraId}`);
    if (datePickerWrapper && datePickerWrapper.parentNode) {
        try {
            datePickerWrapper.remove();
            console.log('‚úÖ Date picker removido com sucesso (blur)');
        } catch (error) {
            console.log('‚ö†Ô∏è Date picker j√° foi removido (blur):', error.message);
        }
    }
    
    // Restaura o input de texto
    if (textInput) {
        textInput.style.display = 'block';
        setTimeout(() => {
            textInput.focus();
            textInput.setSelectionRange(textInput.value.length, textInput.value.length);
        }, 50);
    }
    
    console.log('‚úÖ Input de texto restaurado');
}


/**
 * üÜï ATUALIZA O DISPLAY VISUAL DA DATA
 */
function atualizarDisplayData(dateDisplay, dataFormatada) {
    dateDisplay.textContent = dataFormatada;
    
    // Destaca visualmente se for uma data v√°lida
    if (dataFormatada && /^\d{2}\/\d{2}\/\d{4}$/.test(dataFormatada)) {
        dateDisplay.style.color = '#000';
        dateDisplay.style.fontWeight = 'normal';
        dateDisplay.style.fontStyle = 'normal';
    } else {
        dateDisplay.style.color = '#999';
        dateDisplay.style.fontWeight = 'normal';
        dateDisplay.style.fontStyle = 'italic';
    }
}



/**
 * üÜï FORMATA AUTOMATICAMENTE O CAMPO DE DATA ENQUANTO DIGITA
 * Formato: DD/MM/AAAA
 */
function configurarAutoFormatacaoData() {
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('data-cadastro-cadastro') || 
            e.target.classList.contains('data-cadastro-input')) {
            formatarDataEmTempoReal(e.target);
        }
    });
    
    // Tamb√©m prevenir caracteres n√£o num√©ricos
    document.addEventListener('keydown', function(e) {
        if (e.target.classList.contains('data-cadastro-cadastro') || 
            e.target.classList.contains('data-cadastro-input')) {
            permitirApenasNumerosEControles(e);
        }
    });
    
    // Valida√ß√£o ao sair do campo
    document.addEventListener('blur', function(e) {
        if (e.target.classList.contains('data-cadastro-cadastro') || 
            e.target.classList.contains('data-cadastro-input')) {
            validarDataInput(e.target);
        }
    }, true);
    
    console.log('‚úÖ Sistema de auto-formata√ß√£o de data configurado');
}

/**
 * üÜï FORMATA DATA EM TEMPO REAL
 */
function formatarDataEmTempoReal(input) {
    let value = input.value.replace(/\D/g, ''); // Remove n√£o n√∫meros
    
    // Aplica formata√ß√£o autom√°tica
    if (value.length > 2) {
        value = value.substring(0, 2) + '/' + value.substring(2);
    }
    if (value.length > 5) {
        value = value.substring(0, 5) + '/' + value.substring(5, 9);
    }
    
    input.value = value;
    
    // üÜï VALIDA√á√ÉO B√ÅSICA DA DATA
    validarDataInput(input);
}

/**
 * üÜï PERMITE APENAS N√öMEROS E TECLAS DE CONTROLE
 */
function permitirApenasNumerosEControles(event) {
    const teclasPermitidas = [
        'Backspace', 'Delete', 'Tab', 'Escape', 'Enter', 
        'ArrowLeft', 'ArrowRight', 'Home', 'End'
    ];
    
    if (teclasPermitidas.includes(event.key)) {
        return; // Permite teclas de controle
    }
    
    // Permite apenas n√∫meros
    if (!/^\d$/.test(event.key)) {
        event.preventDefault();
        return;
    }
    
    // üÜï LIMITA O TAMANHO M√ÅXIMO (10 caracteres com formata√ß√£o)
    const input = event.target;
    if (input.value.replace(/\D/g, '').length >= 8 && !teclasPermitidas.includes(event.key)) {
        event.preventDefault();
        return;
    }
}

/**
 * üÜï VALIDA√á√ÉO B√ÅSICA DA DATA
 */
function validarDataInput(input) {
    const value = input.value;
    
    // Verifica se est√° vazio
    if (!value) {
        input.style.borderColor = '';
        return true;
    }
    
    // Verifica formato b√°sico
    if (!/^\d{2}\/\d{2}\/\d{4}$/.test(value)) {
        input.style.borderColor = '#ff4444';
        return false;
    }
    
    // Extrai dia, m√™s e ano
    const [dia, mes, ano] = value.split('/').map(Number);
    
    // Valida√ß√µes b√°sicas
    if (dia < 1 || dia > 31) {
        input.style.borderColor = '#ff4444';
        return false;
    }
    
    if (mes < 1 || mes > 12) {
        input.style.borderColor = '#ff4444';
        return false;
    }
    
    if (ano < 1900 || ano > 2100) {
        input.style.borderColor = '#ff4444';
        return false;
    }
    
    // Valida meses com 30 dias
    const meses30Dias = [4, 6, 9, 11];
    if (meses30Dias.includes(mes) && dia > 30) {
        input.style.borderColor = '#ff4444';
        return false;
    }
    
    // Valida fevereiro e anos bissextos
    if (mes === 2) {
        const isBissexto = (ano % 4 === 0 && ano % 100 !== 0) || (ano % 400 === 0);
        if (dia > (isBissexto ? 29 : 28)) {
            input.style.borderColor = '#ff4444';
            return false;
        }
    }
    
    // Data v√°lida
    input.style.borderColor = '#4CAF50';
    return true;
}

/**
 * üÜï CONFIGURA AUTO-FORMATA√á√ÉO PARA UM CAMPO ESPEC√çFICO
 */
function configurarCampoDataEspecifico(inputElement) {
    if (!inputElement) return;
    
    inputElement.addEventListener('input', function() {
        formatarDataEmTempoReal(this);
    });
    
    inputElement.addEventListener('keydown', function(e) {
        permitirApenasNumerosEControles(e);
    });
    
    inputElement.addEventListener('blur', function() {
        validarDataInput(this);
    });
    
    // üÜï CONFIGURA PLACEHOLDER E ATRIBUTOS
    inputElement.placeholder = 'DD/MM/AAAA';
    inputElement.maxLength = 10;
    
    console.log('‚úÖ Campo de data configurado com auto-formata√ß√£o:', inputElement.id);
}

/**
 * üÜï OBT√âM DATA FORMATADA DO CAMPO
 * Retorna no formato DD/MM/AAAA para armazenamento (igual ao JSON)
 */
function obterDataFormatadaDoCampo(inputElement) {
    if (!inputElement || !inputElement.value) return null;
    
    const value = inputElement.value;
    if (!/^\d{2}\/\d{2}\/\d{4}$/.test(value)) return null;
    
    // üÜï RETORNA NO FORMATO DD/MM/AAAA (igual ao JSON)
    return value;
}

/**
 * üÜï DEFINE DATA NO CAMPO FORMATADO
 * Aceita formato YYYY-MM-DD ou DD/MM/AAAA
 */
function definirDataNoCampo(inputElement, data) {
    if (!inputElement || !data) return;
    
    let dataFormatada;
    
    if (data.includes('-')) {
        // Formato YYYY-MM-DD
        const [ano, mes, dia] = data.split('-');
        dataFormatada = `${dia}/${mes}/${ano}`;
    } else if (data.includes('/')) {
        // J√° est√° no formato DD/MM/AAAA
        dataFormatada = data;
    } else {
        console.warn('Formato de data n√£o reconhecido:', data);
        return;
    }
    
    inputElement.value = dataFormatada;
    validarDataInput(inputElement);
}

/**
 * üÜï VALIDA TODOS OS CAMPOS DE DATA DO FORMUL√ÅRIO
 */
function validarTodosCamposDataNoFormulario(formElement) {
    const camposData = formElement.querySelectorAll('.data-cadastro-cadastro, .data-cadastro-input');
    let todosValidos = true;
    
    camposData.forEach(campo => {
        if (!validarDataInput(campo)) {
            todosValidos = false;
        }
    });
    
    return todosValidos;
}

/**
 * üÜï LIMPA E RESETA CAMPO DE DATA
 */
function limparCampoData(inputElement) {
    if (!inputElement) return;
    
    inputElement.value = '';
    inputElement.style.borderColor = '';
    inputElement.placeholder = 'DD/MM/AAAA';
}

// üÜï EXPORTA AS FUN√á√ïES
export {
    atualizarInterfaceComEmpresa,
    atualizarCamposEmpresaForm,
    criarVisualizacaoEmpresa,
    criarFormularioVazioEmpresa,
    configurarAutoFormatacaoData,
    configurarCampoDataEspecifico,
    obterDataFormatadaDoCampo,
    definirDataNoCampo,
    validarTodosCamposDataNoFormulario,
    limparCampoData,
    alternarDatePicker,
    aplicarDataDoDatePicker,
    restaurarInputTexto,
    atualizarDisplayData
};

// üÜï TORNA AS FUN√á√ïES DISPON√çVEIS GLOBALMENTE PARA OS EVENTOS HTML
window.alternarDatePicker = alternarDatePicker;
window.aplicarDataDoDatePicker = aplicarDataDoDatePicker;
window.restaurarInputTexto = restaurarInputTexto;
/* ==== FIM: data/adapters/obra-adapter-folder/empresa-form-manager.js ==== */

/* ==== IN√çCIO: features/filters/filter-dom.js ==== */
/**
 * filter-dom.js - Interface gr√°fica dos filtros
 * Gerencia DOM, inputs e estados visuais
 */

const FilterDOM = (function () {
    // Elementos DOM
    let filterInputsArea = null;
    let empresaInput = null;
    let numeroClienteInput = null;
    let nomeObraInput = null;
    let inputsInitialized = false;

    /**
     * Inicializa o m√≥dulo DOM
     */
    /**
     * Inicializa o m√≥dulo DOM
     */
    function initialize() {
        console.log('üîß [FILTER-DOM] Inicializando...');

        // Buscar elementos
        filterInputsArea = document.getElementById('filtros-inputs');
        empresaInput = document.getElementById('filter-empresa');
        numeroClienteInput = document.getElementById('filter-numero-cliente');
        nomeObraInput = document.getElementById('filter-nome-obra');

        if (!validateElements()) {
            console.error('‚ùå [FILTER-DOM] Elementos dos filtros n√£o encontrados');
            return false;
        }

        // üî• INICIALIZAR OCULTO (n√£o desabilitado, mas invis√≠vel)
        setFiltersEnabled(false);

        console.log('‚úÖ [FILTER-DOM] Inicializado com sucesso (inputs ocultos)');
        return true;
    }
    /**
     * Valida se elementos existem
     */
    function validateElements() {
        const elements = [filterInputsArea, empresaInput, numeroClienteInput, nomeObraInput];
        const allExist = elements.every(el => el !== null);

        if (!allExist) {
            console.warn('‚ö†Ô∏è [FILTER-DOM] Alguns elementos n√£o encontrados:', {
                filterInputsArea: !!filterInputsArea,
                empresaInput: !!empresaInput,
                numeroClienteInput: !!numeroClienteInput,
                nomeObraInput: !!nomeObraInput
            });
        }

        return allExist;
    }

    /**
     * Habilita/desabilita os inputs de filtro
     */
    /**
     * Habilita/desabilita os inputs de filtro
     */
    function setFiltersEnabled(enabled) {
        console.log(`üéöÔ∏è [FILTER-DOM] ${enabled ? 'Habilitando' : 'Desabilitando'} inputs`);

        // üî• CORRE√á√ÉO: Controlar VISIBILIDADE al√©m de habilita√ß√£o
        [empresaInput, numeroClienteInput, nomeObraInput].forEach(input => {
            if (input) {
                // üî• IMPORTANTE: Controlar display/visibility
                if (enabled) {
                    // Mostrar e habilitar inputs
                    input.style.display = 'block';
                    input.style.visibility = 'visible';
                    input.style.opacity = '1';
                    input.disabled = false;
                    input.style.cursor = 'text';
                    input.style.height = 'auto';
                    input.style.marginTop = '4px';
                    input.style.pointerEvents = 'auto';
                } else {
                    // üî• OCULTAR COMPLETAMENTE quando desabilitado
                    input.style.display = 'none';
                    input.style.visibility = 'hidden';
                    input.style.opacity = '0';
                    input.disabled = true;
                    input.style.cursor = 'default';
                    input.style.height = '0';
                    input.style.marginTop = '0';
                    input.style.pointerEvents = 'none';
                    input.value = '';

                    // Disparar eventos de limpeza
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        });

        // üî• √Årea de inputs - controlar altura
        if (filterInputsArea) {
            if (enabled) {
                // Mostrar √°rea com transi√ß√£o suave
                filterInputsArea.style.display = 'flex'; // ou 'flex' dependendo do CSS
                filterInputsArea.style.visibility = 'visible';
                filterInputsArea.style.opacity = '1';
                filterInputsArea.style.height = 'auto';
                filterInputsArea.style.maxHeight = '200px';
                filterInputsArea.style.transition = 'all 0.3s ease';
                filterInputsArea.style.pointerEvents = 'auto';
                filterInputsArea.style.marginTop = '8px';
            } else {
                // Ocultar √°rea completamente
                filterInputsArea.style.display = 'none';
                filterInputsArea.style.visibility = 'hidden';
                filterInputsArea.style.opacity = '0';
                filterInputsArea.style.height = '0';
                filterInputsArea.style.maxHeight = '0';
                filterInputsArea.style.overflow = 'hidden';
                filterInputsArea.style.pointerEvents = 'none';
                filterInputsArea.style.marginTop = '0';
                filterInputsArea.style.padding = '0';
                filterInputsArea.style.border = 'none';
            }
        }

        // üî• Configurar listeners apenas quando habilitado pela primeira vez
        if (enabled && !inputsInitialized) {
            setupInputListeners();
            inputsInitialized = true;
        }

        // üî• Se desabilitando, notificar sistema para limpar filtros
        if (!enabled && window.FilterSystem) {
            window.FilterSystem.clearFilters();
        }
    }

    /**
     * Retorna placeholder original
     */
    function getOriginalPlaceholder(inputId) {
        const placeholders = {
            'filter-empresa': 'Empresa',
            'filter-numero-cliente': 'N¬∫ Cliente',
            'filter-nome-obra': 'Nome da Obra'
        };
        return placeholders[inputId] || '';
    }

    /**
     * Limpa todos os inputs
     */
    function clearFilterInputs() {
        console.log('üßπ [FILTER-DOM] Limpando inputs');

        [empresaInput, numeroClienteInput, nomeObraInput].forEach(input => {
            if (input) {
                input.value = '';

                // Disparar eventos
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }

    /**
     * Configura listeners nos inputs
     */
    function setupInputListeners() {
        if (!empresaInput || !numeroClienteInput || !nomeObraInput) return;

        console.log('üéß [FILTER-DOM] Configurando listeners');

        // üî• CORRE√á√ÉO: Usar 'input' em vez de 'change' para empresa
        // Para capturar sele√ß√£o do autocomplete e digita√ß√£o manual
        empresaInput.addEventListener('input', debounce(function (e) {
            const value = e.target.value.trim();
            console.log(`üè¢ [FILTER-DOM] Empresa alterada: "${value}"`);

            if (window.FilterSystem) {
                // Enviar valor completo para filtro (o sistema extrair√° a sigla)
                window.FilterSystem.updateFilterValue('empresa', value || null);
            }
        }, 500));

        // Listener para n√∫mero do cliente (com debounce)
        numeroClienteInput.addEventListener('input', debounce(function (e) {
            const value = e.target.value.trim();
            const numValue = value ? parseInt(value) : null;

            console.log(`üî¢ [FILTER-DOM] N¬∫ Cliente alterado: ${value}`);

            if (window.FilterSystem) {
                window.FilterSystem.updateFilterValue('numeroCliente', numValue);
            }
        }, 500));

        // Listener para nome da obra (com debounce)
        nomeObraInput.addEventListener('input', debounce(function (e) {
            const value = e.target.value.trim();

            console.log(`üèóÔ∏è [FILTER-DOM] Nome obra alterado: "${value}"`);

            if (window.FilterSystem) {
                window.FilterSystem.updateFilterValue('nomeObra', value || null);
            }
        }, 500));

        // Clear on Escape key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && window.FilterSystem) {
                window.FilterSystem.clearFilters();
            }
        });
    }

    /**
     * Debounce helper
     */
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    /**
     * Retorna valores atuais dos inputs
     */
    function getFilterValues() {
        return {
            empresa: empresaInput ? empresaInput.value.trim() : '',
            numeroCliente: numeroClienteInput ? numeroClienteInput.value.trim() : '',
            nomeObra: nomeObraInput ? nomeObraInput.value.trim() : ''
        };
    }

    /**
     * Atualiza placeholder dinamicamente (para dicas)
     */
    function updatePlaceholders(count) {
        if (!empresaInput || !nomeObraInput) return;

        if (count > 0) {
            empresaInput.placeholder = `Empresa (${count} obras)`;
            nomeObraInput.placeholder = `Nome da Obra (${count} obras)`;
        } else {
            empresaInput.placeholder = getOriginalPlaceholder('filter-empresa');
            nomeObraInput.placeholder = getOriginalPlaceholder('filter-nome-obra');
        }
    }

    // API p√∫blica
    return {
        initialize,
        setFiltersEnabled,
        clearFilterInputs,
        getFilterValues,
        updatePlaceholders
    };
})();

// Exportar para uso global
window.FilterDOM = FilterDOM;
/* ==== FIM: features/filters/filter-dom.js ==== */

/* ==== IN√çCIO: features/filters/filter-system.js ==== */
/**
 * filter-system.js - C√©rebro do sistema de filtros
 * Gerencia estados, switch e endpoint
 * TOTALMENTE MODULAR - n√£o altera fun√ß√µes existentes
 */

const FilterSystem = (function () {
    // Estado interno do filtro
    const state = {
        active: false,
        endpointMode: 'session', // 'session' | 'general'
        filterValues: {
            empresa: null,
            numeroCliente: null,
            nomeObra: null
        },
        systemReady: false,
        isLoading: false,
        currentObras: [] // Cache das obras carregadas
    };

    // Refer√™ncias DOM
    let filterToggle = null;
    let filterSwitchArea = null;

    /**
     * Inicializa o sistema de filtros
     */
    function initialize() {
        console.log('üîß [FILTER-SYSTEM] Inicializando...');

        // Buscar elementos DOM
        filterToggle = document.getElementById('filter-toggle');
        filterSwitchArea = document.querySelector('.filtro-switch-area');

        if (!filterToggle) {
            console.error('‚ùå [FILTER-SYSTEM] Switch de filtro n√£o encontrado');
            return false;
        }

        // Inicializar outros m√≥dulos
        if (window.FilterDOM) {
            window.FilterDOM.initialize();
        }

        // Configurar listener do switch (mas switch ainda desabilitado)
        setupSwitchListener();

        // Aguardar sistema principal carregar (mesma l√≥gica do bot√£o Nova Obra)
        waitForSystemReady();

        console.log('‚úÖ [FILTER-SYSTEM] Inicializado com sucesso');
        return true;
    }

    /**
     * Aguarda sistema principal carregar para habilitar switch
     * MESMA L√ìGICA DO BOT√ÉO "NOVA OBRA"
     */
    function waitForSystemReady() {
        console.log('‚è≥ [FILTER-SYSTEM] Aguardando sistema principal carregar...');

        const checkInterval = setInterval(() => {
            if (window.systemLoaded) {
                clearInterval(checkInterval);
                state.systemReady = true;
                enableFilterSwitch();
                console.log('‚úÖ [FILTER-SYSTEM] Sistema carregado - switch habilitado');
            }
        }, 500);

        // Timeout de seguran√ßa (30 segundos)
        setTimeout(() => {
            clearInterval(checkInterval);
            if (!state.systemReady) {
                console.warn('‚ö†Ô∏è [FILTER-SYSTEM] Timeout ao aguardar sistema carregar');
                // Tenta habilitar mesmo assim (fallback)
                enableFilterSwitch();
            }
        }, 30000);
    }

    /**
     * Habilita o switch de filtro (MESMA L√ìGICA DO BOT√ÉO "NOVA OBRA")
     */
    function enableFilterSwitch() {
        if (!filterToggle) return;

        filterToggle.disabled = false;
        filterToggle.title = 'Ativar filtros avan√ßados';

        if (filterSwitchArea) {
            filterSwitchArea.style.opacity = '1';
            filterSwitchArea.style.cursor = 'pointer';
        }

        console.log('‚úÖ [FILTER-SYSTEM] Switch de filtro habilitado');
    }

    /**
     * Configura listener para mudan√ßa do switch
     */
    function setupSwitchListener() {
        filterToggle.addEventListener('change', function (e) {
            const isActive = e.target.checked;
            handleFilterToggleChange(isActive);
        });
    }

    /**
     * Manipula mudan√ßa no switch
     */
    function handleFilterToggleChange(isActive) {
        if (state.isLoading) {
            console.log('‚è≥ [FILTER-SYSTEM] Sistema ocupado, ignorando toggle');
            filterToggle.checked = !isActive; // Reverte visualmente
            return;
        }

        console.log(`üîÄ [FILTER-SYSTEM] Switch ${isActive ? 'ATIVADO' : 'DESATIVADO'}`);

        // Atualizar estado
        state.active = isActive;
        state.endpointMode = isActive ? 'general' : 'session';

        // Limpar cache quando desativar
        if (!isActive) {
            state.currentObras = [];
        }

        // Notificar outros m√≥dulos
        if (window.FilterDOM) {
            window.FilterDOM.setFiltersEnabled(isActive);
        }

        // Inicializar autocomplete se ativado
        if (window.FilterAutocomplete && isActive) {
            window.FilterAutocomplete.initialize();
        }

        // Atualizar UI do switch
        updateSwitchUI(isActive);

        // Recarregar obras com endpoint correto
        reloadObrasWithCurrentEndpoint();
    }


    /**
     * Atualiza UI do switch
     */
    function updateSwitchUI(isActive) {
        if (!filterSwitchArea) return;

        const label = filterSwitchArea.querySelector('.switch-label-text');
        if (label) {
            label.textContent = isActive
                ? 'Filtro Ativo (Modo Geral)'
                : 'Filtro de Obras';
            label.style.color = isActive ? '#4CAF50' : '#666';
            label.style.fontWeight = isActive ? 'bold' : 'normal';
            label.style.transition = 'color 0.3s ease';
        }

        // Visual feedback no switch
        if (filterSwitchArea) {
            filterSwitchArea.style.backgroundColor = isActive
                ? 'rgba(76, 175, 80, 0.1)'
                : 'transparent';
            filterSwitchArea.style.transition = 'background-color 0.3s ease';
            filterSwitchArea.style.borderRadius = '6px';
            filterSwitchArea.style.padding = isActive ? '8px' : '4px';
        }

        // üî• ATUALIZAR: Feedback visual no switch toggle
        const switchElement = document.querySelector('.filter-switch');
        if (switchElement) {
            switchElement.style.boxShadow = isActive
                ? '0 0 10px rgba(76, 175, 80, 0.5)'
                : 'none';
        }
    }

    /**
     * Retorna endpoint correto baseado no estado
     */
    function getCurrentEndpoint() {
        if (state.active) {
            console.log('üåê [FILTER-SYSTEM] Endpoint: /obras (TODAS as obras)');
            return '/obras';
        } else {
            console.log('üåê [FILTER-SYSTEM] Endpoint: /api/session-obras (apenas sess√£o)');
            return '/api/session-obras';
        }
    }

    /**
     * Recarrega obras com endpoint atual + filtros
     */
    async function reloadObrasWithCurrentEndpoint() {
        if (state.isLoading) {
            console.log('‚è≥ [FILTER-SYSTEM] J√° recarregando, ignorando...');
            return;
        }

        state.isLoading = true;
        console.log('üîÑ [FILTER-SYSTEM] Recarregando obras...');

        try {
            // Limpar obras atuais (reutiliza fun√ß√£o existente)
            clearCurrentObras();

            if (state.active) {
                // Modo filtro: carrega TODAS as obras e aplica filtros
                await loadAndFilterAllObras();
            } else {
                // Modo normal: carrega apenas obras da sess√£o
                await loadSessionObras();
            }

            console.log('‚úÖ [FILTER-SYSTEM] Obras recarregadas com sucesso');

        } catch (error) {
            console.error('‚ùå [FILTER-SYSTEM] Erro ao recarregar obras:', error);
        } finally {
            state.isLoading = false;
        }
    }

    /**
     * Limpa obras atuais do DOM
     */
    function clearCurrentObras() {
        console.log('üßπ [FILTER-SYSTEM] Limpando obras atuais do DOM');

        // Tentar usar fun√ß√£o existente primeiro
        if (typeof removeBaseObraFromHTML === 'function') {
            removeBaseObraFromHTML();
        } else if (typeof window.removeBaseObraFromHTML === 'function') {
            window.removeBaseObraFromHTML();
        } else {
            // Fallback: limpar container manualmente
            const container = document.getElementById('projects-container');
            if (container) {
                container.innerHTML = '';
                console.log('üóëÔ∏è [FILTER-SYSTEM] Container de obras limpo manualmente');
            }
        }

        // Resetar contador se existir
        if (typeof window.resetGeralCount === 'function') {
            window.resetGeralCount();
        }
    }

    /**
     * Carrega TODAS as obras e aplica filtros
     */
    async function loadAndFilterAllObras() {
        console.log('üîç [FILTER-SYSTEM] Carregando TODAS as obras do endpoint /obras');

        try {
            // 1. Buscar todas as obras
            const response = await fetch('/obras');
            if (!response.ok) {
                throw new Error(`Erro ${response.status} ao buscar obras`);
            }

            const todasObras = await response.json();
            console.log(`üì¶ [FILTER-SYSTEM] ${todasObras.length} obras dispon√≠veis no servidor`);

            // Salvar cache para filtragem
            state.currentObras = todasObras;

            // 2. Aplicar filtros
            const obrasFiltradas = aplicarFiltros(todasObras);
            console.log(`üéØ [FILTER-SYSTEM] ${obrasFiltradas.length} obras ap√≥s filtros`);

            // 3. Carregar obras filtradas
            if (obrasFiltradas.length === 0) {
                console.log('üì≠ [FILTER-SYSTEM] Nenhuma obra corresponde aos filtros');
                return;
            }

            // 4. Carregar cada obra
            for (const obraData of obrasFiltradas) {
                await loadObraIntoDOM(obraData);
            }

        } catch (error) {
            console.error('‚ùå [FILTER-SYSTEM] Erro ao carregar todas as obras:', error);
            throw error;
        }
    }

    /**
     * Carrega uma obra no DOM (reutilizando sistema existente)
     */
    /**
     * Carrega uma obra no DOM (reutilizando sistema existente) - SEM FALLBACK
     */
    async function loadObraIntoDOM(obraData) {
        try {
            console.log(`üîÑ [FILTER-SYSTEM] Carregando obra: ${obraData.nome || obraData.id}`);

            // Verificar se j√° existe no DOM
            const obraExistente = document.querySelector(`[data-obra-id="${obraData.id}"]`);
            if (obraExistente) {
                console.log(`‚ö†Ô∏è [FILTER-SYSTEM] Obra ${obraData.id} j√° existe, ignorando`);
                return;
            }

            // üî• OP√á√ÉO 1: Usar loadSingleObra se dispon√≠vel
            if (window.systemFunctions && typeof window.systemFunctions.loadSingleObra === 'function') {
                console.log(`üî® [FILTER-SYSTEM] Carregando via loadSingleObra (systemFunctions)`);
                await window.systemFunctions.loadSingleObra(obraData);
            }
            else if (typeof window.loadSingleObra === 'function') {
                console.log(`üî® [FILTER-SYSTEM] Carregando via loadSingleObra (window)`);
                await window.loadSingleObra(obraData);
            }
            else if (typeof loadSingleObra === 'function') {
                console.log(`üî® [FILTER-SYSTEM] Carregando via loadSingleObra (global)`);
                await loadSingleObra(obraData);
            }
            // üî• OP√á√ÉO 2: Usar createEmptyObra + populateObraData
            else if (window.systemFunctions &&
                typeof window.systemFunctions.createEmptyObra === 'function' &&
                typeof window.systemFunctions.populateObraData === 'function') {
                console.log(`üî® [FILTER-SYSTEM] Criando via createEmptyObra + populateObraData`);

                // Criar obra vazia
                await window.systemFunctions.createEmptyObra(obraData.nome || `Obra ${obraData.id}`, obraData.id);

                // Aguardar cria√ß√£o no DOM
                await new Promise(resolve => setTimeout(resolve, 200));

                // Preencher dados
                const obraElement = document.querySelector(`[data-obra-id="${obraData.id}"]`);
                if (obraElement) {
                    await window.systemFunctions.populateObraData(obraData);
                }
            }
            else if (typeof window.createEmptyObra === 'function' && typeof window.populateObraData === 'function') {
                console.log(`üî® [FILTER-SYSTEM] Criando via createEmptyObra (window) + populateObraData`);

                await window.createEmptyObra(obraData.nome || `Obra ${obraData.id}`, obraData.id);
                await new Promise(resolve => setTimeout(resolve, 200));

                const obraElement = document.querySelector(`[data-obra-id="${obraData.id}"]`);
                if (obraElement) {
                    await window.populateObraData(obraData);
                }
            }
            else {
                // üî• CR√çTICO: Se n√£o encontrar fun√ß√µes de carregamento
                console.error(`‚ùå [FILTER-SYSTEM] NENHUMA fun√ß√£o de carregamento dispon√≠vel para obra ${obraData.id}`);
                console.error('üí° Verifique se estas fun√ß√µes est√£o dispon√≠veis:');
                console.error('   - loadSingleObra');
                console.error('   - createEmptyObra + populateObraData');

                // N√£o criar fallback manual - apenas logar erro
                return;
            }

            console.log(`‚úÖ [FILTER-SYSTEM] Obra "${obraData.nome}" carregada com sucesso`);

        } catch (error) {
            console.error(`‚ùå [FILTER-SYSTEM] Erro ao carregar obra ${obraData.id}:`, error);
        }
    }

    /**
     * Carrega obras da sess√£o (modo normal)
     */
    /**
     * Carrega obras da sess√£o (modo normal) - SEM FALLBACK
     */
    async function loadSessionObras() {
        console.log('üìÅ [FILTER-SYSTEM] Carregando obras da sess√£o');

        try {
            // üî• IMPORTANTE: Limpar DOM completamente primeiro
            clearCurrentObras();

            // üî• USAR SOMENTE FUN√á√ïES EXPORTADAS - SEM FALLBACK
            if (window.systemFunctions && typeof window.systemFunctions.loadObrasFromServer === 'function') {
                console.log('‚úÖ [FILTER-SYSTEM] Usando loadObrasFromServer do systemFunctions');
                await window.systemFunctions.loadObrasFromServer();
            }
            // üî• ALTERNATIVA: fun√ß√£o direta no window
            else if (typeof window.loadObrasFromServer === 'function') {
                console.log('‚úÖ [FILTER-SYSTEM] Usando loadObrasFromServer do window');
                await window.loadObrasFromServer();
            }
            // üî• ALTERNATIVA: fun√ß√£o global direta
            else if (typeof loadObrasFromServer === 'function') {
                console.log('‚úÖ [FILTER-SYSTEM] Usando loadObrasFromServer global');
                await loadObrasFromServer();
            }
            else {
                // üî• CR√çTICO: Se n√£o encontrar a fun√ß√£o, mostrar erro claro
                console.error('‚ùå [FILTER-SYSTEM] FUN√á√ÉO loadObrasFromServer N√ÉO ENCONTRADA');
                console.error('üí° SOLU√á√ÉO: Certifique-se que a fun√ß√£o est√° dispon√≠vel em:');
                console.error('   - window.loadObrasFromServer');
                console.error('   - window.systemFunctions.loadObrasFromServer');
                console.error('   - ou no escopo global (loadObrasFromServer)');

                // Lan√ßar erro para tratamento externo
                throw new Error('Fun√ß√£o loadObrasFromServer n√£o dispon√≠vel para filtros');
            }

            console.log('‚úÖ [FILTER-SYSTEM] Obras da sess√£o carregadas com sucesso');

        } catch (error) {
            console.error('‚ùå [FILTER-SYSTEM] ERRO ao carregar sess√£o:', error);

            // üî• IMPORTANTE: N√£o tentar fallback, apenas propagar o erro
            throw error;
        }
    }

    /**
     * Aplica filtros ao array de obras
     */
    function aplicarFiltros(obras) {
        if (!state.active || !obras || obras.length === 0) {
            return obras; // Se filtro n√£o ativo ou sem obras, retorna todas
        }

        const { empresa, numeroCliente, nomeObra } = state.filterValues;

        // üî• CORRE√á√ÉO: Se NENHUM filtro preenchido, retorna TODAS as obras
        const hasActiveFilter = empresa || (numeroCliente !== null && numeroCliente !== undefined) || nomeObra;

        if (!hasActiveFilter) {
            console.log('üîì [FILTER-SYSTEM] Nenhum filtro ativo - retornando TODAS as obras');
            return obras;
        }

        console.log(`üéØ [FILTER-SYSTEM] Aplicando filtros:`, { empresa, numeroCliente, nomeObra });

        return obras.filter(obra => {
            let passaEmpresa = true;
            let passaNumero = true;
            let passaNome = true;

            // üî• FILTRO POR EMPRESA - CORRE√á√ÉO CR√çTICA
            if (empresa) {
                const empresaFiltro = empresa.toUpperCase().trim();

                // Extrair apenas sigla do filtro (remover " - NOME" se existir)
                const filtroSigla = empresaFiltro.includes(' - ')
                    ? empresaFiltro.split(' - ')[0].trim()
                    : empresaFiltro;

                // Verificar em v√°rios campos da obra
                const obraSigla = (obra.empresaSigla || '').toUpperCase().trim();
                const obraNomeCompleto = (obra.empresa || '').toUpperCase().trim();
                const obraNomeEmpresa = (obra.nomeEmpresa || '').toUpperCase().trim();

                // Tentar extrair sigla do nome completo se existir
                let obraSiglaExtraida = '';
                if (obraNomeCompleto.includes(' - ')) {
                    obraSiglaExtraida = obraNomeCompleto.split(' - ')[0].trim();
                }

                passaEmpresa = obraSigla === filtroSigla ||
                    obraSigla.includes(filtroSigla) ||
                    obraNomeCompleto.includes(filtroSigla) ||
                    obraNomeEmpresa.includes(filtroSigla) ||
                    obraSiglaExtraida === filtroSigla ||
                    obraSiglaExtraida.includes(filtroSigla);

                if (!passaEmpresa) {
                    console.log(`‚ùå [FILTRO] Obra ${obra.id} falhou no filtro empresa:`, {
                        filtro: filtroSigla,
                        obraSigla,
                        obraNomeCompleto,
                        obraNomeEmpresa,
                        obraSiglaExtraida
                    });
                }
            }

            // üî• FILTRO POR N√öMERO DO CLIENTE
            if (numeroCliente !== null && numeroCliente !== undefined) {
                const filtroNumero = parseInt(numeroCliente);

                // Verificar em v√°rios campos poss√≠veis
                const obraNumero1 = obra.numeroClienteFinal ? parseInt(obra.numeroClienteFinal) : null;
                const obraNumero2 = obra.numeroCliente ? parseInt(obra.numeroCliente) : null;
                const obraNumero3 = obra.clienteNumero ? parseInt(obra.clienteNumero) : null;
                const obraNumero4 = obra.numero ? parseInt(obra.numero) : null;

                const obraNumeros = [obraNumero1, obraNumero2, obraNumero3, obraNumero4];
                const numerosValidos = obraNumeros.filter(n => n !== null && !isNaN(n));

                passaNumero = numerosValidos.some(n => n === filtroNumero);

                if (!passaNumero) {
                    console.log(`‚ùå [FILTRO] Obra ${obra.id} falhou no filtro n√∫mero:`, {
                        filtro: filtroNumero,
                        obraNumeros: numerosValidos
                    });
                }
            }

            // üî• FILTRO POR NOME DA OBRA
            if (nomeObra) {
                const filtroNome = nomeObra.toUpperCase().trim();
                const obraNome1 = (obra.nome || '').toUpperCase().trim();
                const obraNome2 = (obra.titulo || '').toUpperCase().trim();
                const obraNome3 = (obra.nomeObra || '').toUpperCase().trim();

                passaNome = obraNome1.includes(filtroNome) ||
                    obraNome2.includes(filtroNome) ||
                    obraNome3.includes(filtroNome);

                if (!passaNome) {
                    console.log(`‚ùå [FILTRO] Obra ${obra.id} falhou no filtro nome:`, {
                        filtro: filtroNome,
                        obraNome1,
                        obraNome2,
                        obraNome3
                    });
                }
            }

            const passaTodos = passaEmpresa && passaNumero && passaNome;

            if (passaTodos) {
                console.log(`‚úÖ [FILTRO] Obra ${obra.id} passou nos filtros:`, {
                    nome: obra.nome || obra.titulo,
                    empresa: obra.empresaSigla || obra.empresa
                });
            }

            return passaTodos;
        });
    }

    /**
     * Atualiza valor de um filtro espec√≠fico
     */
    function updateFilterValue(filterName, value) {
        if (state.filterValues.hasOwnProperty(filterName)) {
            const oldValue = state.filterValues[filterName];

            // üî• CORRE√á√ÉO: N√£o atualizar se valor for o mesmo (evita loop)
            if (oldValue === value) {
                return;
            }

            state.filterValues[filterName] = value;
            console.log(`üìù [FILTER-SYSTEM] Filtro "${filterName}" atualizado: ${oldValue} ‚Üí ${value}`);

            // üî• ATUALIZAR: Recarregar SEMPRE que filtro mudar (mesmo que seja null)
            if (state.active) {
                console.log('üîÑ [FILTER-SYSTEM] Filtro alterado - recarregando obras...');

                // Debounce para evitar m√∫ltiplas recargas r√°pidas
                clearTimeout(window._filterDebounce);
                window._filterDebounce = setTimeout(() => {
                    reloadObrasWithCurrentEndpoint();
                }, 300);
            }
        }
    }

    /**
     * Limpa todos os filtros
     */
    function clearFilters() {
        console.log('üßπ [FILTER-SYSTEM] Limpando todos os filtros');

        state.filterValues = {
            empresa: null,
            numeroCliente: null,
            nomeObra: null
        };

        // Notificar DOM para limpar inputs
        if (window.FilterDOM) {
            window.FilterDOM.clearFilterInputs();
        }

        // Se filtro ativo, recarregar (para mostrar todas as obras)
        if (state.active) {
            reloadObrasWithCurrentEndpoint();
        }
    }

    /**
     * Retorna estado atual
     */
    function getState() {
        return { ...state };
    }

    /**
     * Verifica se h√° filtros ativos
     */
    function hasActiveFilters() {
        return state.active && (
            state.filterValues.empresa !== null ||
            state.filterValues.numeroCliente !== null ||
            state.filterValues.nomeObra !== null
        );
    }

    // API p√∫blica
    return {
        initialize,
        updateFilterValue,
        clearFilters,
        getState,
        hasActiveFilters,
        getCurrentEndpoint
    };
})();

// Exportar para uso global
window.FilterSystem = FilterSystem;
/* ==== FIM: features/filters/filter-system.js ==== */

/* ==== IN√çCIO: data/builders/data-builders-folder/obra-data-builder.js ==== */
// data/builders/data-builders-folder/obra-data-builder.js
// Respons√°vel por montar o objeto completo da obra (incluindo dados de empresa, projetos e salas).
import { generateObraId, generateProjectId, generateRoomId } from '../../utils/id-generator.js';
import { extractEmpresaData } from './empresa-data-extractor.js';

/**
 * Constr√≥i o objeto de dados completo de uma obra a partir do HTML - VERS√ÉO CORRIGIDA
 */
function buildObraData(obraIdOrElement) {
    console.log('üö® buildObraData INICIADA - buscando elemento...');
    
    let obraElement;
    
    if (typeof obraIdOrElement === 'string') {
        obraElement = document.querySelector(`[data-obra-id="${obraIdOrElement}"]`);
        
        if (!obraElement) {
            console.error('‚ùå Obra n√£o encontrada pelo ID:', obraIdOrElement);
            
            const todasObras = document.querySelectorAll('[data-obra-id]');
            console.log('üìã Obras dispon√≠veis no DOM:', 
                Array.from(todasObras).map(o => ({
                    id: o.dataset.obraId,
                    name: o.dataset.obraName
                }))
            );
            return null;
        }
    } else if (obraIdOrElement instanceof HTMLElement) {
        if (obraIdOrElement.classList.contains('obra-block')) {
            obraElement = obraIdOrElement;
        } else {
            console.error('‚ùå Elemento n√£o √© uma obra:', obraIdOrElement);
            return null;
        }
    } else {
        console.error('‚ùå Tipo inv√°lido para obraIdOrElement:', typeof obraIdOrElement, obraIdOrElement);
        return null;
    }

    if (!document.body.contains(obraElement)) {
        console.error('‚ùå CR√çTICO: Elemento da obra N√ÉO EST√Å MAIS NO DOM!');
        return null;
    }

    const obraName = obraElement.dataset.obraName;
    const obraId = obraElement.dataset.obraId;

    console.log(`üì¶ Construindo dados da obra: "${obraName}" (ID: ${obraId}) - ELEMENTO NO DOM: ${document.body.contains(obraElement)}`);

    const finalObraId = obraId || generateObraId();
    const empresaData = extractEmpresaData(obraElement);
    
    const obraData = {
        id: finalObraId,
        nome: obraName,
        empresa_id: `empresa_${finalObraId}`,
        ...empresaData,

        projetos: []
    };


    const projectElements = obraElement.querySelectorAll('.project-block');
    console.log(`üîç Encontrados ${projectElements.length} projetos na obra "${obraName}"`);
    
    let projetosProcessados = 0;
    
    projectElements.forEach((projectElement, index) => {
        console.log(`üìù Processando projeto ${index + 1}/${projectElements.length}`);
        
        if (!document.body.contains(projectElement)) {
            console.error(`‚ùå Projeto ${index} foi removido do DOM durante o processamento!`);
            return;
        }
        
        const projectData = buildProjectData(projectElement);
        if (projectData) {
            obraData.projetos.push(projectData);
            projetosProcessados++;
            console.log(`‚úÖ Projeto "${projectData.nome}" adicionado √† obra "${obraName}"`);
        } else {
            console.error(`‚ùå Falha ao construir projeto ${index} da obra "${obraName}"`);
        }
    });

    console.log('üì¶ Dados da obra constru√≠dos:', {
        obra: obraData.nome,
        id: obraData.id,
        projetos: `${projetosProcessados}/${projectElements.length} processados`
    });
    
    console.log('üîç VERIFICA√á√ÉO FINAL - Obra ainda no DOM?:', 
        document.body.contains(obraElement) ? '‚úÖ SIM' : '‚ùå N√ÉO');
    
    return obraData;
}

/**
 * Constr√≥i o objeto de dados completo de um projeto a partir do HTML
 */
function buildProjectData(projectIdOrElement) {
    let projectElement;
    
    if (typeof projectIdOrElement === 'string') {
        projectElement = document.querySelector(`[data-project-name="${projectIdOrElement}"]`);
    } else if (projectIdOrElement instanceof HTMLElement) {
        projectElement = projectIdOrElement;
    } else {
        console.error('‚ùå Tipo inv√°lido para projectIdOrElement:', projectIdOrElement);
        return null;
    }

    if (!projectElement) {
        console.error('‚ùå Elemento do projeto n√£o encontrado:', projectIdOrElement);
        return null;
    }

    if (!document.body.contains(projectElement)) {
        console.error('‚ùå CR√çTICO: Elemento do projeto N√ÉO EST√Å MAIS NO DOM!');
        return null;
    }

    const projectName = projectElement.dataset.projectName || projectElement.id;
    const projectId = projectElement.dataset.projectId;
    const obraElement = projectElement.closest('.obra-block');

    if (!obraElement) {
        console.error('‚ùå Elemento da obra pai n√£o encontrado para projeto:', projectName);
        return null;
    }

    const finalProjectId = projectId || generateProjectId(obraElement);

    const projectData = {
        id: finalProjectId,
        nome: projectName,
        salas: [],
    };

    const roomElements = projectElement.querySelectorAll('.room-block');
    console.log(`üîç Encontradas ${roomElements.length} salas no projeto "${projectName}"`);
    
    let salasProcessadas = 0;
    
    roomElements.forEach((roomElement, index) => {
        if (!document.body.contains(roomElement)) {
            console.error(`‚ùå Sala ${index} foi removida do DOM durante o processamento!`);
            return;
        }
        
        const roomData = extractRoomData(roomElement, projectElement);
        if (roomData) {
            projectData.salas.push(roomData);
            salasProcessadas++;
        }
    });

    console.log(`‚úÖ Projeto "${projectName}" processado: ${salasProcessadas}/${roomElements.length} salas`);
    return projectData;
}

// EXPORTS NO FINAL
export {
    buildObraData,
    buildProjectData
};
/* ==== FIM: data/builders/data-builders-folder/obra-data-builder.js ==== */

/* ==== IN√çCIO: data/adapters/obra-adapter-folder/obra-data-loader.js ==== */
// obra-data-loader.js
import {atualizarInterfaceComEmpresa } from './empresa-form-manager.js'

/**
 * Remove todas as obras base do container HTML
 */
function removeBaseObraFromHTML() {
    const obrasContainer = document.getElementById("projects-container")
    if (!obrasContainer) return

    const existingObras = obrasContainer.querySelectorAll(".obra-block")
    existingObras.forEach((obra) => obra.remove())
}

/**
 * Carrega obras salvas do servidor para a sess√£o atual
 */
async function loadObrasFromServer() {
    console.log("üîÑ [LOAD OBRAS] Carregando OBRAS do servidor...");
    
    try {
        const sessionResponse = await fetch('/api/session-obras');
        if (!sessionResponse.ok) {
            console.log("üì≠ Nenhuma sess√£o ativa encontrada");
            return;
        }
        
        const sessionData = await sessionResponse.json();
        const obraIds = sessionData.obras || [];
        
        console.log(`üìä [LOAD OBRAS] Sess√£o com ${obraIds.length} obras:`, obraIds);
        
        if (obraIds.length === 0) {
            console.log("üì≠ [LOAD OBRAS] Nenhuma obra na sess√£o");
            return;
        }

        // Buscar TODAS as obras do servidor
        const obrasResponse = await fetch('/obras');
        if (!obrasResponse.ok) {
            console.error("‚ùå [LOAD OBRAS] Erro ao buscar dados das obras");
            return;
        }

        const todasObras = await obrasResponse.json();
        console.log(`üì¶ [LOAD OBRAS] ${todasObras.length} obras dispon√≠veis no servidor`);
        
        // Converter IDs da sess√£o para string e encontrar correspond√™ncias
        const obrasDaSessao = todasObras.filter(obra => {
            // Tentar encontrar por ID exato (novo formato)
            if (obraIds.includes(obra.id)) {
                return true;
            }
            
            // Tentar encontrar por ID num√©rico (compatibilidade com sess√£o antiga)
            const obraIdNumero = obra.id.toString();
            if (obraIds.includes(obraIdNumero)) {
                return true;
            }
            
            return false;
        });
        
        console.log(`üéØ [LOAD OBRAS] ${obrasDaSessao.length} obras da sess√£o encontradas:`, 
            obrasDaSessao.map(o => ({id: o.id, nome: o.nome})));

        if (obrasDaSessao.length === 0) {
            console.log("üì≠ [LOAD OBRAS] Nenhuma obra correspondente encontrada");
            return;
        }

        // Limpar interface antes de carregar
        removeBaseObraFromHTML();
        
        // Carregar cada obra individualmente com await
        let loadedCount = 0;
        for (const obraData of obrasDaSessao) {
            const success = await loadSingleObra(obraData);
            if (success) loadedCount++;
        }
        
        console.log(`‚úÖ [LOAD OBRAS] ${loadedCount}/${obrasDaSessao.length} obras carregadas com sucesso`);
        
    } catch (error) {
        console.error("‚ùå [LOAD OBRAS] Erro ao carregar obras da sess√£o:", error);
    }
}

/**
 * Fun√ß√£o para carregar uma obra individual
 */
async function loadSingleObra(obraData) {
    if (!obraData || !obraData.id) {
        console.error('‚ùå [LOAD OBRAS] Dados de obra inv√°lidos:', obraData);
        return false;
    }

    console.log(`üîÑ [LOAD OBRAS] Carregando obra: "${obraData.nome}" (ID: ${obraData.id})`);
    
    try {
        // Verificar se a obra j√° existe no DOM
        const obraExistente = document.querySelector(`[data-obra-id="${obraData.id}"]`);
        if (obraExistente) {
            console.log(`‚ö†Ô∏è [LOAD OBRAS] Obra "${obraData.nome}" j√° existe no DOM, atualizando...`);
            
            if (typeof window.populateObraData === 'function') {
                await window.populateObraData(obraData);
                console.log(`‚úÖ [LOAD OBRAS] Obra "${obraData.nome}" atualizada com sucesso`);
                return true;
            }
        }
        
        // Se n√£o existe, criar nova obra
        if (typeof window.createEmptyObra === 'function') {
            console.log(`üî® [LOAD OBRAS] Criando nova obra: "${obraData.nome}"`);
            
            // Criar obra vazia com ID espec√≠fico
            await window.createEmptyObra(obraData.nome, obraData.id);
            
            // Aguardar cria√ß√£o no DOM
            await new Promise(resolve => setTimeout(resolve, 150));
            
            // Verificar se foi criada
            const obraCriada = document.querySelector(`[data-obra-id="${obraData.id}"]`);
            if (obraCriada && typeof window.populateObraData === 'function') {
                console.log(`üé® [LOAD OBRAS] Preenchendo dados da obra "${obraData.nome}"...`);
                await window.populateObraData(obraData);
                
                // üÜï PREPARAR DADOS DE EMPRESA SE EXISTIREM
                await prepararDadosEmpresaNaObra(obraData, obraCriada);
                
                console.log(`‚úÖ [LOAD OBRAS] Obra "${obraData.nome}" carregada com sucesso`);
                return true;
            } else {
                console.error(`‚ùå [LOAD OBRAS] Falha ao criar obra "${obraData.nome}" no DOM`);
            }
        } else {
            console.error(`‚ùå [LOAD OBRAS] createEmptyObra n√£o dispon√≠vel`);
        }
        
        return false;
    } catch (error) {
        console.error(`üí• [LOAD OBRAS] ERRO ao carregar obra "${obraData.nome}":`, error);
        return false;
    }
}

/**
 * üÜï PREPARA DADOS DE EMPRESA NA OBRA CARREGADA
 */

async function prepararDadosEmpresaNaObra(obraData, obraElement) {
    try {
        console.log('üîÑ [PREPARAR EMPRESA] INICIANDO prepara√ß√£o para obra:', obraData.nome);
        console.log('üì¶ [PREPARAR EMPRESA] Dados recebidos da obra:', {
            empresaSigla: obraData.empresaSigla,
            empresaNome: obraData.empresaNome,
            numeroClienteFinal: obraData.numeroClienteFinal,
            clienteFinal: obraData.clienteFinal,
            codigoCliente: obraData.codigoCliente,
            dataCadastro: obraData.dataCadastro,
            orcamentistaResponsavel: obraData.orcamentistaResponsavel,
            idGerado: obraData.idGerado
        });

        const camposEmpresa = [
            'empresaSigla', 'empresaNome', 'numeroClienteFinal', 
            'clienteFinal', 'codigoCliente', 'dataCadastro', 
            'orcamentistaResponsavel', 'idGerado'
        ];
        
        // üÜï VERIFICAR ANTES DE ATRIBUIR
        console.log('üîç [PREPARAR EMPRESA] Data attributes ANTES da prepara√ß√£o:');
        camposEmpresa.forEach(campo => {
            console.log(`   ${campo}: "${obraElement.dataset[campo]}"`);
        });

        const temDadosEmpresa = camposEmpresa.some(campo => obraData[campo]);
        
        if (!temDadosEmpresa) {
            console.log('üì≠ [PREPARAR EMPRESA] Obra n√£o possui dados de empresa');
            return;
        }
        
        console.log('üè¢ [PREPARAR EMPRESA] Atribuindo dados aos data attributes...');
        
        // Preencher dados da empresa nos data attributes da obra
        camposEmpresa.forEach(campo => {
            const valorAntigo = obraElement.dataset[campo];
            const valorNovo = obraData[campo];
            
            if (valorNovo) {
                obraElement.dataset[campo] = valorNovo;
                console.log(`‚úÖ [PREPARAR EMPRESA] ${campo}: "${valorAntigo || 'vazio'}" ‚Üí "${valorNovo}"`);
            } else {
                console.log(`‚ùå [PREPARAR EMPRESA] ${campo}: VALOR AUSENTE nos dados da obra`);
            }
        });
        
        // üÜï VERIFICAR DEPOIS DE ATRIBUIR
        console.log('üîç [PREPARAR EMPRESA] Data attributes DEPOIS da prepara√ß√£o:');
        camposEmpresa.forEach(campo => {
            console.log(`   ${campo}: "${obraElement.dataset[campo]}"`);
        });
        
        // Atualizar interface
        await atualizarInterfaceComEmpresa(obraElement, obraData);
        
        console.log('‚úÖ [PREPARAR EMPRESA] Prepara√ß√£o conclu√≠da');
        
    } catch (error) {
        console.error('‚ùå [PREPARAR EMPRESA] Erro:', error);
    }
}

/**
 * üÜï OBT√âM DADOS DE EMPRESA DE UMA OBRA ESPEC√çFICA
 */
function obterDadosEmpresaDaObra(obraId) {
    try {
        const obraElement = document.querySelector(`[data-obra-id="${obraId}"]`);
        if (!obraElement) {
            console.error(`‚ùå [EMPRESA] Obra com ID ${obraId} n√£o encontrada`);
            return null;
        }
        
        const camposEmpresa = [
            'empresaSigla', 'empresaNome', 'numeroClienteFinal', 
            'clienteFinal', 'codigoCliente', 'dataCadastro', 
            'orcamentistaResponsavel', 'idGerado'
        ];
        
        const dadosEmpresa = {};
        let temDados = false;
        
        camposEmpresa.forEach(campo => {
            if (obraElement.dataset[campo]) {
                dadosEmpresa[campo] = obraElement.dataset[campo];
                temDados = true;
            }
        });
        
        return temDados ? dadosEmpresa : null;
        
    } catch (error) {
        console.error(`‚ùå [EMPRESA] Erro ao obter dados de empresa:`, error);
        return null;
    }
}

// Fun√ß√£o alternativa para debug
async function debugLoadObras() {
    console.log("üêõ [DEBUG] Iniciando debug do carregamento...");
    
    // Verificar fun√ß√µes globais
    console.log("üîç [DEBUG] Fun√ß√µes dispon√≠veis:", {
        createEmptyObra: typeof window.createEmptyObra,
        populateObraData: typeof window.populateObraData,
        createEmptyProject: typeof window.createEmptyProject,
        createEmptyRoom: typeof window.createEmptyRoom,
        obterDadosEmpresa: typeof window.obterDadosEmpresa
    });
    
    // Verificar obras no servidor
    try {
        const response = await fetch('/obras');
        if (response.ok) {
            const obras = await response.json();
            console.log(`üì¶ [DEBUG] Obras no servidor: ${obras.length}`, obras.map(o => ({
                id: o.id, 
                nome: o.nome,
                empresaSigla: o.empresaSigla,
                idGerado: o.idGerado
            })));
        }
    } catch (error) {
        console.error("‚ùå [DEBUG] Erro ao buscar obras:", error);
    }
}

// EXPORTS NO FINAL
export {
    removeBaseObraFromHTML,
    loadObrasFromServer,
    loadSingleObra,
    prepararDadosEmpresaNaObra,
    obterDadosEmpresaDaObra,
    debugLoadObras
};
/* ==== FIM: data/adapters/obra-adapter-folder/obra-data-loader.js ==== */
