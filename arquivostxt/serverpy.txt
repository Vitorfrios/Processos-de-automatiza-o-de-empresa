
/* ==== IN√çCIO: handlers/http_handler.py ==== */
# servidor_modules/handlers/http_handler.py

import http.server
import json
import time
from urllib.parse import parse_qs, urlparse
from pathlib import Path
import os
import gzip
import threading
import re



# IMPORTS
from servidor_modules.utils.file_utils import FileUtils


class UniversalHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """Handler ULTRA-R√ÅPIDO com CACHE BUSTER AUTOM√ÅTICO PARA TODOS OS ARQUIVOS"""

    # Arquivos que NUNCA devem ser logados (acelera MUITO)
    SILENT_PATHS = {
        "/static/",
        ".css",
        ".js",
        ".png",
        ".jpg",
        ".jpeg",
        "/public/static/",
        "/public/scripts/",
        ".woff",
        ".woff2",
        ".ico",
        ".svg",
        ".gif",
        ".map",
        ".ttf",
        ".eot",
    }

    # Roteamento direto para m√°xima velocidade
    API_ROUTES = {
        # ROTAS EXISTENTES DO SISTEMA
        "/constants": "handle_get_constants",
        "/system-constants": "handle_get_constants",
        "/dados": "handle_get_dados",
        "/backup": "handle_get_backup",
        "/machines": "handle_get_machines",
        "/health-check": "handle_health_check",
        "/session-obras": "handle_get_session_obras",
        "/api/session-obras": "handle_get_session_obras",
        "/api/sessions/current": "handle_get_sessions_current",
        "/api/backup-completo": "handle_get_backup_completo",
        "/api/dados/empresas": "handle_get_empresas",
        "/obras": "handle_get_obras",
        "/api/server/uptime": "handle_get_server_uptime",
        # ========== ROTAS PARA EQUIPAMENTOS ==========
        "/api/acessorios": "handle_get_acessorios",
        "/api/acessorios/types": "handle_get_acessorio_types",
        "/api/acessorios/dimensoes": "handle_get_acessorio_dimensoes",
        # ========== NOVAS ROTAS PARA SISTEMA DE EDI√á√ÉO ==========
        # ROTAS GET - DADOS DO SISTEMA
        "/api/system-data": "handle_get_system_data",
        "/api/constants": "handle_get_constants_json",
        "/api/materials": "handle_get_materials",
        "/api/empresas/all": "handle_get_all_empresas",
        "/api/empresas/": "handle_delete_empresa_route",
        # ROTAS GET - M√ÅQUINAS
        "/api/machines/types": "handle_get_machine_types",
        # '/api/machines/type/{type}' √© tratada separadamente no handle_machine_routes
        # ROTAS POST - SALVAMENTO DE DADOS
        "/api/system-data/save": "handle_post_save_system_data",
        "/api/constants/save": "handle_post_save_constants",
        "/api/materials/save": "handle_post_save_materials",
        "/api/empresas/save": "handle_post_save_empresas",
        "/api/machines/save": "handle_post_save_machines",
        "/api/machines/add": "handle_post_add_machine",
        "/api/machines/update": "handle_post_update_machine",
        "/api/machines/delete": "handle_post_delete_machine",  # NOVA ROTA ADICIONADA
        # ROTAS DE EMPRESAS ESPEC√çFICAS
        "/api/dados/empresas/auto": "handle_post_empresas_auto",
        # ROTAS DE SESS√ÉO
        "/api/sessions/shutdown": "handle_post_sessions_shutdown",
        "/api/sessions/ensure-single": "handle_post_sessions_ensure_single",
        "/api/sessions/add-obra": "handle_post_sessions_add_obra",
        "/api/reload-page": "handle_post_reload_page",
        # ROTAS DE SHUTDOWN
        "/api/shutdown": "handle_shutdown",
        # ROTA UNIVERSAL DELETE
        "/api/delete": "handle_delete_universal",
        # APIS do json

        "/api/system/apply-json": "handle_post_apply_json",
        
        # ========== ROTAS PARA DUTOS ==========
        "/api/dutos": "handle_get_dutos",
        "/api/dutos/types": "handle_get_duto_types",
        "/api/dutos/opcionais": "handle_get_duto_opcionais",
               
        # ========== ROTAS PARA TUBOS ==========
        "/api/tubos": "handle_get_tubos",
        "/api/tubos/polegadas": "handle_get_tubo_polegadas",
        
        
        # ========= ROTAS PARA WORD ========== #
        "/api/word/models": "handle_get_word_models",
        "/api/word/templates": "handle_get_word_templates",
        "/api/word/generate/proposta-comercial": "handle_generate_word_proposta_comercial",
        "/api/word/generate/proposta-tecnica": "handle_generate_word_proposta_tecnica",
        "/api/word/generate/ambos": "handle_generate_word_ambos",
        "/api/word/download": "handle_download_word",
    }

    def __init__(self, *args, **kwargs):
        # INICIALIZA√á√ÉO R√ÅPIDA
        self.file_utils = FileUtils()
        self.project_root = self.file_utils.find_project_root()

        # Timestamp √∫nico para TODOS os arquivos (muda a cada execu√ß√£o do servidor)
        self.CACHE_BUSTER = f"v{int(time.time())}"
        print(f"üîÑ CACHE BUSTER INICIADO: {self.CACHE_BUSTER}")

        # Inicializa√ß√£o Pregui√ßosa - s√≥ quando necess√°rio
        self._routes_core = None
        self._route_handler = None

        serve_directory = self.project_root
        super().__init__(*args, directory=str(serve_directory), **kwargs)

    @property
    def routes_core(self):
        """Inicializa√ß√£o pregui√ßosa do RoutesCore"""
        if self._routes_core is None:
            from servidor_modules.core.routes_core import RoutesCore
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner

            self._routes_core = RoutesCore(
                self.project_root, sessions_manager, self.file_utils, CacheCleaner()
            )
        return self._routes_core

    @property
    def route_handler(self):
        """Inicializa√ß√£o pregui√ßosa do RouteHandler"""
        if self._route_handler is None:
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner
            from servidor_modules.handlers.route_handler import RouteHandler

            self._route_handler = RouteHandler(
                self.project_root, sessions_manager, self.file_utils, CacheCleaner()
            )
            self._route_handler.set_routes_core(self.routes_core)
        return self._route_handler


    def do_GET(self):
        """GET com CACHE BUSTER AUTOM√ÅTICO para CSS/JS/HTML"""
        parsed_path = urlparse(self.path)
        original_path = self.path
        path = parsed_path.path

        # Normaliza√ß√£o r√°pida de path
        if path.startswith("/codigo/"):
            path = path[7:]

        # Log apenas para rotas importantes (acelera MUITO)
        if not any(silent in path for silent in self.SILENT_PATHS):
            print(f"üì• GET: {path}")

        # CACHE BUSTER AUTOM√ÅTICO: Adiciona versionamento a CSS, JS e HTML
        if any(path.endswith(ext) for ext in [".css", ".js", ".html", ".htm"]):
            new_path = self._add_cache_buster(original_path)
            if new_path != original_path:
                print(f"üîÑ AUTO CACHE BUSTER: {original_path} -> {new_path}")
                self.path = new_path

        # ========== ROTEAMENTO R√ÅPIDO PARA APIs ==========

        # Rotas definidas no dicion√°rio API_ROUTES
        if path in self.API_ROUTES:
            handler_name = self.API_ROUTES[path]
            try:
                getattr(self.route_handler, handler_name)(self)
            except AttributeError as e:
                print(f"‚ùå Handler n√£o encontrado: {handler_name}")
                print(
                    f"‚ùå M√©todos dispon√≠veis: {[m for m in dir(self.route_handler) if not m.startswith('_')]}"
                )
                self.send_error(501, f"Handler n√£o implementado: {handler_name}")

        # ========== ROTAS COM PAR√ÇMETROS ==========

        # Rotas de empresas com par√¢metros
        elif path.startswith("/api/dados/empresas/buscar/"):
            termo = path.split("/")[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith("/api/dados/empresas/numero/"):
            sigla = path.split("/")[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)

        # Rotas de obras com ID
        elif path.startswith("/obras/"):
            self.handle_obra_routes(path)

        # Rotas de m√°quinas com par√¢metros
        elif path.startswith("/api/machines/"):
            self.handle_machine_routes(path)

        # ========== ROTAS PARA EQUIPAMENTOS ==========

        # Rotas de acessorios com par√¢metros
        elif path.startswith("/api/acessorios/type/"):
            self.handle_get_acessorio_by_type()

        elif path.startswith("/api/acessorios/search"):
            self.handle_get_search_acessorios()
            
        # ========== ROTAS PARA DUTOS ==========
        elif path.startswith("/api/dutos/type/"):
            self.handle_get_duto_by_type()
            
        elif path.startswith("/api/dutos/search"):
            self.handle_get_search_dutos()

        # ========== ROTAS PARA TUBOS ==========
        elif path.startswith("/api/tubos/polegada/"):
            self.handle_get_tubo_por_polegada()
        elif path.startswith("/api/tubos/search"):
            self.handle_get_search_tubos()
            
        # ========== ARQUIVOS EST√ÅTICOS ==========
        else:
            # Serve arquivo est√°tico COM HEADERS ANTI-CACHE
            self.serve_static_file_no_cache(path)

    def do_POST(self):
        """POST com todas as rotas necess√°rias"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"üì® POST: {path}")
        
        # ========== ROTAS PARA WORD ==========
        if path == "/api/word/generate/proposta-comercial":
            self.handle_generate_word_proposta_comercial()
        elif path == "/api/word/generate/proposta-tecnica":
            self.handle_generate_word_proposta_tecnica()
        elif path == "/api/word/generate/ambos":
            self.handle_generate_word_ambos()
            
        # ========== ROTAS PARA EQUIPAMENTOS ==========

        # ROTAS PARA EQUIPAMENTOS
        if path == "/api/acessorios/add":
            self.handle_post_add_acessorio()
        elif path == "/api/acessorios/update":
            self.handle_post_update_acessorio()
        elif path == "/api/acessorios/delete":
            self.handle_post_delete_acessorio()

        # ========== ROTAS PARA JSON ==========

        elif path == "/api/system/apply-json":
            self.handle_post_system_apply_json()


        # ========== ROTAS EXISTENTES ==========
        elif path == "/obras":
            self.route_handler.handle_post_obras(self)

        # ========== ROTAS DE SESS√ÉO ==========
        elif path == "/api/sessions/shutdown":
            self.route_handler.handle_post_sessions_shutdown(self)
        elif path == "/api/shutdown":
            self.route_handler.handle_shutdown(self)
        elif path == "/api/sessions/ensure-single":
            self.route_handler.handle_post_sessions_ensure_single(self)
        elif path == "/api/sessions/add-obra":
            self.route_handler.handle_post_sessions_add_obra(self)
        elif path == "/api/reload-page":
            self.route_handler.handle_post_reload_page(self)

        # ========== ROTAS DE DADOS ==========
        elif path == "/dados":
            self.route_handler.handle_post_dados(self)
        elif path == "/backup":
            self.route_handler.handle_post_backup(self)

        # ========== ROTAS DE EMPRESAS ==========
        elif path == "/api/dados/empresas":
            self.route_handler.handle_post_empresas(self)
        elif path == "/api/dados/empresas/auto":
            self.route_handler.handle_post_empresas_auto(self)

        # ========== ROTAS LEGACY (COMPATIBILIDADE) ==========
        elif path in ["/projetos", "/projects"]:
            self.route_handler.handle_post_projetos(self)

        # ========== NOVAS ROTAS PARA EDI√á√ÉO DE DADOS ==========

        # ROTAS DE SALVAMENTO COMPLETO
        elif path == "/api/system-data/save":
            self.route_handler.handle_post_save_system_data(self)

        # ROTAS DE SALVAMENTO POR SE√á√ÉO
        elif path == "/api/constants/save":
            self.route_handler.handle_post_save_constants(self)
        elif path == "/api/materials/save":
            self.route_handler.handle_post_save_materials(self)
        elif path == "/api/empresas/save":
            self.route_handler.handle_post_save_empresas(self)
        elif path == "/api/machines/save":
            self.route_handler.handle_post_save_machines(self)

        # ROTAS ESPEC√çFICAS DE M√ÅQUINAS
        elif path == "/api/machines/add":
            self.route_handler.handle_post_add_machine(self)
        elif path == "/api/machines/update":
            self.route_handler.handle_post_update_machine(self)
        elif path == "/api/machines/delete":
            self.route_handler.handle_post_delete_machine(self)
            
        # ========== ROTAS PARA DUTOS ==========
        elif path == "/api/dutos/add":
            self.handle_post_add_duto()
        elif path == "/api/dutos/update":
            self.handle_post_update_duto()
        elif path == "/api/dutos/delete":
            self.handle_post_delete_duto()

        # ========== ROTAS PARA TUBOS ==========
        elif path == "/api/tubos/add":
            self.handle_post_add_tubo()
        elif path == "/api/tubos/update":
            self.handle_post_update_tubo()
        elif path == "/api/tubos/delete":
            self.handle_post_delete_tubo()

        # ========== ROTA N√ÉO ENCONTRADA ==========
        else:
            print(f"‚ùå POST n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: POST {path}")

    def do_PUT(self):
        """PUT para atualiza√ß√µes"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"üì® PUT: {path}")

        # ROTAS PRINCIPAIS - OBRAS
        if path.startswith("/obras/"):
            print(f"üéØ Roteando PUT para obra: {path}")
            self.route_handler.handle_put_obra(self)
        else:
            print(f"‚ùå PUT n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: PUT {path}")

    def do_DELETE(self):
        """DELETE para remo√ß√£o de recursos"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"üóëÔ∏è  DELETE: {path}")

        # ========== NOVA ROTA UNIVERSAL ==========
        if path == "/api/delete":
            self.handle_delete_universal()

        # ========== ROTA ESPEC√çFICA PARA EMPRESAS ==========
        elif path.startswith("/api/empresas/"):
            self.handle_delete_empresa()

        # ROTAS PRINCIPAIS - OBRAS
        elif path.startswith("/obras/"):
            obra_id = path.split("/")[-1]
            print(f"üéØ Roteando DELETE para obra: {obra_id}")
            self.route_handler.handle_delete_obra(self, obra_id)
        # ROTAS PRINCIPAIS - SESS√ïES OBRAS
        elif path.startswith("/api/sessions/remove-obra/"):
            obra_id = path.split("/")[-1]
            self.route_handler.handle_delete_sessions_remove_obra(self, obra_id)

        else:
            print(f"‚ùå DELETE n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: DELETE {path}")

    def handle_delete_universal(self):
        """API universal para deletar qualquer item do backup.json usando path"""
        try:
            content_length = int(self.headers["Content-Length"])
            post_data = self.rfile.read(content_length).decode("utf-8")
            data = json.loads(post_data)

            # Obrigat√≥rio: path como array (ex: ["obras", "obra_id", "projetos", "projeto_id"])
            path = data.get("path")

            if not path or not isinstance(path, list):
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Path inv√°lido. Deve ser um array (ex: ['obras', 'id_da_obra'])",
                    },
                    status=400,
                )
                return

            print(f"üóëÔ∏è  DELETE UNIVERSAL - Path: {path}")

            # Chama o m√©todo no RoutesCore
            result = self.routes_core.handle_delete_universal(path)

            if result["success"]:
                self.send_json_response(result)
            else:
                self.send_json_response(result, status=500)

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"}, status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_universal: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_health_check(self):
        """Health check r√°pido"""
        self.send_json_response({"status": "online", "timestamp": time.time()})

    def handle_empresa_routes(self, path):
        """Rotas de empresa otimizadas"""
        if path.startswith("/api/dados/empresas/buscar/"):
            termo = path.split("/")[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith("/api/dados/empresas/numero/"):
            sigla = path.split("/")[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)

    def handle_obra_routes(self, path):
        """Rotas de obra otimizadas"""
        if self.command == "GET":
            obra_id = path.split("/")[-1]
            self.route_handler.handle_get_obra_by_id(self, obra_id)

    def _add_cache_buster(self, path):
        """Adiciona cache buster √† URL se n√£o tiver"""
        if "?" in path:
            # J√° tem par√¢metros, adiciona ou atualiza o v=
            if "v=" in path:
                # Substitui vers√£o existente
                path = re.sub(r"[?&]v=[^&]+", f"&v={self.CACHE_BUSTER}", path)
                # Corrige se ficou ?& substituindo por ?
                path = path.replace("?&", "?")
            else:
                # Adiciona novo par√¢metro
                path += f"&v={self.CACHE_BUSTER}"
        else:
            # Primeiro par√¢metro
            path += f"?v={self.CACHE_BUSTER}"

        return path

    def serve_static_file_no_cache(self, path):
        """Serve arquivos est√°ticos - sempre do disco com headers anti-cache"""
        try:
            # Remove par√¢metros para encontrar arquivo real
            clean_path = path.split("?")[0]
            file_path = self.translate_path(clean_path)

            if os.path.isfile(file_path):
                self.send_response(200)

                # Determina content-type
                if clean_path.endswith(".css"):
                    content_type = "text/css"
                elif clean_path.endswith(".js"):
                    content_type = "application/javascript"
                elif clean_path.endswith((".html", ".htm")):
                    content_type = "text/html"
                elif clean_path.endswith(".json"):
                    content_type = "application/json"
                elif clean_path.endswith(".png"):
                    content_type = "image/png"
                elif clean_path.endswith(".jpg") or clean_path.endswith(".jpeg"):
                    content_type = "image/jpeg"
                elif clean_path.endswith(".svg"):
                    content_type = "image/svg+xml"
                else:
                    content_type = self.guess_type(clean_path)

                self.send_header("Content-type", content_type)

                # HEADERS ANTI-CACHE DEFINITIVOS
                self.send_header(
                    "Cache-Control", "no-cache, no-store, must-revalidate, max-age=0"
                )
                self.send_header("Pragma", "no-cache")
                self.send_header("Expires", "0")
                self.send_header("Last-Modified", self.date_time_string(time.time()))

                self.end_headers()

                with open(file_path, "rb") as f:
                    self.wfile.write(f.read())
            else:
                self.send_error(404, f"File not found: {clean_path}")

        except Exception as e:
            print(f"‚ùå Erro em {path}: {e}")
            self.send_error(404, f"Recurso n√£o encontrado: {path}")

    def send_json_response(self, data, status=200):
        """Resposta JSON R√ÅPIDA SEM compress√£o para simplicidade"""
        try:
            response = json.dumps(data, ensure_ascii=False).encode("utf-8")

            # Resposta direta SEM compress√£o
            self.send_response(status)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.send_header("Content-Length", str(len(response)))
            self.send_header("Cache-Control", "no-cache, no-store, must-revalidate")
            self.send_header("Pragma", "no-cache")
            self.send_header("Expires", "0")
            self.end_headers()
            self.wfile.write(response)

        except Exception as e:
            print(f"‚ùå Erro em send_json_response: {e}")
            self.send_error(500, "Erro interno")

    def end_headers(self):
        """Headers CORS otimizados"""
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header(
            "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS"
        )
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        # Headers anti-cache
        self.send_header("Cache-Control", "no-cache, no-store, must-revalidate")
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "0")
        super().end_headers()

    def do_OPTIONS(self):
        """CORS r√°pido"""
        self.send_response(200)
        self.end_headers()

    def log_message(self, format, *args):
        """Log SILENCIOSO - apenas erros e APIs importantes"""
        message = format % args
        # Apenas logs importantes
        if any(
            keyword in message
            for keyword in [" 404", " 500", " 403", "/api/", "/obras", "/empresas"]
        ):
            print(f"üåê {self.address_string()} - {message}")

    def handle_machine_routes(self, path):
        """Rotas espec√≠ficas para m√°quinas"""
        if self.command == "GET":
            if path == "/api/machines/types":
                self.route_handler.handle_get_machine_types(self)
            elif path.startswith("/api/machines/type/"):
                machine_type = path.split("/")[-1]
                self.route_handler.handle_get_machine_by_type(self, machine_type)
        elif self.command == "POST":
            # As rotas POST de m√°quinas j√° s√£o tratadas no do_POST
            pass

    def handle_delete_empresa(self):
        """Handler para DELETE /api/empresas/{index}"""
        try:
            # Extrai o √≠ndice da URL (ex: /api/empresas/21 -> index=21)
            index = self.path.split("/")[-1]
            print(f"üóëÔ∏è  DELETE empresa - √≠ndice: {index}")

            # Chama o m√©todo no RoutesCore
            result = self.routes_core.handle_delete_empresa_by_index(index)

            if result.get("success"):
                self.send_json_response(result)
            else:
                self.send_json_response(result, status=500)

        except Exception as e:
            print(f"‚ùå Erro em handle_delete_empresa: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_system_apply_json(self):
        """Rota: /api/system/apply-json - Compara JSONs e retorna diferen√ßas"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            current = data.get("current", {})
            proposed = data.get("proposed", {})

            print(
                f"üîç Comparando JSONs: current={bool(current)}, proposed={bool(proposed)}"
            )

            # Valida√ß√£o b√°sica ATUALIZADA
            required_sections = [
                "constants", 
                "machines", 
                "materials", 
                "empresas",
                "banco_acessorios"  # ADICIONADO
            ]
            
            for section in required_sections:
                if section not in proposed:
                    return self.send_json_response(
                        {
                            "success": False,
                            "error": f"Se√ß√£o '{section}' n√£o encontrada no JSON proposto",
                        },
                        400,
                    )

            # Calcular diferen√ßas (j√° atualizada anteriormente)
            differences = self._calculate_simple_differences(current, proposed)
            summary = self._generate_simple_summary(differences)

            print(f"üìä Compara√ß√£o conclu√≠da: {summary['total_changes']} altera√ß√µes")

            self.send_json_response(
                {
                    "success": True,
                    "differences": differences,
                    "summary": summary,
                    "message": "Compara√ß√£o realizada com sucesso",
                },
                200,
            )

        except json.JSONDecodeError:
            self.send_json_response({"success": False, "error": "JSON inv√°lido"}, 400)
        except Exception as e:
            print(f"‚ùå Erro em handle_post_system_apply_json: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )

    def _calculate_simple_differences(self, current, proposed):
        """Calcula diferen√ßas simples entre JSONs"""
        diffs = {
            "constants": {"added": [], "modified": [], "removed": []},
            "machines": {"added": [], "modified": [], "removed": []},
            "materials": {"added": [], "modified": [], "removed": []},
            "empresas": {"added": [], "modified": [], "removed": []},
            "banco_acessorios": {"added": [], "modified": [], "removed": []},
            "dutos": {"added": [], "modified": [], "removed": []},
            "tubos": {"added": [], "modified": [], "removed": []},  # ADICIONADO
        }

        # Constants
        current_const = current.get("constants", {})
        proposed_const = proposed.get("constants", {})

        for key in proposed_const:
            if key not in current_const:
                diffs["constants"]["added"].append(key)
            elif json.dumps(proposed_const[key]) != json.dumps(current_const[key]):
                diffs["constants"]["modified"].append(key)

        for key in current_const:
            if key not in proposed_const:
                diffs["constants"]["removed"].append(key)

        # Machines (por type)
        current_machines = {m.get("type", ""): m for m in current.get("machines", [])}
        proposed_machines = {m.get("type", ""): m for m in proposed.get("machines", [])}

        for type_name in proposed_machines:
            if type_name not in current_machines:
                diffs["machines"]["added"].append(type_name)
            elif json.dumps(proposed_machines[type_name]) != json.dumps(
                current_machines[type_name]
            ):
                diffs["machines"]["modified"].append(type_name)

        for type_name in current_machines:
            if type_name not in proposed_machines:
                diffs["machines"]["removed"].append(type_name)

        # Materials
        current_materials = current.get("materials", {})
        proposed_materials = proposed.get("materials", {})

        for key in proposed_materials:
            if key not in current_materials:
                diffs["materials"]["added"].append(key)
            elif json.dumps(proposed_materials[key]) != json.dumps(
                current_materials[key]
            ):
                diffs["materials"]["modified"].append(key)

        for key in current_materials:
            if key not in proposed_materials:
                diffs["materials"]["removed"].append(key)

        # Dutos (por type)
        current_dutos = {d.get("type", ""): d for d in current.get("dutos", [])}
        proposed_dutos = {d.get("type", ""): d for d in proposed.get("dutos", [])}
        
        for type_name in proposed_dutos:
            if type_name not in current_dutos:
                diffs["dutos"]["added"].append(type_name)
            elif json.dumps(proposed_dutos[type_name]) != json.dumps(current_dutos[type_name]):
                diffs["dutos"]["modified"].append(type_name)
        
        for type_name in current_dutos:
            if type_name not in proposed_dutos:
                diffs["dutos"]["removed"].append(type_name)
        
        # Tubos (por polegadas)
        current_tubos = {t.get("polegadas", ""): t for t in current.get("tubos", [])}
        proposed_tubos = {t.get("polegadas", ""): t for t in proposed.get("tubos", [])}
        
        for polegadas in proposed_tubos:
            if polegadas not in current_tubos:
                diffs["tubos"]["added"].append(polegadas)
            elif json.dumps(proposed_tubos[polegadas]) != json.dumps(current_tubos[polegadas]):
                diffs["tubos"]["modified"].append(polegadas)
        
        for polegadas in current_tubos:
            if polegadas not in proposed_tubos:
                diffs["tubos"]["removed"].append(polegadas)
        
        # Empresas (por primeiro campo)
        def get_empresa_key(empresa):
            return next(iter(empresa)) if empresa else ""

        current_empresas_dict = {
            get_empresa_key(e): e for e in current.get("empresas", [])
        }
        proposed_empresas_dict = {
            get_empresa_key(e): e for e in proposed.get("empresas", [])
        }

        for key in proposed_empresas_dict:
            if key not in current_empresas_dict:
                diffs["empresas"]["added"].append(key)
            elif json.dumps(proposed_empresas_dict[key]) != json.dumps(
                current_empresas_dict[key]
            ):
                diffs["empresas"]["modified"].append(key)

        for key in current_empresas_dict:
            if key not in proposed_empresas_dict:
                diffs["empresas"]["removed"].append(key)

        # Banco de Acessorios
        current_acessorios = current.get("banco_acessorios", {})
        proposed_acessorios = proposed.get("banco_acessorios", {})

        for key in proposed_acessorios:
            if key not in current_acessorios:
                diffs["banco_acessorios"]["added"].append(key)
            elif json.dumps(proposed_acessorios[key]) != json.dumps(
                current_acessorios[key]
            ):
                diffs["banco_acessorios"]["modified"].append(key)

        for key in current_acessorios:
            if key not in proposed_acessorios:
                diffs["banco_acessorios"]["removed"].append(key)

        return diffs

    def _generate_simple_summary(self, differences):
        """Gera resumo simples das diferen√ßas"""
        total_added = (
            len(differences["constants"]["added"]) +
            len(differences["machines"]["added"]) +
            len(differences["materials"]["added"]) +
            len(differences["empresas"]["added"]) +
            len(differences["banco_acessorios"]["added"]) +
            len(differences["dutos"]["added"]) +
            len(differences["tubos"]["added"])  # ADICIONADO
        )
        
        total_modified = (
            len(differences["constants"]["modified"]) +
            len(differences["machines"]["modified"]) +
            len(differences["materials"]["modified"]) +
            len(differences["empresas"]["modified"]) +
            len(differences["banco_acessorios"]["modified"]) +
            len(differences["dutos"]["modified"]) +
            len(differences["tubos"]["modified"])  # ADICIONADO
        )
        
        total_removed = (
            len(differences["constants"]["removed"]) +
            len(differences["machines"]["removed"]) +
            len(differences["materials"]["removed"]) +
            len(differences["empresas"]["removed"]) +
            len(differences["banco_acessorios"]["removed"]) +
            len(differences["dutos"]["removed"]) +
            len(differences["tubos"]["removed"])  # ADICIONADO
        )
        
        return {
            "total_changes": total_added + total_modified + total_removed,
            "total_added": total_added,
            "total_modified": total_modified,
            "total_removed": total_removed,
            "has_changes": (total_added + total_modified + total_removed) > 0,
        }

    def handle_get_acessorios(self):
        """GET /api/acessorios - Retorna todos os acessorios"""
        try:
            # Carrega dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verifica se existe a se√ß√£o banco_acessorios
            banco_acessorios = dados_data.get("banco_acessorios", {})

            self.send_json_response(
                {
                    "success": True,
                    "acessorios": banco_acessorios,
                    "count": len(banco_acessorios),
                }
            )

        except Exception as e:
            print(f"‚ùå Erro em handle_get_acessorios: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_acessorio_types(self):
        """GET /api/acessorios/types - Retorna tipos de acessorios"""
        try:
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            banco_acessorios = dados_data.get("banco_acessorios", {})
            types = list(banco_acessorios.keys())

            # Ordenar tipos (opcional)
            types.sort()

            self.send_json_response(
                {"success": True, "types": types, "count": len(types)}
            )

        except Exception as e:
            print(f"‚ùå Erro em handle_get_acessorio_types: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_acessorio_by_type(self):
        """GET /api/acessorios/type/{type} - Retorna acessorios por tipo"""
        try:
            # Extrair tipo da URL
            path_parts = self.path.split("/")
            if len(path_parts) < 5:
                self.send_json_response(
                    {"success": False, "error": "Tipo n√£o especificado na URL"},
                    status=400,
                )
                return

            tipo = path_parts[-1]

            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            banco_acessorios = dados_data.get("banco_acessorios", {})

            if tipo in banco_acessorios:
                acessorio = banco_acessorios[tipo]

                # Adicionar estat√≠sticas
                valores = acessorio.get("valores_padrao", {})
                dimensoes = list(valores.keys())

                # Calcular pre√ßo m√©dio
                precos = list(valores.values())
                preco_medio = sum(precos) / len(precos) if precos else 0

                self.send_json_response(
                    {
                        "success": True,
                        "tipo": tipo,
                        "acessorio": acessorio,
                        "estatisticas": {
                            "quantidade_dimensoes": len(dimensoes),
                            "dimensoes": dimensoes[:10],  # Primeiras 10 dimens√µes
                            "preco_medio": round(preco_medio, 2),
                            "preco_min": min(precos) if precos else 0,
                            "preco_max": max(precos) if precos else 0,
                        },
                    }
                )
            else:
                self.send_json_response(
                    {
                        "success": False,
                        "error": f"Tipo de acessorio '{tipo}' n√£o encontrado",
                    },
                    status=404,
                )

        except Exception as e:
            print(f"‚ùå Erro em handle_get_acessorio_by_type: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_add_acessorio(self):
        """POST /api/acessorios/add - Adiciona novo acessorio"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            # Validar dados
            required_fields = ["tipo", "descricao", "valores"]
            for field in required_fields:
                if field not in data:
                    self.send_json_response(
                        {
                            "success": False,
                            "error": f"Campo obrigat√≥rio faltando: {field}",
                        },
                        status=400,
                    )
                    return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Garantir que existe a se√ß√£o banco_acessorios
            if "banco_acessorios" not in dados_data:
                dados_data["banco_acessorios"] = {}

            banco_acessorios = dados_data["banco_acessorios"]

            # Verificar se tipo j√° existe
            if tipo in banco_acessorios:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' j√° existe"}, status=400
                )
                return

            # Adicionar novo acessorio
            novo_acessorio = {
                "descricao": data["descricao"],
                "valores_padrao": data["valores"],
            }

            # Adicionar dimens√µes se fornecidas
            if "dimensoes" in data:
                novo_acessorio["dimensoes"] = data["dimensoes"]

            # Adicionar unidade se fornecida
            if "unidade_valor" in data:
                novo_acessorio["unidade_valor"] = data["unidade_valor"]

            banco_acessorios[tipo] = novo_acessorio

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Acessorio '{tipo}' adicionado com sucesso",
                    "acessorio": novo_acessorio,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"}, status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_add_acessorio: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_update_acessorio(self):
        """POST /api/acessorios/update - Atualiza acessorio existente"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            # Validar dados
            if "tipo" not in data:
                self.send_json_response(
                    {"success": False, "error": "Campo 'tipo' √© obrigat√≥rio"},
                    status=400,
                )
                return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a se√ß√£o banco_acessorios
            if "banco_acessorios" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Se√ß√£o 'banco_acessorios' n√£o encontrada",
                    },
                    status=404,
                )
                return

            banco_acessorios = dados_data["banco_acessorios"]

            # Verificar se tipo existe
            if tipo not in banco_acessorios:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' n√£o encontrado"},
                    status=404,
                )
                return

            # Atualizar campos
            acessorio_atual = banco_acessorios[tipo]

            if "descricao" in data:
                acessorio_atual["descricao"] = data["descricao"]

            if "valores" in data:
                acessorio_atual["valores_padrao"] = data["valores"]

            if "dimensoes" in data:
                acessorio_atual["dimensoes"] = data["dimensoes"]

            if "unidade_valor" in data:
                acessorio_atual["unidade_valor"] = data["unidade_valor"]

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Acessorio '{tipo}' atualizado com sucesso",
                    "acessorio": acessorio_atual,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"}, status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_update_acessorio: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_delete_acessorio(self):
        """POST /api/acessorios/delete - Remove acessorio"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            if "tipo" not in data:
                self.send_json_response(
                    {"success": False, "error": "Campo 'tipo' √© obrigat√≥rio"},
                    status=400,
                )
                return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a se√ß√£o banco_acessorios
            if "banco_acessorios" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Se√ß√£o 'banco_acessorios' n√£o encontrada",
                    },
                    status=404,
                )
                return

            banco_acessorios = dados_data["banco_acessorios"]

            # Verificar se tipo existe
            if tipo not in banco_acessorios:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' n√£o encontrado"},
                    status=404,
                )
                return

            # Remover acessorio
            acessorio_removido = banco_acessorios.pop(tipo)

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Acessorio '{tipo}' removido com sucesso",
                    "acessorio_removido": acessorio_removido,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"}, status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_delete_acessorio: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_search_acessorios(self):
        """GET /api/acessorios/search?q=termo - Busca acessorios"""
        try:
            # Extrair par√¢metro de busca da query string
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            termo = query_params.get("q", [""])[0].lower()

            if not termo:
                self.send_json_response(
                    {"success": False, "error": "Termo de busca n√£o fornecido"},
                    status=400,
                )
                return

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a se√ß√£o banco_acessorios
            if "banco_acessorios" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Se√ß√£o 'banco_acessorios' n√£o encontrada",
                    },
                    status=404,
                )
                return

            banco_acessorios = dados_data["banco_acessorios"]

            resultados = []
            for tipo, dados in banco_acessorios.items():
                # Buscar no tipo
                if termo in tipo.lower():
                    resultados.append(
                        {
                            "tipo": tipo,
                            "descricao": dados.get("descricao", ""),
                            "match": "tipo",
                            "valores_count": len(dados.get("valores_padrao", {})),
                        }
                    )
                    continue

                # Buscar na descri√ß√£o
                descricao = dados.get("descricao", "").lower()
                if termo in descricao:
                    resultados.append(
                        {
                            "tipo": tipo,
                            "descricao": dados.get("descricao", ""),
                            "match": "descricao",
                            "valores_count": len(dados.get("valores_padrao", {})),
                        }
                    )
                    continue

                # Buscar nas dimens√µes/valores
                valores = dados.get("valores_padrao", {})
                for dimensao, valor in valores.items():
                    if termo in dimensao.lower():
                        resultados.append(
                            {
                                "tipo": tipo,
                                "descricao": dados.get("descricao", ""),
                                "dimensao_encontrada": dimensao,
                                "valor": valor,
                                "match": "dimensao",
                                "valores_count": len(valores),
                            }
                        )
                        break

            self.send_json_response(
                {
                    "success": True,
                    "termo": termo,
                    "resultados": resultados,
                    "count": len(resultados),
                }
            )

        except Exception as e:
            print(f"‚ùå Erro em handle_get_search_acessorios: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_acessorio_dimensoes(self):
        """GET /api/acessorios/dimensoes - Retorna dimens√µes dispon√≠veis"""
        try:
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a se√ß√£o banco_acessorios
            if "banco_acessorios" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Se√ß√£o 'banco_acessorios' n√£o encontrada",
                    },
                    status=404,
                )
                return

            banco_acessorios = dados_data["banco_acessorios"]

            # Coletar todas as dimens√µes √∫nicas
            todas_dimensoes = set()
            dimensoes_por_tipo = {}

            for tipo, dados in banco_acessorios.items():
                valores = dados.get("valores_padrao", {})
                dimensoes = list(valores.keys())

                dimensoes_por_tipo[tipo] = {
                    "descricao": dados.get("descricao", ""),
                    "dimensoes": dimensoes,
                    "quantidade": len(dimensoes),
                }

                # Adicionar dimens√µes ao conjunto geral
                todas_dimensoes.update(dimensoes)

            self.send_json_response(
                {
                    "success": True,
                    "dimensoes_por_tipo": dimensoes_por_tipo,
                    "todas_dimensoes": sorted(list(todas_dimensoes)),
                    "total_dimensoes": len(todas_dimensoes),
                }
            )

        except Exception as e:
            print(f"‚ùå Erro em handle_get_acessorio_dimensoes: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )
                     
    def handle_get_dutos(self):
        """GET /api/dutos - Retorna todos os dutos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verifica se existe a se√ß√£o dutos
            dutos = dados_data.get("dutos", [])
            
            self.send_json_response({
                "success": True,
                "dutos": dutos,
                "count": len(dutos)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_dutos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_types(self):
        """GET /api/dutos/types - Retorna tipos de dutos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            # Retornar array de objetos com informa√ß√µes completas
            types = []
            for duto in dutos:
                tipo = duto.get("type", "")
                if tipo:
                    types.append({
                        "value": tipo,
                        "label": tipo,
                        "descricao": duto.get("descricao", ""),
                        "valor_base": duto.get("valor", 0)
                    })
            
            # Ordenar tipos
            types.sort(key=lambda x: x["label"])
            
            self.send_json_response({
                "success": True,
                "types": types,  # Agora √© array de objetos
                "count": len(types)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_duto_types: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_opcionais(self):
        """GET /api/dutos/opcionais - Retorna opcionais dispon√≠veis"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            opcionais_por_tipo = {}
            todos_opcionais = []
            todos_opcionais_dict = {}
            
            for duto in dutos:
                tipo = duto.get("type", "")
                opcionais = duto.get("opcionais", [])
                
                if not isinstance(opcionais, list):
                    opcionais = []
                
                opcionais_formatados = []
                for opcional in opcionais:
                    opcional_info = {
                        "id": opcional.get("id"),
                        "nome": opcional.get("nome", ""),
                        "value": opcional.get("value", 0),
                        "descricao": opcional.get("descricao", ""),
                        "tipo_duto": tipo
                    }
                    opcionais_formatados.append(opcional_info)
                    
                    # Adicionar √† lista geral de opcionais
                    if opcional.get("nome") and opcional.get("nome") not in todos_opcionais_dict:
                        todos_opcionais_dict[opcional.get("nome")] = True
                        todos_opcionais.append({
                            "nome": opcional.get("nome", ""),
                            "valor_medio": opcional.get("value", 0),
                            "descricao": opcional.get("descricao", "")
                        })
                
                opcionais_por_tipo[tipo] = {
                    "valor_base": duto.get("valor", 0),
                    "opcionais": opcionais_formatados,
                    "quantidade_opcionais": len(opcionais_formatados)
                }
            
            self.send_json_response({
                "success": True,
                "opcionais_por_tipo": opcionais_por_tipo,
                "todos_opcionais": todos_opcionais,
                "total_opcionais": len(todos_opcionais)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_duto_opcionais: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_by_type(self):
        """GET /api/dutos/type/{type} - Retorna duto por tipo"""
        try:
            # Extrair tipo da URL
            path_parts = self.path.split("/")
            if len(path_parts) < 5:
                self.send_json_response(
                    {"success": False, "error": "Tipo n√£o especificado na URL"},
                    status=400
                )
                return
                
            tipo = path_parts[-1]
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            
            for duto in dutos:
                if duto.get("type") == tipo:
                    # Garantir que opcionais √© um array
                    opcionais = duto.get("opcionais", [])
                    if not isinstance(opcionais, list):
                        opcionais = []
                    
                    # Calcular valor m√°ximo (com todos os opcionais)
                    valor_base = duto.get("valor", 0)
                    valor_maximo = valor_base
                    for opcional in opcionais:
                        valor_maximo += opcional.get("value", 0)
                    
                    # Retornar estrutura completa que o frontend espera
                    response = {
                        "success": True,
                        "tipo": tipo,
                        "duto": {
                            "type": duto.get("type", ""),
                            "valor": valor_base,
                            "descricao": duto.get("descricao", ""),
                            "categoria": duto.get("categoria", ""),
                            "unidade": duto.get("unidade", "m¬≤"),
                            "opcionais": opcionais
                        },
                        "estatisticas": {
                            "valor_base": valor_base,
                            "valor_maximo": valor_maximo,
                            "quantidade_opcionais": len(opcionais),
                            "opcionais_disponiveis": [op.get("nome", "") for op in opcionais]
                        }
                    }
                    
                    print(f"‚úÖ Retornando duto '{tipo}': {len(opcionais)} opcionais")
                    self.send_json_response(response)
                    return
            
            self.send_json_response({
                "success": False,
                "error": f"Tipo de duto '{tipo}' n√£o encontrado"
            }, status=404)
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_duto_by_type: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_search_dutos(self):
        """GET /api/dutos/search?q=termo - Busca dutos"""
        try:
            from urllib.parse import parse_qs
            
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            termo = query_params.get("q", [""])[0].lower()
            
            if not termo:
                self.send_json_response(
                    {"success": False, "error": "Termo de busca n√£o fornecido"},
                    status=400
                )
                return
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            resultados = []
            
            for duto in dutos:
                tipo = duto.get("type", "").lower()
                
                # Buscar no tipo
                if termo in tipo:
                    resultados.append({
                        "tipo": duto.get("type", ""),
                        "valor_base": duto.get("valor", 0),
                        "match": "tipo",
                        "opcionais_count": len(duto.get("opcionais", []))
                    })
                    continue
                
                # Buscar nos opcionais
                opcionais = duto.get("opcionais", [])
                for opcional in opcionais:
                    nome_opcional = opcional.get("nome", "").lower()
                    if termo in nome_opcional:
                        resultados.append({
                            "tipo": duto.get("type", ""),
                            "valor_base": duto.get("valor", 0),
                            "opcional_encontrado": opcional.get("nome", ""),
                            "valor_opcional": opcional.get("value", 0),
                            "match": "opcional",
                            "opcionais_count": len(opcionais)
                        })
                        break
            
            self.send_json_response({
                "success": True,
                "termo": termo,
                "resultados": resultados,
                "count": len(resultados)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_search_dutos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_add_duto(self):
        """POST /api/dutos/add - Adiciona novo duto"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            required_fields = ["type", "valor"]
            for field in required_fields:
                if field not in data:
                    self.send_json_response({
                        "success": False,
                        "error": f"Campo obrigat√≥rio faltando: {field}"
                    }, status=400)
                    return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Garantir que existe a se√ß√£o dutos
            if "dutos" not in dados_data:
                dados_data["dutos"] = []
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo j√° existe
            for duto in dutos:
                if duto.get("type") == tipo:
                    self.send_json_response({
                        "success": False,
                        "error": f"Tipo '{tipo}' j√° existe"
                    }, status=400)
                    return
            
            # Adicionar novo duto
            novo_duto = {
                "type": data["type"],
                "valor": data["valor"]
            }
            
            # Adicionar opcionais se fornecidos
            if "opcionais" in data:
                novo_duto["opcionais"] = data["opcionais"]
            else:
                novo_duto["opcionais"] = []
            
            # Adicionar descri√ß√£o se fornecida
            if "descricao" in data:
                novo_duto["descricao"] = data["descricao"]
            
            dutos.append(novo_duto)
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' adicionado com sucesso",
                "duto": novo_duto
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_add_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_update_duto(self):
        """POST /api/dutos/update - Atualiza duto existente"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            if "type" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'type' √© obrigat√≥rio"
                }, status=400)
                return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a se√ß√£o dutos
            if "dutos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "Se√ß√£o 'dutos' n√£o encontrada"
                }, status=404)
                return
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo existe
            duto_encontrado = None
            duto_index = -1
            
            for i, duto in enumerate(dutos):
                if duto.get("type") == tipo:
                    duto_encontrado = duto
                    duto_index = i
                    break
            
            if duto_index == -1:
                self.send_json_response({
                    "success": False,
                    "error": f"Tipo '{tipo}' n√£o encontrado"
                }, status=404)
                return
            
            # Atualizar campos
            if "valor" in data:
                dutos[duto_index]["valor"] = data["valor"]
            
            if "opcionais" in data:
                dutos[duto_index]["opcionais"] = data["opcionais"]
            
            if "descricao" in data:
                dutos[duto_index]["descricao"] = data["descricao"]
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' atualizado com sucesso",
                "duto": dutos[duto_index]
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_update_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_delete_duto(self):
        """POST /api/dutos/delete - Remove duto"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            if "type" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'type' √© obrigat√≥rio"
                }, status=400)
                return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a se√ß√£o dutos
            if "dutos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "Se√ß√£o 'dutos' n√£o encontrada"
                }, status=404)
                return
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo existe
            duto_removido = None
            novos_dutos = []
            
            for duto in dutos:
                if duto.get("type") == tipo:
                    duto_removido = duto
                else:
                    novos_dutos.append(duto)
            
            if duto_removido is None:
                self.send_json_response({
                    "success": False,
                    "error": f"Tipo '{tipo}' n√£o encontrado"
                }, status=404)
                return
            
            # Salvar dados atualizados
            dados_data["dutos"] = novos_dutos
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' removido com sucesso",
                "duto_removido": duto_removido
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_delete_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_tubos(self):
        """GET /api/tubos - Retorna todos os tubos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verifica se existe a se√ß√£o tubos
            tubos = dados_data.get("tubos", [])
            
            self.send_json_response({
                "success": True,
                "tubos": tubos,
                "count": len(tubos)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_tubos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_tubo_polegadas(self):
        """GET /api/tubos/polegadas - Retorna todas as polegadas dispon√≠veis"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            tubos = dados_data.get("tubos", [])
            polegadas_lista = []
            
            for tubo in tubos:
                polegadas = tubo.get("polegadas", "")
                if polegadas:
                    polegadas_lista.append({
                        "value": polegadas,
                        "label": f"{polegadas}''",
                        "mm": tubo.get("mm", 0),
                        "valor": tubo.get("valor", 0)
                    })
            
            # Ordenar por tamanho (convertendo polegadas para valor num√©rico)
            def polegadas_para_numero(polegadas_str):
                try:
                    if '/' in polegadas_str:
                        # Converte fra√ß√µes como "1 1/4" ou "1/2"
                        if ' ' in polegadas_str:
                            inteiro, frac = polegadas_str.split(' ')
                            num, den = frac.split('/')
                            return float(inteiro) + float(num) / float(den)
                        else:
                            num, den = polegadas_str.split('/')
                            return float(num) / float(den)
                    else:
                        return float(polegadas_str)
                except:
                    return 0
            
            polegadas_lista.sort(key=lambda x: polegadas_para_numero(x["value"]))
            
            self.send_json_response({
                "success": True,
                "polegadas": polegadas_lista,
                "count": len(polegadas_lista)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_tubo_polegadas: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_tubo_por_polegada(self):
        """GET /api/tubos/polegada/{polegada} - Retorna tubo por polegada"""
        try:
            # Extrair polegada da URL
            path_parts = self.path.split("/")
            if len(path_parts) < 5:
                self.send_json_response(
                    {"success": False, "error": "Polegada n√£o especificada na URL"},
                    status=400
                )
                return
                
            polegada = path_parts[-1]
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            tubos = dados_data.get("tubos", [])
            
            for tubo in tubos:
                if tubo.get("polegadas") == polegada:
                    self.send_json_response({
                        "success": True,
                        "polegada": polegada,
                        "tubo": tubo
                    })
                    return
            
            self.send_json_response({
                "success": False,
                "error": f"Tubo de {polegada}'' n√£o encontrado"
            }, status=404)
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_tubo_por_polegada: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_add_tubo(self):
        """POST /api/tubos/add - Adiciona novo tubo"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            required_fields = ["polegadas", "mm", "valor"]
            for field in required_fields:
                if field not in data:
                    self.send_json_response({
                        "success": False,
                        "error": f"Campo obrigat√≥rio faltando: {field}"
                    }, status=400)
                    return
            
            polegadas = data["polegadas"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Garantir que existe a se√ß√£o tubos
            if "tubos" not in dados_data:
                dados_data["tubos"] = []
            
            tubos = dados_data["tubos"]
            
            # Verificar se polegada j√° existe
            for tubo in tubos:
                if tubo.get("polegadas") == polegadas:
                    self.send_json_response({
                        "success": False,
                        "error": f"Tubo de {polegadas}'' j√° existe"
                    }, status=400)
                    return
            
            # Adicionar novo tubo
            novo_tubo = {
                "polegadas": data["polegadas"],
                "mm": data["mm"],
                "valor": data["valor"]
            }
            
            # Adicionar descri√ß√£o se fornecida
            if "descricao" in data:
                novo_tubo["descricao"] = data["descricao"]
            
            tubos.append(novo_tubo)
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Tubo de {polegadas}'' adicionado com sucesso",
                "tubo": novo_tubo
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_add_tubo: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_update_tubo(self):
        """POST /api/tubos/update - Atualiza tubo existente"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            if "polegadas" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'polegadas' √© obrigat√≥rio"
                }, status=400)
                return
            
            polegadas = data["polegadas"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a se√ß√£o tubos
            if "tubos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "Se√ß√£o 'tubos' n√£o encontrada"
                }, status=404)
                return
            
            tubos = dados_data["tubos"]
            
            # Verificar se polegada existe
            tubo_index = -1
            for i, tubo in enumerate(tubos):
                if tubo.get("polegadas") == polegadas:
                    tubo_index = i
                    break
            
            if tubo_index == -1:
                self.send_json_response({
                    "success": False,
                    "error": f"Tubo de {polegadas}'' n√£o encontrado"
                }, status=404)
                return
            
            # Atualizar campos
            if "mm" in data:
                tubos[tubo_index]["mm"] = data["mm"]
            
            if "valor" in data:
                tubos[tubo_index]["valor"] = data["valor"]
            
            if "descricao" in data:
                tubos[tubo_index]["descricao"] = data["descricao"]
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Tubo de {polegadas}'' atualizado com sucesso",
                "tubo": tubos[tubo_index]
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_update_tubo: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_delete_tubo(self):
        """POST /api/tubos/delete - Remove tubo"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            if "polegadas" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'polegadas' √© obrigat√≥rio"
                }, status=400)
                return
            
            polegadas = data["polegadas"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a se√ß√£o tubos
            if "tubos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "Se√ß√£o 'tubos' n√£o encontrada"
                }, status=404)
                return
            
            tubos = dados_data["tubos"]
            
            # Verificar se polegada existe
            tubo_removido = None
            novos_tubos = []
            
            for tubo in tubos:
                if tubo.get("polegadas") == polegadas:
                    tubo_removido = tubo
                else:
                    novos_tubos.append(tubo)
            
            if tubo_removido is None:
                self.send_json_response({
                    "success": False,
                    "error": f"Tubo de {polegadas}'' n√£o encontrado"
                }, status=404)
                return
            
            # Salvar dados atualizados
            dados_data["tubos"] = novos_tubos
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Tubo de {polegadas}'' removido com sucesso",
                "tubo_removido": tubo_removido
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON inv√°lido"},
                status=400
            )
        except Exception as e:
            print(f"‚ùå Erro em handle_post_delete_tubo: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_search_tubos(self):
        """GET /api/tubos/search?q=termo - Busca tubos por termo"""
        try:
            from urllib.parse import parse_qs
            
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            termo = query_params.get("q", [""])[0].lower()
            
            if not termo:
                self.send_json_response(
                    {"success": False, "error": "Termo de busca n√£o fornecido"},
                    status=400
                )
                return
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json n√£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            tubos = dados_data.get("tubos", [])
            resultados = []
            
            for tubo in tubos:
                polegadas = tubo.get("polegadas", "").lower()
                mm = str(tubo.get("mm", "")).lower()
                valor = str(tubo.get("valor", "")).lower()
                
                # Buscar na polegada
                if termo in polegadas:
                    resultados.append({
                        "polegadas": tubo.get("polegadas", ""),
                        "mm": tubo.get("mm", 0),
                        "valor": tubo.get("valor", 0),
                        "match": "polegadas"
                    })
                    continue
                
                # Buscar no mm
                if termo in mm:
                    resultados.append({
                        "polegadas": tubo.get("polegadas", ""),
                        "mm": tubo.get("mm", 0),
                        "valor": tubo.get("valor", 0),
                        "match": "mm"
                    })
                    continue
                
                # Buscar no valor
                if termo in valor:
                    resultados.append({
                        "polegadas": tubo.get("polegadas", ""),
                        "mm": tubo.get("mm", 0),
                        "valor": tubo.get("valor", 0),
                        "match": "valor"
                    })
                    continue
            
            self.send_json_response({
                "success": True,
                "termo": termo,
                "resultados": resultados,
                "count": len(resultados)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_search_tubos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )
            
            
            

    def handle_get_word_models(self):
        """GET /api/word/models - Retorna modelos de Word dispon√≠veis"""
        try:
            from servidor_modules.handlers.word_handler import WordHandler
            word_handler = WordHandler(self.project_root, self.file_utils)
            
            models = [
                {
                    "id": "pc",
                    "name": "Proposta Comercial",
                    "description": "Documento comercial com valores e condi√ß√µes",
                    "icon": "üìã"
                },
                {
                    "id": "pt", 
                    "name": "Proposta T√©cnica",
                    "description": "Documento t√©cnico com especifica√ß√µes",
                    "icon": "üîß"
                },
                {
                    "id": "ambos",
                    "name": "Ambos Documentos",
                    "description": "Proposta Comercial e T√©cnica juntos",
                    "icon": "üìÑ"
                }
            ]
            
            self.send_json_response({
                "success": True,
                "models": models,
                "templates_available": len(word_handler.get_available_templates()) > 0
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_word_models: {e}")
            self.send_json_response({
                "success": False,
                "error": str(e)
            }, status=500)

    def handle_get_word_templates(self):
        """GET /api/word/templates - Retorna templates dispon√≠veis"""
        try:
            from servidor_modules.handlers.word_handler import WordHandler
            word_handler = WordHandler(self.project_root, self.file_utils)
            
            templates = word_handler.get_available_templates()
            
            self.send_json_response({
                "success": True,
                "templates": templates,
                "templates_dir": str(word_handler.templates_dir)
            })
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_word_templates: {e}")
            self.send_json_response({
                "success": False,
                "error": str(e)
            }, status=500)

    def handle_generate_word_proposta_comercial(self):
        """POST /api/word/generate/proposta-comercial"""
        self.handle_generate_word("comercial")

    def handle_generate_word_proposta_tecnica(self):
        """POST /api/word/generate/proposta-tecnica"""
        self.handle_generate_word("tecnica")

    def handle_generate_word_ambos(self):
        """POST /api/word/generate/ambos"""
        self.handle_generate_word("ambos")

    def handle_generate_word(self, template_type):
        """Handler gen√©rico para gera√ß√£o de Word"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            obra_id = data.get("obra_id")
            if not obra_id:
                self.send_json_response({
                    "success": False,
                    "error": "ID da obra n√£o fornecido"
                }, status=400)
                return
            
            from servidor_modules.handlers.word_handler import WordHandler
            word_handler = WordHandler(self.project_root, self.file_utils)
            
            if template_type == "ambos":
                file_path, error = word_handler.generate_both_documents(obra_id)
            else:
                file_path, error = word_handler.generate_word_document(obra_id, template_type)
            
            if error:
                self.send_json_response({
                    "success": False,
                    "error": error
                }, status=500)
                return
            
            # Criar nome de arquivo amig√°vel
            obra_data = word_handler.get_obra_data(obra_id)
            obra_nome = obra_data.get("nome", "obra") if obra_data else obra_id
            safe_name = "".join(c for c in obra_nome if c.isalnum() or c in (' ', '-', '_')).rstrip()
            
            filename = f"Proposta_{template_type.capitalize()}_{safe_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.docx"
            
            # Salvar informa√ß√µes do arquivo gerado para download posterior
            download_info = {
                "file_path": file_path,
                "filename": filename,
                "obra_id": obra_id,
                "obra_nome": obra_nome,
                "template_type": template_type,
                "generated_at": datetime.now().isoformat(),
                "size": os.path.getsize(file_path) if os.path.exists(file_path) else 0
            }
            
            # Salvar em arquivo tempor√°rio de sess√£o
            import tempfile
            download_id = f"word_{int(datetime.now().timestamp())}_{obra_id}"
            temp_info_file = tempfile.gettempdir() + f"/{download_id}.json"
            
            with open(temp_info_file, "w", encoding="utf-8") as f:
                json.dump(download_info, f)
            
            self.send_json_response({
                "success": True,
                "download_id": download_id,
                "filename": filename,
                "obra_nome": obra_nome,
                "template_type": template_type,
                "size": download_info["size"],
                "message": "Documento gerado com sucesso!"
            })
            
        except json.JSONDecodeError:
            self.send_json_response({
                "success": False,
                "error": "JSON inv√°lido"
            }, status=400)
        except Exception as e:
            print(f"‚ùå Erro em handle_generate_word: {e}")
            self.send_json_response({
                "success": False,
                "error": f"Erro interno: {str(e)}"
            }, status=500)

    def handle_download_word(self):
        """GET /api/word/download?id={download_id} - Faz download do arquivo gerado"""
        try:
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            download_id = query_params.get("id", [""])[0]
            
            if not download_id:
                self.send_json_response({
                    "success": False,
                    "error": "ID de download n√£o fornecido"
                }, status=400)
                return
            
            # Buscar informa√ß√µes do arquivo
            import tempfile
            temp_info_file = tempfile.gettempdir() + f"/{download_id}.json"
            
            if not os.path.exists(temp_info_file):
                self.send_json_response({
                    "success": False,
                    "error": "Arquivo n√£o encontrado ou expirado"
                }, status=404)
                return
            
            with open(temp_info_file, "r", encoding="utf-8") as f:
                download_info = json.load(f)
            
            file_path = download_info.get("file_path")
            filename = download_info.get("filename", "documento.docx")
            
            if not file_path or not os.path.exists(file_path):
                self.send_json_response({
                    "success": False,
                    "error": "Arquivo Word n√£o encontrado"
                }, status=404)
                return
            
            # Enviar arquivo
            with open(file_path, "rb") as f:
                file_data = f.read()
            
            self.send_response(200)
            self.send_header("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
            self.send_header("Content-Disposition", f'attachment; filename="{filename}"')
            self.send_header("Content-Length", str(len(file_data)))
            self.end_headers()
            self.wfile.write(file_data)
            
            # Limpar arquivos tempor√°rios ap√≥s envio
            try:
                os.unlink(file_path)
                os.unlink(temp_info_file)
            except:
                pass
                
        except Exception as e:
            print(f"‚ùå Erro em handle_download_word: {e}")
            self.send_json_response({
                "success": False,
                "error": str(e)
            }, status=500)
            
        
/* ==== FIM: handlers/http_handler.py ==== */

/* ==== IN√çCIO: handlers/route_handler.py ==== */
"""
route_handler.py
Handler principal de rotas - Interface entre HTTP e Core
"""

import json
from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import os
import time

class RouteHandler:
    """Manipula o roteamento de requisi√ß√µes HTTP"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        
        # RoutesCore ser√° injetado depois para evitar import circular
        self.routes_core = None
    
    def set_routes_core(self, routes_core):
        """Define o RoutesCore ap√≥s a inicializa√ß√£o para evitar import circular"""
        self.routes_core = routes_core

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self, handler):
        """GET /obras"""
        obras = self.routes_core.handle_get_obras()
        handler.send_json_response(obras)

    def handle_get_obra_by_id(self, handler, obra_id):
        """GET /obras/{id}"""
        obra = self.routes_core.handle_get_obra_by_id(obra_id)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_post_obras(self, handler):
        """POST /obras"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_post_obras(post_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(500, "Erro ao salvar obra")

    def handle_put_obra(self, handler):
        """PUT /obras/{id}"""
        obra_id = handler.path.split('/')[-1]
        content_length = int(handler.headers['Content-Length'])
        put_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_put_obra(obra_id, put_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_delete_obra(self, handler, obra_id):
        """DELETE /obras/{id}"""
        success = self.routes_core.handle_delete_obra(obra_id)
        if success:
            handler.send_json_response({
                "success": True,
                "message": f"Obra {obra_id} deletada com sucesso"
            })
        else:
            handler.send_error(500, "Erro ao deletar obra")

    # ========== ROTAS DE EMPRESAS ==========

    def handle_get_empresas(self, handler):
        """GET /api/dados/empresas"""
        empresas = self.routes_core.handle_get_empresas()
        handler.send_json_response(empresas)
        
    def handle_get_proximo_numero(self, handler, sigla):
        """GET /api/dados/empresas/numero/{sigla}"""
        numero = self.routes_core.handle_get_proximo_numero(sigla)
        handler.send_json_response(numero)

    def handle_post_empresas(self, handler):
        """POST /api/dados/empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas(post_data)
        handler.send_json_response(result)

    def handle_buscar_empresas(self, handler, termo):
        """GET /api/dados/empresas/buscar/{termo}"""
        result = self.routes_core.handle_buscar_empresas(termo)
        handler.send_json_response(result)

    # ========== ROTAS DE SESS√ÉO ==========

    def handle_get_sessions_current(self, handler):
        """GET /api/sessions/current"""
        session_data = self.routes_core.handle_get_sessions_current()
        handler.send_json_response(session_data)

    def handle_post_sessions_add_obra(self, handler):
        """POST /api/sessions/add-obra"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_sessions_add_obra(post_data)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_delete_sessions_remove_obra(self, handler, obra_id):
        """DELETE /api/sessions/remove-obra/{id}"""
        result = self.routes_core.handle_delete_sessions_remove_obra(obra_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_get_session_obras(self, handler):
        """GET /api/session-obras"""
        result = self.routes_core.handle_get_session_obras()
        handler.send_json_response(result)

    def handle_post_sessions_shutdown(self, handler):
        """POST /api/sessions/shutdown"""
        result = self.routes_core.handle_post_sessions_shutdown()
        handler.send_json_response(result)

    def handle_shutdown(self, handler):
        """POST /api/shutdown"""
        response = self.routes_core.handle_shutdown()
        handler.send_json_response(response)

    def handle_post_sessions_ensure_single(self, handler):
        """POST /api/sessions/ensure-single"""
        result = self.routes_core.handle_post_sessions_ensure_single()
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    # ========== ROTAS DE SISTEMA ==========

    def handle_get_server_uptime(self, handler):
        """GET /api/server/uptime"""
        result = self.routes_core.handle_get_server_uptime()
        handler.send_json_response(result)

    def handle_get_constants(self, handler):
        """GET /constants"""
        constants = self.routes_core.handle_get_constants()
        handler.send_json_response(constants)

    def handle_get_machines(self, handler):
        """GET /machines"""
        machines = self.routes_core.handle_get_machines()
        handler.send_json_response(machines)

    def handle_get_dados(self, handler):
        """GET /dados"""
        dados = self.routes_core.handle_get_dados()
        handler.send_json_response(dados)

    def handle_get_backup(self, handler):
        """GET /backup"""
        backup = self.routes_core.handle_get_backup()
        handler.send_json_response(backup)

    def handle_get_backup_completo(self, handler):
        """GET /api/backup-completo"""
        backup = self.routes_core.handle_get_backup_completo()
        handler.send_json_response(backup)

    def handle_post_dados(self, handler):
        """POST /dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_dados(post_data)
        handler.send_json_response(result)

    def handle_post_backup(self, handler):
        """POST /backup"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_backup(post_data)
        handler.send_json_response(result)

    def handle_post_reload_page(self, handler):
        """POST /api/reload-page"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_reload_page(post_data)
        handler.send_json_response(result)

    # ========== ROTAS DE COMPATIBILIDADE ==========

    def handle_get_projetos(self, handler):
        """GET /projetos (legacy)"""
        projetos = self.routes_core.handle_get_projetos()
        handler.send_json_response(projetos)

    def handle_post_projetos(self, handler):
        """POST /projetos (legacy)"""
        handler.send_error(501, "Use o endpoint /obras em vez de /projetos")

    def handle_get_session_projects(self, handler):
        """GET /api/session-projects (legacy)"""
        handler.send_json_response([])

    def handle_delete_sessions_remove_project(self, handler, project_id):
        """DELETE /api/sessions/remove-project/{id} (legacy)"""
        result = self.routes_core.handle_delete_sessions_remove_project(project_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])
        
    def handle_post_empresas_auto(self, handler):
        """POST /api/dados/empresas/auto"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas_auto(post_data)
        handler.send_json_response(result)
        
    # ========== ROTA UNIVERSAL DELETE ==========
    
    def handle_delete_universal(self, handler):
        """DELETE /api/delete - Rota universal para deletar qualquer item"""
        result = self.routes_core.handle_delete_universal_from_handler(handler)
        handler.send_json_response(result)
        
    # ========== ROTAS PARA SISTEMA DE EDI√á√ÉO ==========

    def handle_get_system_data(self, handler):
        """GET /api/system-data - Retorna TODOS os dados do sistema"""
        system_data = self.routes_core.handle_get_system_data()
        handler.send_json_response(system_data)

    def handle_get_constants_json(self, handler):
        """GET /api/constants - Retorna apenas as constantes"""
        constants = self.routes_core.handle_get_constants_json()
        handler.send_json_response(constants)

    def handle_get_materials(self, handler):
        """GET /api/materials - Retorna materiais"""
        materials = self.routes_core.handle_get_materials()
        handler.send_json_response(materials)

    def handle_get_all_empresas(self, handler):
        """GET /api/empresas/all - Retorna todas empresas formatadas"""
        empresas = self.routes_core.handle_get_all_empresas()
        handler.send_json_response(empresas)

    def handle_get_machine_types(self, handler):
        """GET /api/machines/types - Retorna tipos de m√°quinas"""
        machine_types = self.routes_core.handle_get_machine_types()
        handler.send_json_response(machine_types)

    def handle_get_machine_by_type(self, handler, machine_type):
        """GET /api/machines/type/{type} - Retorna m√°quina espec√≠fica"""
        machine = self.routes_core.handle_get_machine_by_type(machine_type)
        if machine:
            handler.send_json_response(machine)
        else:
            handler.send_error(404, f"M√°quina tipo {machine_type} n√£o encontrada")

    def handle_post_save_system_data(self, handler):
        """POST /api/system-data/save - Salva todos os dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_system_data(post_data)
        handler.send_json_response(result)

    def handle_post_save_constants(self, handler):
        """POST /api/constants/save - Salva constantes"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_constants(post_data)
        handler.send_json_response(result)

    def handle_post_save_materials(self, handler):
        """POST /api/materials/save - Salva materiais"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_materials(post_data)
        handler.send_json_response(result)

    def handle_post_save_empresas(self, handler):
        """POST /api/empresas/save - Salva empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_empresas(post_data)
        handler.send_json_response(result)

    def handle_post_save_machines(self, handler):
        """POST /api/machines/save - Salva m√°quinas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_machines(post_data)
        handler.send_json_response(result)

    def handle_post_add_machine(self, handler):
        """POST /api/machines/add - Adiciona nova m√°quina"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_add_machine(post_data)
        handler.send_json_response(result)

    def handle_post_update_machine(self, handler):
        """POST /api/machines/update - Atualiza m√°quina existente"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_update_machine(post_data)
        handler.send_json_response(result)

    # NOVO M√âTODO ADICIONADO
    def handle_post_delete_machine(self, handler):
        """POST /api/machines/delete - Deleta uma m√°quina"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_delete_machine(post_data)
        handler.send_json_response(result)

    # ========== ROTAS EXISTENTES QUE PODEM FALTAR ==========

    def handle_health_check(self, handler):
        """GET /health-check"""
        handler.send_json_response({"status": "online", "timestamp": time.time()})
        
    def handle_delete_empresa(self, handler, index):
        """DELETE /api/empresas/{index}"""
        result = self.routes_core.handle_delete_empresa(index)
        handler.send_json_response(result)
        

    def handle_post_system_apply_json(self, handler):
        """POST /api/system/apply-json"""
        # Delegar para o handler HTTP
        handler.handle_post_system_apply_json()

    # ========== ROTAS PARA EQUIPAMENTOS ==========

    def handle_get_acessorios(self, handler):
        """GET /api/acessorios"""
        handler.handle_get_acessorios()

    def handle_get_acessorio_types(self, handler):
        """GET /api/acessorios/types"""
        handler.handle_get_acessorio_types()

    def handle_get_acessorio_dimensoes(self, handler):
        """GET /api/acessorios/dimensoes"""
        handler.handle_get_acessorio_dimensoes()

    def handle_get_acessorio_by_type(self, handler):
        """GET /api/acessorios/type/{type}"""
        handler.handle_get_acessorio_by_type()

    def handle_get_search_acessorios(self, handler):
        """GET /api/acessorios/search"""
        handler.handle_get_search_acessorios()

    def handle_post_add_acessorio(self, handler):
        """POST /api/acessorios/add"""
        handler.handle_post_add_acessorio()

    def handle_post_update_acessorio(self, handler):
        """POST /api/acessorios/update"""
        handler.handle_post_update_acessorio()

    def handle_post_delete_acessorio(self, handler):
        """POST /api/acessorios/delete"""
        handler.handle_post_delete_acessorio()
        
    # ========== ROTAS PARA DUTOS ==========
            
    def handle_get_dutos(self, handler):
        """GET /api/dutos"""
        handler.handle_get_dutos()

    def handle_get_duto_types(self, handler):
        """GET /api/dutos/types"""
        handler.handle_get_duto_types()

    def handle_get_duto_opcionais(self, handler):
        """GET /api/dutos/opcionais"""
        handler.handle_get_duto_opcionais()

    def handle_get_duto_by_type(self, handler):
        """GET /api/dutos/type/{type}"""
        handler.handle_get_duto_by_type()

    def handle_get_search_dutos(self, handler):
        """GET /api/dutos/search"""
        handler.handle_get_search_dutos()

    def handle_post_add_duto(self, handler):
        """POST /api/dutos/add"""
        handler.handle_post_add_duto()

    def handle_post_update_duto(self, handler):
        """POST /api/dutos/update"""
        handler.handle_post_update_duto()

    def handle_post_delete_duto(self, handler):
        """POST /api/dutos/delete"""
        handler.handle_post_delete_duto()
        
    # ========== ROTAS PARA TUBOS ==========

    def handle_get_tubos(self, handler):
        """GET /api/tubos"""
        handler.handle_get_tubos()

    def handle_get_tubo_polegadas(self, handler):
        """GET /api/tubos/polegadas"""
        handler.handle_get_tubo_polegadas()

    def handle_get_tubo_por_polegada(self, handler):
        """GET /api/tubos/polegada/{polegada}"""
        handler.handle_get_tubo_por_polegada()

    def handle_get_search_tubos(self, handler):
        """GET /api/tubos/search"""
        handler.handle_get_search_tubos()

    def handle_post_add_tubo(self, handler):
        """POST /api/tubos/add"""
        handler.handle_post_add_tubo()

    def handle_post_update_tubo(self, handler):
        """POST /api/tubos/update"""
        handler.handle_post_update_tubo()

    def handle_post_delete_tubo(self, handler):
        """POST /api/tubos/delete"""
        handler.handle_post_delete_tubo()
        
    
    def handle_get_word_models(self, handler):
        """GET /api/word/models"""
        handler.handle_get_word_models()

    def handle_get_word_templates(self, handler):
        """GET /api/word/templates"""
        handler.handle_get_word_templates()

    def handle_generate_word_proposta_comercial(self, handler):
        """POST /api/word/generate/proposta-comercial"""
        handler.handle_generate_word_proposta_comercial()

    def handle_generate_word_proposta_tecnica(self, handler):
        """POST /api/word/generate/proposta-tecnica"""
        handler.handle_generate_word_proposta_tecnica()

    def handle_generate_word_ambos(self, handler):
        """POST /api/word/generate/ambos"""
        handler.handle_generate_word_ambos()

    def handle_download_word(self, handler):
        """GET /api/word/download"""
        handler.handle_download_word()
/* ==== FIM: handlers/route_handler.py ==== */

/* ==== IN√çCIO: core/routes_core.py ==== */
# servidor_modules/core/routes_core.py

"""
routes_core.py
N√∫cleo das rotas - Divis√£o l√≥gica das funcionalidades
"""

import json
import time
import threading
from pathlib import Path



class RoutesCore:
    """N√∫cleo das funcionalidades de rotas organizadas por categoria"""

    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner

        # Inicializa EmpresaHandler com file_utils injetado
        from servidor_modules.handlers.empresa_handler import EmpresaHandler

        self.empresa_handler = EmpresaHandler(file_utils=self.file_utils)

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self):
        """Obt√©m todas as obras da sess√£o atual"""
        try:
            print("üéØ [OBRAS] Obtendo obras da sess√£o")

            current_session_id = self.sessions_manager.get_current_session_id()
            session_data = self.sessions_manager._load_sessions_data()
            session_obra_ids = (
                session_data["sessions"].get(current_session_id, {}).get("obras", [])
            )

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return []

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_data = json.loads(f.read())

            obras = backup_data.get("obras", [])
            if not isinstance(obras, list):
                obras = []

            obras_da_sessao = []
            for obra in obras:
                if not isinstance(obra, dict):
                    continue

                obra_id = str(obra.get("id", ""))
                if obra_id in session_obra_ids:
                    obras_da_sessao.append(obra)

            print(f"üéØ ENVIANDO: {len(obras_da_sessao)} obras da sess√£o")
            return obras_da_sessao

        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obras: {str(e)}")
            return []

    def handle_get_obra_by_id(self, obra_id):
        """Obt√©m uma obra espec√≠fica por ID"""
        try:
            print(f"üéØ [OBRA POR ID] Buscando obra {obra_id}")

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return None

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_data = json.loads(f.read())

            obras = backup_data.get("obras", [])

            for obra in obras:
                if str(obra.get("id")) == obra_id:
                    print(f"‚úÖ Obra {obra_id} encontrada")
                    return obra

            print(f"‚ùå Obra {obra_id} n√£o encontrada")
            return None

        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obra_by_id: {str(e)}")
            return None

    def handle_post_obras(self, post_data):
        """Salva nova obra e adiciona √† sess√£o - COM VERIFICA√á√ÉO DE EMPRESA"""
        try:
            nova_obra = json.loads(post_data)

            # üÜï VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE SALVAR OBRA
            print("üîç [OBRA] Verificando se precisa criar empresa automaticamente...")
            nova_obra = self.empresa_handler.verificar_e_criar_empresa_automatica(
                nova_obra
            )

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(
                backup_file, {"obras": [], "projetos": []}
            )

            obra_id = nova_obra.get("id")

            if not obra_id or obra_id.isdigit():
                import random
                import string

                letters = "abcdefghjkmnpqrstwxyz"
                random_letter1 = random.choice(letters)
                random_letter2 = random.choice(letters)
                random_num = random.randint(10, 99)
                obra_id = f"obra_{random_letter1}{random_num}"

                print(f"üÜï Backend gerou ID seguro: {obra_id}")

            nova_obra["id"] = obra_id

            print(f"üìù Tentando adicionar obra {obra_id} √† sess√£o...")
            success = self.sessions_manager.add_obra_to_session(obra_id)

            if not success:
                print(f"‚ùå FALHA ao adicionar obra {obra_id} √† sess√£o")
                return None

            obras = backup_data.get("obras", [])
            obras.append(nova_obra)
            backup_data["obras"] = obras

            print(f"‚ûï ADICIONANDO nova obra ID: {obra_id}")

            if self.file_utils.save_json_file(backup_file, backup_data):
                print(f"‚úÖ Obra {obra_id} salva com sucesso")
                return nova_obra
            else:
                return None

        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra: {str(e)}")
            return None

    # NO routes_core.py, MODIFIQUE tamb√©m o m√©todo handle_put_obra:

    def handle_put_obra(self, obra_id, put_data):
        """Atualiza obra existente - COM VERIFICA√á√ÉO DE EMPRESA"""
        try:
            obra_atualizada = json.loads(put_data)

            # üÜï VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE ATUALIZAR OBRA
            print(
                "üîç [OBRA UPDATE] Verificando se precisa criar empresa automaticamente..."
            )
            obra_atualizada = self.empresa_handler.verificar_e_criar_empresa_automatica(
                obra_atualizada
            )

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(backup_file)

            if not backup_data:
                return None

            obras = backup_data.get("obras", [])
            obra_encontrada = False

            for i, obra in enumerate(obras):
                if str(obra.get("id")) == obra_id:
                    obras[i] = obra_atualizada
                    obra_encontrada = True
                    print(f"‚úèÔ∏è  ATUALIZANDO obra {obra_id}")
                    break

            if not obra_encontrada:
                return None

            backup_data["obras"] = obras

            if self.file_utils.save_json_file(backup_file, backup_data):
                return obra_atualizada
            else:
                return None

        except Exception as e:
            print(f"‚ùå Erro ao atualizar obra: {str(e)}")
            return None

    def handle_delete_obra(self, obra_id):
        """Deleta uma obra do servidor"""
        try:
            print(f"üóëÔ∏è  Deletando obra {obra_id} do servidor")

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": []})

            obras = backup_data.get("obras", [])
            obra_encontrada = False

            obras_atualizadas = []
            for obra in obras:
                if str(obra.get("id")) != obra_id:
                    obras_atualizadas.append(obra)
                else:
                    obra_encontrada = True
                    print(f"‚úÖ Obra {obra_id} encontrada para remo√ß√£o")

            if not obra_encontrada:
                return False

            backup_data["obras"] = obras_atualizadas

            if self.file_utils.save_json_file(backup_file, backup_data):
                self.sessions_manager.remove_obra(obra_id)
                return True
            else:
                return False

        except Exception as e:
            print(f"‚ùå Erro ao deletar obra: {str(e)}")
            return False

    # ========= Metodos para empresas ========
    def handle_get_empresas(self):
        """Obt√©m todas as empresas"""
        try:
            empresas = self.empresa_handler.obter_empresas()
            return {"success": True, "empresas": empresas}
        except Exception as e:
            print(f"‚ùå Erro ao obter empresas: {e}")
            return {"success": False, "error": str(e)}

    def handle_post_empresas(self, post_data):
        """Adiciona nova empresa"""
        try:
            empresa_data = json.loads(post_data)
            sucesso, mensagem = self.empresa_handler.adicionar_empresa(empresa_data)

            return {"success": sucesso, "message": mensagem}
        except Exception as e:
            print(f"‚ùå Erro ao adicionar empresa: {e}")
            return {"success": False, "error": str(e)}

    def handle_buscar_empresas(self, termo):
        """Busca empresas por termo"""
        try:
            from urllib.parse import unquote

            termo_decodificado = unquote(termo)
            resultados = self.empresa_handler.buscar_empresa_por_termo(
                termo_decodificado
            )

            return {"success": True, "resultados": resultados}
        except Exception as e:
            print(f"‚ùå Erro ao buscar empresas: {e}")
            return {"success": False, "error": str(e), "resultados": []}

    def handle_get_proximo_numero(self, sigla):
        """Obt√©m pr√≥ximo n√∫mero para sigla"""
        try:
            from urllib.parse import unquote

            sigla_decodificada = unquote(sigla)
            numero = self.empresa_handler.obter_proximo_numero_cliente(
                sigla_decodificada
            )

            return {"success": True, "numero": numero}
        except Exception as e:
            print(f"‚ùå Erro ao obter pr√≥ximo n√∫mero: {e}")
            return {"success": False, "error": str(e), "numero": 1}

    # ========== ROTAS DE SESS√ÉO ==========

    def handle_get_sessions_current(self):
        """Retorna a sess√£o atual"""
        try:
            data = self.sessions_manager._load_sessions_data()
            current_session_id = self.sessions_manager.get_current_session_id()

            if current_session_id not in data["sessions"]:
                return {"sessions": {}}

            current_session = {current_session_id: data["sessions"][current_session_id]}

            print(f"üìä Retornando sess√£o {current_session_id}")
            return {"sessions": current_session}

        except Exception as e:
            print(f"‚ùå Erro ao obter sess√£o atual: {str(e)}")
            return {"sessions": {}}

    def handle_post_sessions_add_obra(self, post_data):
        """Adiciona uma obra √† sess√£o atual"""
        try:
            data = json.loads(post_data)
            obra_id = data.get("obra_id")

            if not obra_id:
                return {"success": False, "error": "ID da obra n√£o fornecido"}

            print(f"‚ûï Adicionando obra {obra_id} √† sess√£o")
            success = self.sessions_manager.add_obra_to_session(obra_id)

            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} adicionada √† sess√£o",
                }
            else:
                return {"success": False, "error": "Erro ao adicionar obra √† sess√£o"}

        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra √† sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_delete_sessions_remove_obra(self, obra_id):
        """Remove uma obra da sess√£o atual"""
        try:
            print(f"üóëÔ∏è  Removendo obra {obra_id} da sess√£o")

            success = self.sessions_manager.remove_obra(obra_id)

            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} removida da sess√£o",
                }
            else:
                return {"success": False, "error": "Erro ao remover obra da sess√£o"}

        except Exception as e:
            print(f"‚ùå Erro ao remover obra da sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_get_session_obras(self):
        """Retorna apenas os IDs das obras da sess√£o atual"""
        try:
            session_obras = self.sessions_manager.get_session_obras()
            current_session_id = self.sessions_manager.get_current_session_id()

            print(
                f"üìã [SESSION-OBRAS] Sess√£o {current_session_id} - Obras: {session_obras}"
            )

            return {"session_id": current_session_id, "obras": session_obras}

        except Exception as e:
            print(f"‚ùå Erro em handle_get_session_obras: {str(e)}")
            return {"session_id": "error", "obras": []}

    def handle_post_sessions_shutdown(self):
        """Limpa COMPLETAMENTE TODAS as sess√µes"""
        try:
            print(f"üî¥ SHUTDOWN COMPLETO: Deletando TODAS as sess√µes")

            data_before = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado ANTES do shutdown: {data_before}")

            success = self.sessions_manager.clear_session()

            data_after = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado DEPOIS do shutdown: {data_after}")

            is_empty = (
                not data_after.get("sessions")
                or data_after["sessions"] == {}
                or (
                    data_after.get("sessions", {})
                    .get("session_active", {})
                    .get("obras", [])
                    == []
                )
            )

            if success and is_empty:
                return {
                    "success": True,
                    "message": "Sess√µes DELETADAS completamente",
                    "final_state": data_after,
                }
            else:
                print("üîÑ M√©todo normal falhou - for√ßando limpeza...")
                success = self.sessions_manager.force_clear_all_sessions()
                data_final = self.sessions_manager._load_sessions_data()

                final_is_empty = (
                    not data_final.get("sessions")
                    or data_final["sessions"] == {}
                    or (
                        data_final.get("sessions", {})
                        .get("session_active", {})
                        .get("obras", [])
                        == []
                    )
                )

                if success and final_is_empty:
                    return {
                        "success": True,
                        "message": "Sess√µes DELETADAS (for√ßado)",
                        "final_state": data_final,
                    }
                else:
                    print(
                        f"‚ö†Ô∏è  Sess√£o final n√£o est√° completamente vazia, mas considerando sucesso: {data_final}"
                    )
                    return {
                        "success": True,
                        "message": "Sess√µes limpas com aviso",
                        "final_state": data_final,
                        "warning": "Sess√£o pode conter dados residuais",
                    }

        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")
            return {
                "success": True,
                "message": "Sess√µes limpas (com erro ignorado)",
                "error_ignored": str(e),
            }

    def handle_post_sessions_ensure_single(self):
        """Garante que apenas uma sess√£o esteja ativa por vez"""
        try:
            print(f"üîí Garantindo sess√£o √∫nica")

            success = self.sessions_manager.ensure_single_session()
            current_session_id = self.sessions_manager.get_current_session_id()
            obra_ids = self.sessions_manager.get_session_obras()

            if success:
                return {
                    "success": True,
                    "message": "Sess√£o √∫nica configurada",
                    "session_id": current_session_id,
                    "obras_count": len(obra_ids),
                    "obras": obra_ids,
                }
            else:
                return {"success": False, "error": "Erro ao configurar sess√£o √∫nica"}

        except Exception as e:
            print(f"‚ùå Erro ao configurar sess√£o √∫nica: {str(e)}")
            return {"success": False, "error": str(e)}

    # ========== ROTAS DE SISTEMA ==========

    def handle_shutdown(self):
        """Encerra o servidor com limpeza de cache"""
        try:
            print("üî¥ SHUTDOWN SOLICITADO VIA BOT√ÉO - ENCERRANDO SERVIDOR")

            response = {
                "status": "shutting_down",
                "message": "Servidor encerrado com sucesso via bot√£o",
                "action": "close_window",
                "close_delay": 3000,
            }

            print("‚úÖ Resposta enviada ao cliente - servidor ser√° encerrado")

            def shutdown_sequence():
                print("üîÑ Iniciando sequ√™ncia de encerramento...")

                try:
                    print("üßπ Executando limpeza de cache...")
                    self.cache_cleaner.clean_pycache_async()
                except Exception as cache_error:
                    print(f"‚ö†Ô∏è  Erro na limpeza de cache: {cache_error}")

                time.sleep(2)
                print("üí• For√ßando encerramento do processo Python...")

                import os

                os._exit(0)

            shutdown_thread = threading.Thread(target=shutdown_sequence)
            shutdown_thread.daemon = True
            shutdown_thread.start()

            return response

        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")

            try:
                self.cache_cleaner.clean_pycache_async()
            except:
                pass

            import os

            os._exit(0)

    def handle_get_constants(self):
        """Constants do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            constants = dados_data.get("constants", {})
            print(f"‚öôÔ∏è  Retornando constants")
            return constants

        except Exception as e:
            print(f"‚ùå Erro ao carregar constants: {str(e)}")
            return {}

    def handle_get_machines(self):
        """Machines do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            machines = dados_data.get("machines", [])
            print(f"üñ•Ô∏è  Retornando {len(machines)} m√°quinas")
            return machines

        except Exception as e:
            print(f"‚ùå Erro ao carregar machines: {str(e)}")
            return []

    def handle_get_dados(self):
        """DADOS.json completo"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(
                dados_file, {
                    "constants": {}, 
                    "machines": [],
                    "materials": {},
                    "empresas": [],
                    "banco_acessorios": {}  # ADICIONE AQUI
                }
            )

            print("üìÅ Retornando DADOS.json")
            return dados_data

        except Exception as e:
            print(f"‚ùå Erro ao carregar dados: {str(e)}")
            return {"constants": {}, "machines": []}

    def handle_get_backup(self):
        """BACKUP.json completo"""
        try:
            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(
                backup_file, {"obras": [], "projetos": []}
            )

            print("üíæ Retornando BACKUP.json")
            return backup_data

        except Exception as e:
            print(f"‚ùå Erro ao carregar backup: {str(e)}")
            return {"obras": [], "projetos": []}

    def handle_get_backup_completo(self):
        """Obt√©m TODAS as obras do backup (sem filtro de sess√£o)"""
        try:
            print("üéØ [BACKUP COMPLETO] Obtendo TODAS as obras")

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return {"obras": []}

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_content = f.read()

            backup_data = json.loads(backup_content)
            obras = backup_data.get("obras", [])

            print(f"üìÅ Total de obras no backup: {len(obras)}")
            return {"obras": obras}

        except Exception as e:
            print(f"‚ùå ERRO em handle_get_backup_completo: {str(e)}")
            return {"obras": []}

    def handle_post_dados(self, post_data):
        """Salva DADOS.json"""
        try:
            new_data = json.loads(post_data)

            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)

            if self.file_utils.save_json_file(dados_file, new_data):
                print("üíæ DADOS.json salvo")
                return {"status": "success", "message": "Dados salvos"}
            else:
                return {"status": "error", "message": "Erro ao salvar dados"}

        except Exception as e:
            print(f"‚ùå Erro ao salvar dados: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_backup(self, post_data):
        """Salva BACKUP.json"""
        try:
            new_data = json.loads(post_data)

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )

            if self.file_utils.save_json_file(backup_file, new_data):
                print("üíæ BACKUP.json salvo")
                return {"status": "success", "message": "Backup salvo"}
            else:
                return {"status": "error", "message": "Erro ao salvar backup"}

        except Exception as e:
            print(f"‚ùå Erro ao salvar backup: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_reload_page(self, post_data):
        """For√ßa recarregamento da p√°gina via Python"""
        try:
            data = json.loads(post_data)

            action = data.get("action", "unknown")
            obra_id = data.get("obraId")
            obra_name = data.get("obraName")

            print(
                f"üîÑ [RECARREGAMENTO] A√ß√£o: {action}, Obra: {obra_name} (ID: {obra_id})"
            )

            if action == "undo":
                print(
                    f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o da obra {obra_name} - mantendo na sess√£o"
                )
            elif action == "undo_no_data":
                print(
                    f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o (dados insuficientes) - recarregando p√°gina"
                )
            elif action.startswith("timeout"):
                print(f"‚è∞ Timeout completo - obra {obra_name} removida da sess√£o")

            return {
                "reload_required": True,
                "action": action,
                "obra_id": obra_id,
                "obra_name": obra_name,
                "message": "P√°gina ser√° recarregada",
                "reload_delay": 500,
            }

            print(f"‚úÖ Comando de recarregamento enviado para o frontend")

        except Exception as e:
            print(f"‚ùå Erro no recarregamento: {str(e)}")
            return {
                "reload_required": True,
                "error": str(e),
                "message": "Recarregamento for√ßado devido a erro",
            }

            # ========== ROTA UNIVERSAL DELETE ==========


    def handle_delete_universal(self, path_array):
        """Deleta qualquer item no backup.json seguindo um caminho espec√≠fico"""
        try:
            print(f"üîç [DELETE UNIVERSAL] Path recebido: {path_array}")
            print(f"üîç [DELETE UNIVERSAL] Tipos dos elementos: {[type(item) for item in path_array]}")
            
            # Carrega backup.json
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {})
            
            current = backup_data
            parent = None
            parent_key = None
            
            # Navega at√© o pen√∫ltimo n√≠vel
            for i, key in enumerate(path_array[:-1]):
                print(f"üîç Navegando: key='{key}' (tipo: {type(key)}), n√≠vel={i}, tipo_atual={type(current)}")
                
                if isinstance(current, list):
                    # Buscar por ID em array (obras, projetos, salas)
                    item_found = False
                    for idx, item in enumerate(current):
                        if isinstance(item, dict) and str(item.get('id', '')) == str(key):
                            parent = current
                            parent_key = idx
                            current = item
                            item_found = True
                            print(f"‚úÖ Encontrado '{key}' no √≠ndice {idx}")
                            break
                    
                    if not item_found:
                        return {
                            "success": False,
                            "error": f"Caminho inv√°lido: '{key}' n√£o encontrado",
                            "path": path_array
                        }
                        
                elif isinstance(current, dict):
                    # Acesso direto por chave de dicion√°rio
                    if key not in current:
                        return {
                            "success": False,
                            "error": f"Caminho inv√°lido: '{key}' n√£o encontrado",
                            "path": path_array
                        }
                    parent = current
                    parent_key = key
                    current = current[key]
                else:
                    return {
                        "success": False,
                        "error": f"Tipo inv√°lido no caminho: {type(current)}",
                        "path": path_array
                    }
            
            # üî• CORRE√á√ÉO CR√çTICA: √öLTIMO ELEMENTO - SEMPRE tenta como √≠ndice primeiro
            last_item = path_array[-1]
            print(f"üîç √öltimo item a deletar: '{last_item}' (tipo: {type(last_item)})")
            print(f"üîç N√≠vel final type: {type(current)}")
            
            if isinstance(current, list):
                print(f"üîç Array final com {len(current)} itens")
                
                # üî• SEMPRE TENTA COMO √çNDICE PRIMEIRO (para m√°quinas)
                try:
                    # Converter para inteiro
                    item_index = int(last_item)
                    print(f"üîç Interpretando '{last_item}' como √≠ndice num√©rico: {item_index}")
                    
                    if 0 <= item_index < len(current):
                        print(f"‚úÖ Removendo pelo √≠ndice {item_index}")
                        deleted_item = current.pop(item_index)
                        print(f"‚úÖ Item removido do √≠ndice {item_index}. Array agora tem {len(current)} itens")
                    else:
                        return {
                            "success": False,
                            "error": f"√çndice {item_index} fora do range (0-{len(current)-1})",
                            "path": path_array
                        }
                        
                except (ValueError, TypeError) as e:
                    # Se n√£o for n√∫mero, buscar por ID (para obras/projetos/salas)
                    print(f"üîç '{last_item}' n√£o √© n√∫mero v√°lido, buscando por ID...")
                    item_index = -1
                    for i, item in enumerate(current):
                        if isinstance(item, dict):
                            item_id = str(item.get('id', ''))
                            if item_id == str(last_item):
                                item_index = i
                                break
                    
                    if item_index == -1:
                        return {
                            "success": False,
                            "error": f"Item '{last_item}' n√£o encontrado",
                            "path": path_array
                        }
                    
                    deleted_item = current.pop(item_index)
                    print(f"‚úÖ Removido item com ID '{last_item}' no √≠ndice {item_index}")
                    
            elif isinstance(current, dict):
                # Para dicion√°rios, remover pela chave
                if str(last_item) not in current:
                    return {
                        "success": False,
                        "error": f"Item '{last_item}' n√£o encontrado no dicion√°rio",
                        "path": path_array
                    }
                
                deleted_item = current.pop(str(last_item))
                print(f"‚úÖ Removido chave '{last_item}' do dicion√°rio")
            else:
                return {
                    "success": False,
                    "error": f"Tipo inv√°lido: {type(current)}",
                    "path": path_array
                }
            
            # Salvar backup atualizado
            print(f"üíæ Salvando backup atualizado...")
            if self.file_utils.save_json_file(backup_file, backup_data):
                # Se for uma obra, tamb√©m remove da sess√£o atual
                if len(path_array) == 2 and path_array[0] == 'obras':
                    obra_id = path_array[1]
                    self.sessions_manager.remove_obra(obra_id)
                    print(f"üóëÔ∏è Obra {obra_id} tamb√©m removida da sess√£o")
                
                return {
                    "success": True,
                    "message": "Item deletado com sucesso",
                    "path": path_array,
                    "deleted_item": str(last_item)
                }
            else:
                return {
                    "success": False,
                    "error": "Erro ao salvar backup.json",
                    "path": path_array
                }
            
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_universal: {e}")
            import traceback
            traceback.print_exc()
            
            return {
                "success": False,
                "error": f"Erro interno: {str(e)}",
                "path": path_array
            }

    def handle_delete_universal_from_handler(self, handler):
        """Wrapper para receber dados do handler HTTP"""
        try:
            content_length = int(handler.headers["Content-Length"])
            post_data = handler.rfile.read(content_length).decode("utf-8")
            data = json.loads(post_data)

            path = data.get("path")

            if not path or not isinstance(path, list):
                return {
                    "success": False,
                    "error": "Path inv√°lido. Deve ser um array (ex: ['obras', 'id_da_obra'])",
                }

            return self.handle_delete_universal(path)

        except json.JSONDecodeError:
            return {"success": False, "error": "JSON inv√°lido"}
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_universal_from_handler: {e}")
            return {"success": False, "error": f"Erro no handler: {str(e)}"}



    # ==========  FUN√á√ïES PARA SISTEMA DE EDI√á√ÉO ==========

    def handle_get_system_data(self):
        """Retorna TODOS os dados do sistema para a interface de edi√ß√£o"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(
                dados_file, 
                {
                    "constants": {}, 
                    "machines": [], 
                    "materials": {}, 
                    "empresas": [],
                    "banco_acessorios": {},
                    "dutos": [],
                    "tubos": []  # ADICIONADO
                }
            )
            
            print("üìä Retornando todos os dados do sistema")
            return dados_data
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar system data: {str(e)}")
            return {
                "constants": {}, 
                "machines": [], 
                "materials": {}, 
                "empresas": [],
                "banco_acessorios": {},
                "dutos": [],
                "tubos": []  # ADICIONADO
            }

    def handle_get_constants_json(self):
        """Retorna apenas as constantes formatadas"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            constants = dados_data.get("constants", {})
            return {"constants": constants}
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar constants: {str(e)}")
            return {"constants": {}}

    def handle_get_materials(self):
        """Retorna materiais"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            materials = dados_data.get("materials", {})
            return {"materials": materials}
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar materials: {str(e)}")
            return {"materials": {}}

    def handle_get_all_empresas(self):
        """Retorna todas empresas no formato correto"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            empresas = dados_data.get("empresas", [])
            return {"empresas": empresas}
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar empresas: {str(e)}")
            return {"empresas": []}

    def handle_get_machine_types(self):
        """Retorna lista de tipos de m√°quinas"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            machine_types = [machine.get("type", "") for machine in machines if machine.get("type")]
            
            return {"machine_types": machine_types}
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar machine types: {str(e)}")
            return {"machine_types": []}

    def handle_get_machine_by_type(self, machine_type):
        """Retorna m√°quina espec√≠fica pelo tipo"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            
            for machine in machines:
                if machine.get("type") == machine_type:
                    return {"machine": machine}
            
            return {"machine": None}
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar machine: {str(e)}")
            return {"machine": None}

    def handle_post_save_system_data(self, post_data):
        """Salva TODOS os dados do sistema"""
        try:
            new_data = json.loads(post_data)
            
            # Valida estrutura b√°sica ATUALIZADA com dutos e tubos
            required_keys = [
                "constants", "machines", "materials", "empresas", 
                "banco_acessorios", "dutos", "tubos"  # ADICIONADO tubos
            ]
            if not all(key in new_data for key in required_keys):
                return {
                    "success": False, 
                    "error": "Estrutura de dados inv√°lida. Faltam campos obrigat√≥rios."
                }
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            
            if self.file_utils.save_json_file(dados_file, new_data):
                print("üíæ TODOS os dados do sistema salvos (incluindo dutos e tubos)")
                return {"success": True, "message": "Dados salvos com sucesso"}
            else:
                return {"success": False, "error": "Erro ao salvar dados"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar system data: {str(e)}")
            return {"success": False, "error": str(e)}


    def handle_post_save_constants(self, post_data):
        """Salva apenas as constantes"""
        try:
            new_constants = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["constants"] = new_constants.get("constants", {})
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ Constantes salvas")
                return {"success": True, "message": "Constantes salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar constantes"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar constants: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_materials(self, post_data):
        """Salva materiais"""
        try:
            new_materials = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["materials"] = new_materials.get("materials", {})
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ Materiais salvos")
                return {"success": True, "message": "Materiais salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar materiais"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar materials: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_empresas(self, post_data):
        """Salva empresas"""
        try:
            new_empresas = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["empresas"] = new_empresas.get("empresas", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ Empresas salvas")
                return {"success": True, "message": "Empresas salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar empresas"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar empresas: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_machines(self, post_data):
        """Salva todas as m√°quinas"""
        try:
            new_machines = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["machines"] = new_machines.get("machines", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ M√°quinas salvas")
                return {"success": True, "message": "M√°quinas salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar m√°quinas"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar machines: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_add_machine(self, post_data):
        """Adiciona nova m√°quina"""
        try:
            new_machine = json.loads(post_data)
            
            if not new_machine.get("type"):
                return {"success": False, "error": "Tipo de m√°quina n√£o especificado"}
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            machines.append(new_machine)
            dados_data["machines"] = machines
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print(f"üíæ Nova m√°quina '{new_machine.get('type')}' adicionada")
                return {"success": True, "message": "M√°quina adicionada", "machine": new_machine}
            else:
                return {"success": False, "error": "Erro ao adicionar m√°quina"}
                
        except Exception as e:
            print(f"‚ùå Erro ao adicionar machine: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_update_machine(self, post_data):
        """Atualiza m√°quina existente"""
        try:
            update_data = json.loads(post_data)
            
            machine_type = update_data.get("type")
            if not machine_type:
                return {"success": False, "error": "Tipo de m√°quina n√£o especificado"}
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            updated = False
            
            for i, machine in enumerate(machines):
                if machine.get("type") == machine_type:
                    machines[i] = update_data
                    updated = True
                    break
            
            if not updated:
                return {"success": False, "error": f"M√°quina '{machine_type}' n√£o encontrada"}
            
            dados_data["machines"] = machines
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print(f"üíæ M√°quina '{machine_type}' atualizada")
                return {"success": True, "message": "M√°quina atualizada", "machine": update_data}
            else:
                return {"success": False, "error": "Erro ao atualizar m√°quina"}
                
        except Exception as e:
            print(f"‚ùå Erro ao atualizar machine: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_empresas_auto(self, post_data):
        """Cria empresa automaticamente"""
        try:
            # Esta fun√ß√£o pode delegar para o EmpresaHandler
            return {
                "success": True, 
                "message": "Empresa auto criada"
            }
        except Exception as e:
            print(f"‚ùå Erro em handle_post_empresas_auto: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_health_check(self):
        """Health check r√°pido"""
        return {"status": "online", "timestamp": time.time()}

    def handle_get_server_uptime(self):
        """Retorna uptime do servidor"""
        try:
            import time
            from servidor_modules.core.sessions_core import sessions_manager
            
            # Calcular tempo desde o in√≠cio
            start_time = sessions_manager.start_time
            uptime_seconds = time.time() - start_time
            
            # Converter para formato leg√≠vel
            hours = int(uptime_seconds // 3600)
            minutes = int((uptime_seconds % 3600) // 60)
            seconds = int(uptime_seconds % 60)
            
            return {
                "uptime_seconds": uptime_seconds,
                "uptime_human": f"{hours}h {minutes}m {seconds}s",
                "start_time": start_time
            }
        except Exception as e:
            print(f"‚ùå Erro ao obter uptime: {str(e)}")
            return {"error": str(e)}

    def handle_get_projetos(self):
        """Obt√©m projetos (legacy)"""
        try:
            # Implementa√ß√£o simples para compatibilidade
            return []
        except Exception as e:
            print(f"‚ùå Erro ao obter projetos: {str(e)}")
            return []
        
    
    def handle_delete_empresa_by_index(self, index):
        """Deleta uma empresa pelo √≠ndice"""
        try:
            index_int = int(index)
            print(f"üóëÔ∏è  [DELETE EMPRESA] Excluindo empresa no √≠ndice: {index_int}")

            # Carrega dados.json
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            empresas = dados_data.get("empresas", [])
            if not isinstance(empresas, list):
                return {"success": False, "error": "Estrutura 'empresas' inv√°lida"}

            # Verifica √≠ndice
            if 0 <= index_int < len(empresas):
                empresa_removida = empresas.pop(index_int)
                sigla_removida = list(empresa_removida.keys())[0] if empresa_removida else "?"
                print(f"‚úÖ Empresa '{sigla_removida}' (√≠ndice {index_int}) removida.")

                # Salva
                dados_data["empresas"] = empresas
                if self.file_utils.save_json_file(dados_file, dados_data):
                    return {"success": True, "message": f"Empresa {sigla_removida} exclu√≠da"}
                else:
                    return {"success": False, "error": "Falha ao salvar arquivo"}
            else:
                return {"success": False, "error": f"√çndice {index_int} inv√°lido"}

        except ValueError:
            return {"success": False, "error": f"√çndice inv√°lido: '{index}'"}
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_empresa_by_index: {e}")
            return {"success": False, "error": str(e)}
        
        
    def handle_delete_empresa(self, index):
        """Deleta uma empresa pelo √≠ndice"""
        try:
            index_int = int(index)
            print(f"üóëÔ∏è  [DELETE EMPRESA] Excluindo empresa no √≠ndice: {index_int}")

            # Carrega dados.json
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            empresas = dados_data.get("empresas", [])
            if not isinstance(empresas, list):
                return {"success": False, "error": "Estrutura 'empresas' inv√°lida"}

            # Verifica √≠ndice
            if 0 <= index_int < len(empresas):
                empresa_removida = empresas.pop(index_int)
                sigla_removida = list(empresa_removida.keys())[0] if empresa_removida else "?"
                print(f"‚úÖ Empresa '{sigla_removida}' (√≠ndice {index_int}) removida.")

                # Salva
                dados_data["empresas"] = empresas
                if self.file_utils.save_json_file(dados_file, dados_data):
                    return {"success": True, "message": f"Empresa {sigla_removida} exclu√≠da"}
                else:
                    return {"success": False, "error": "Falha ao salvar arquivo"}
            else:
                return {"success": False, "error": f"√çndice {index_int} inv√°lido"}

        except ValueError:
            return {"success": False, "error": f"√çndice inv√°lido: '{index}'"}
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_empresa: {e}")
            return {"success": False, "error": str(e)}
        
        
        
        # Adicionar na classe RoutesCore:


        
        
    def handle_get_acessorios(self):
        """Retorna todos os acessorios do banco_acessorios"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            acessorios = dados_data.get("banco_acessorios", {})
            return {
                "success": True,
                "acessorios": acessorios,
                "count": len(acessorios)
            }
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar acessorios: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "acessorios": {},
                "count": 0
            }
            
            
    def handle_get_dutos(self):
        """Retorna todos os dutos"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dutos = dados_data.get("dutos", [])
            return {
                "success": True,
                "dutos": dutos,
                "count": len(dutos)
            }
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar dutos: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "dutos": [],
                "count": 0
            }
            
    def handle_post_save_dutos(self, post_data):
        """Salva apenas os dutos"""
        try:
            new_dutos = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["dutos"] = new_dutos.get("dutos", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ Dutos salvos")
                return {"success": True, "message": "Dutos salvos"}
            else:
                return {"success": False, "error": "Erro ao salvar dutos"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar dutos: {str(e)}")
            return {"success": False, "error": str(e)}
        
        
    def handle_get_tubos(self):
        """Retorna todos os tubos"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            tubos = dados_data.get("tubos", [])
            return {
                "success": True,
                "tubos": tubos,
                "count": len(tubos)
            }
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar tubos: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "tubos": [],
                "count": 0
            }

    def handle_post_save_tubos(self, post_data):
        """Salva apenas os tubos"""
        try:
            new_tubos = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["tubos"] = new_tubos.get("tubos", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("üíæ Tubos salvos")
                return {"success": True, "message": "Tubos salvos"}
            else:
                return {"success": False, "error": "Erro ao salvar tubos"}
                
        except Exception as e:
            print(f"‚ùå Erro ao salvar tubos: {str(e)}")
            return {"success": False, "error": str(e)}
        
        
        
        # Adicione este m√©todo na classe RoutesCore, depois do m√©todo handle_post_update_machine:

    def handle_post_delete_machine(self, post_data):
        """Deleta uma m√°quina do sistema"""
        try:
            data = json.loads(post_data)
            
            # Obt√©m o tipo da m√°quina e o √≠ndice
            machine_type = data.get("type")
            index = data.get("index", None)
            
            if not machine_type:
                return {"success": False, "error": "Tipo de m√°quina n√£o especificado"}
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            
            # Buscar m√°quina pelo tipo
            machine_found = False
            machine_index = -1
            
            for i, machine in enumerate(machines):
                if machine.get("type") == machine_type:
                    machine_found = True
                    machine_index = i
                    break
            
            # Se n√£o encontrar pelo tipo, tenta pelo √≠ndice
            if not machine_found and index is not None:
                try:
                    index_int = int(index)
                    if 0 <= index_int < len(machines):
                        machine_found = True
                        machine_index = index_int
                except (ValueError, TypeError):
                    pass
            
            if not machine_found:
                return {"success": False, "error": f"M√°quina '{machine_type}' n√£o encontrada"}
            
            # Remover a m√°quina
            machine_removed = machines.pop(machine_index)
            dados_data["machines"] = machines
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print(f"üóëÔ∏è  M√°quina '{machine_type}' (√≠ndice {machine_index}) removida com sucesso")
                return {
                    "success": True, 
                    "message": f"M√°quina '{machine_type}' deletada com sucesso",
                    "machine_removed": machine_removed,
                    "index": machine_index
                }
            else:
                return {"success": False, "error": "Erro ao salvar dados ap√≥s remo√ß√£o"}
                
        except json.JSONDecodeError:
            return {"success": False, "error": "JSON inv√°lido"}
        except Exception as e:
            print(f"‚ùå Erro ao deletar machine: {str(e)}")
            return {"success": False, "error": str(e)}
/* ==== FIM: core/routes_core.py ==== */

/* ==== IN√çCIO: handlers/word_handler.py ==== */
# servidor_modules/handlers/word_handler.py
"""
word_handler.py - Manipula√ß√£o de documentos Word
"""

import json
import os
import tempfile
from pathlib import Path
from datetime import datetime
from docxtpl import DocxTemplate
import traceback
from http.server import BaseHTTPRequestHandler
from typing import Dict, List, Any, Optional

class WordHandler:
    """Handler para gera√ß√£o de documentos Word"""
    
    def __init__(self, project_root, file_utils):
        self.project_root = project_root
        self.file_utils = file_utils
        self.templates_dir = project_root / "word_templates"
        self.ensure_templates_dir()
        
    def ensure_templates_dir(self):
        """Garante que a pasta de templates existe"""
        self.templates_dir.mkdir(exist_ok=True)
        
        # Cria templates padr√£o se n√£o existirem
        default_templates = {
            "proposta_comercial_template.docx": {
                "name": "Proposta Comercial",
                "description": "Documento comercial com valores, condi√ß√µes de pagamento"
            },
            "proposta_tecnica_template.docx": {
                "name": "Proposta T√©cnica", 
                "description": "Documento t√©cnico com especifica√ß√µes e c√°lculos"
            }
        }
        
        # Cria arquivos de placeholder se n√£o existirem
        for filename, info in default_templates.items():
            template_path = self.templates_dir / filename
            if not template_path.exists():
                self.create_placeholder_template(template_path, info["name"])
                
    def create_placeholder_template(self, template_path, template_name):
        """Cria um template placeholder se n√£o existir"""
        try:
            from docx import Document
            from docx.shared import Pt, Inches, RGBColor
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            doc = Document()
            
            # T√≠tulo
            title = doc.add_heading(f'Template: {template_name}', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Informa√ß√µes
            doc.add_paragraph(f'Template criado em: {datetime.now().strftime("%d/%m/%Y")}')
            doc.add_paragraph('Este √© um template placeholder. Substitua com seu template real.')
            doc.add_paragraph('Vari√°veis dispon√≠veis:')
            
            # Vari√°veis exemplo para Proposta Comercial
            if "comercial" in template_name.lower():
                vars_list = doc.add_paragraph()
                vars_list.add_run('‚Ä¢ {{data_emissao}} - Data de emiss√£o\n').bold = True
                vars_list.add_run('‚Ä¢ {{empresa_nome}} - Nome da empresa cliente\n')
                vars_list.add_run('‚Ä¢ {{obra_nome}} - Nome da obra\n')
                vars_list.add_run('‚Ä¢ {{cliente_final}} - Nome do cliente final\n')
                vars_list.add_run('‚Ä¢ {{valor_total_projeto}} - Valor total do projeto\n')
                vars_list.add_run('‚Ä¢ {{total_global}} - Valor total global\n')
                vars_list.add_run('‚Ä¢ {{machines_spec_groups}} - Lista de m√°quinas por especifica√ß√£o\n')
                vars_list.add_run('‚Ä¢ {{engenharia_valor}} - Valor da engenharia\n')
                vars_list.add_run('‚Ä¢ {{engenharia_descricao}} - Descri√ß√£o da engenharia\n')
                vars_list.add_run('‚Ä¢ {{adicionais}} - Lista de servi√ßos adicionais\n')
            # Vari√°veis exemplo para Proposta T√©cnica
            elif "tecnica" in template_name.lower():
                vars_list = doc.add_paragraph()
                vars_list.add_run('‚Ä¢ {{data_emissao}} - Data de emiss√£o\n').bold = True
                vars_list.add_run('‚Ä¢ {{empresa_nome}} - Nome da empresa\n')
                vars_list.add_run('‚Ä¢ {{obra_nome}} - Nome da obra\n')
                vars_list.add_run('‚Ä¢ {{cliente_final}} - Cliente final\n')
                vars_list.add_run('‚Ä¢ {{normas_aplicaveis}} - Normas t√©cnicas aplicadas\n')
                vars_list.add_run('‚Ä¢ {{escopo_trabalho}} - Escopo do trabalho\n')
                vars_list.add_run('‚Ä¢ {{memoria_calculo}} - Mem√≥ria de c√°lculo\n')
                vars_list.add_run('‚Ä¢ {{especificacoes_tecnicas}} - Especifica√ß√µes t√©cnicas\n')
            
            doc.save(str(template_path))
            print(f"‚úÖ Template placeholder criado: {template_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar template placeholder: {e}")
            return False
    
    def get_available_templates(self):
        """Retorna templates dispon√≠veis"""
        templates = []
        for file in self.templates_dir.glob("*.docx"):
            templates.append({
                "filename": file.name,
                "path": str(file),
                "size": file.stat().st_size,
                "modified": datetime.fromtimestamp(file.stat().st_mtime).isoformat()
            })
        return templates
    
    def get_obra_data(self, obra_id):
        """Obt√©m dados completos de uma obra"""
        try:
            backup_file = self.project_root / "json" / "backup.json"
            if not backup_file.exists():
                return None
                
            with open(backup_file, "r", encoding="utf-8") as f:
                backup_data = json.load(f)
            
            obras = backup_data.get("obras", [])
            for obra in obras:
                if str(obra.get("id")) == obra_id:
                    return obra
            return None
        except Exception as e:
            print(f"‚ùå Erro ao buscar obra: {e}")
            return None
    
    def generate_proposta_comercial(self, obra_id: str, template_path: Path) -> Optional[str]:
        """Gera documento de Proposta Comercial com tratamento de erros melhorado"""
        try:
            # Verificar template
            if not template_path.exists():
                print(f"‚ùå Template n√£o encontrado: {template_path}")
                return None
            
            # Verificar se √© um arquivo v√°lido
            if template_path.stat().st_size == 0:
                print(f"‚ùå Template est√° vazio: {template_path}")
                return None
            
            # Gerar contexto
            context = self.generate_context_for_pc(obra_id)
            if not context:
                raise ValueError("N√£o foi poss√≠vel gerar contexto para a PC")
            
            print(f"üìä Contexto gerado com {len(context.get('machines_list', []))} m√°quinas")
            
            # Testar contexto b√°sico primeiro
            test_context = {
                "data_emissao": context.get("data_emissao", ""),
                "empresa_nome": context.get("empresa_nome", ""),
                "obra_nome": context.get("obra_nome", ""),
                "cliente_final": context.get("cliente_final", ""),
                "projeto_nome": context.get("projeto_nome", ""),
                "machines_spec_groups": [],
                "engenharia_valor": context.get("engenharia_valor", ""),
                "engenharia_descricao": context.get("engenharia_descricao", ""),
                "tem_adicionais": False,
                "adicionais": [],
                "valor_total_projeto": context.get("valor_total_projeto", ""),
                "total_global": context.get("total_global", ""),
                "empresa_esi_razao_social": context.get("empresa_esi_razao_social", ""),
                "empresa_esi_cnpj": context.get("empresa_esi_cnpj", ""),
                "validade_proposta": context.get("validade_proposta", ""),
                "forma_pagamento_maquinas": context.get("forma_pagamento_maquinas", ""),
                "forma_pagamento_servicos": context.get("forma_pagamento_servicos", ""),
                "prazo_pagamento_maquinas": context.get("prazo_pagamento_maquinas", ""),
                "prazo_pagamento_servicos": context.get("prazo_pagamento_servicos", ""),
                "responsavel": context.get("responsavel", ""),
                "cargo": context.get("cargo", "")
            }
            
            print("üß™ Testando template com contexto b√°sico...")
            
            try:
                doc = DocxTemplate(str(template_path))
                doc.render(test_context)
                print("‚úÖ Template b√°sico funciona!")
            except Exception as template_error:
                print(f"‚ùå Erro no template: {template_error}")
            
            # Agora renderizar com contexto completo
            print("üîÑ Renderizando com contexto completo...")
            doc = DocxTemplate(str(template_path))
            doc.render(context)
            
            # Salvar arquivo tempor√°rio
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as tmp:
                output_path = tmp.name
                doc.save(output_path)
            
            print(f"‚úÖ Proposta Comercial gerada: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar Proposta Comercial: {e}")
            traceback.print_exc()
            return None

    
    def generate_proposta_tecnica_avancada(self, obra_id):
        """Gera proposta t√©cnica usando o gerador espec√≠fico (a implementar)"""
        try:
            # Por enquanto, usar o m√©todo gen√©rico
            return self.generate_word_document(obra_id, "tecnica")
        except Exception as e:
            print(f"‚ùå Erro em generate_proposta_tecnica_avancada: {e}")
            return None, str(e)
    
    def generate_context_for_obra(self, obra_data, template_type="comercial"):
        """Gera contexto para preenchimento do template (m√©todo gen√©rico - mantido para compatibilidade)"""
        try:
            # Dados b√°sicos da obra
            obra_nome = obra_data.get("nome", "Obra n√£o especificada")
            cliente = obra_data.get("cliente", {})
            cliente_nome = cliente.get("nome", "Cliente n√£o especificado") if isinstance(cliente, dict) else "Cliente n√£o especificado"
            
            # Endere√ßo
            endereco_completo = ""
            if isinstance(cliente, dict):
                endereco_parts = []
                if cliente.get("endereco"):
                    endereco_parts.append(cliente["endereco"])
                if cliente.get("bairro"):
                    endereco_parts.append(cliente["bairro"])
                if cliente.get("cidade"):
                    endereco_parts.append(cliente["cidade"])
                if cliente.get("estado"):
                    endereco_parts.append(cliente["estado"])
                if cliente.get("cep"):
                    endereco_parts.append(f"CEP: {cliente['cep']}")
                endereco_completo = ", ".join(filter(None, endereco_parts))
            
            # Formatar valores
            def formatar_valor(valor):
                return f"R$ {valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
            
            # Contexto base
            context = {
                "obra_nome": obra_nome,
                "cliente_nome": cliente_nome,
                "endereco": endereco_completo,
                "data_emissao": datetime.now().strftime("%d/%m/%Y"),
                "data_emissao_completa": datetime.now().strftime("%d de %B de %Y"),
                "hora_emissao": datetime.now().strftime("%H:%M"),
            }
            
            # Adicionar dados espec√≠ficos por tipo de template
            if template_type == "comercial":
                context.update({
                    "titulo_documento": "PROPOSTA COMERCIAL",
                    "tipo_proposta": "Comercial",
                    "condicoes_pagamento": "50% na assinatura do contrato, 50% na entrega",
                    "validade_proposta": "30 dias",
                    "garantia": "12 meses",
                    "prazo_entrega": "45 dias √∫teis",
                })
            elif template_type == "tecnica":
                context.update({
                    "titulo_documento": "PROPOSTA T√âCNICA",
                    "tipo_proposta": "T√©cnica",
                    "normas_aplicaveis": "NBR 16401, NBR 7256, NBR 14606",
                    "escopo_trabalho": "Fornecimento e instala√ß√£o completa do sistema de climatiza√ß√£o",
                    "memoria_calculo": "C√°lculos realizados conforme normas t√©cnicas vigentes",
                    "especificacoes_tecnicas": "Todos os equipamentos conforme cat√°logo t√©cnico",
                })
            
            return context
        except Exception as e:
            print(f"‚ùå Erro ao gerar contexto: {e}")
            return {}
    
    def generate_word_document(self, obra_id, template_type="comercial"):
        """Gera documento Word baseado no template (m√©todo gen√©rico - mantido para compatibilidade)"""
        try:
            # Para Proposta Comercial, usar o m√©todo avan√ßado
            if template_type == "comercial":
                return self.generate_proposta_comercial_avancada(obra_id)
            # Para Proposta T√©cnica, usar o m√©todo avan√ßado quando dispon√≠vel
            elif template_type == "tecnica":
                return self.generate_proposta_tecnica_avancada(obra_id)
            else:
                return None, f"Tipo de template n√£o suportado: {template_type}"
                
        except Exception as e:
            print(f"‚ùå Erro na gera√ß√£o do Word: {e}")
            traceback.print_exc()
            return None, str(e)
    
    def generate_both_documents(self, obra_id):
        """Gera ambos os documentos (comercial e t√©cnico)"""
        try:
            # Gerar proposta comercial usando o gerador avan√ßado
            pc_path, pc_error = self.generate_proposta_comercial_avancada(obra_id)
            if pc_error:
                return None, pc_error
            
            # Gerar proposta t√©cnica
            pt_path, pt_error = self.generate_proposta_tecnica_avancada(obra_id)
            if pt_error:
                # Limpar arquivo gerado anteriormente
                if pc_path and os.path.exists(pc_path):
                    os.unlink(pc_path)
                return None, pt_error
            
            # Para ambos, criar um ZIP com os dois arquivos
            # Por enquanto, retornamos apenas o comercial
            # TODO: Implementar cria√ß√£o de ZIP
            
            return pc_path, None
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar ambos documentos: {e}")
            return None, str(e)
    
    def get_machine_types_with_specifications(self):
        """Obt√©m tipos de m√°quinas com suas especifica√ß√µes do BD"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            if not dados_file.exists():
                return []
            
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            machines = dados_data.get("machines", [])
            machine_types = []
            
            for machine in machines:
                machine_type = machine.get("type", "")
                especificacao = machine.get("especificacao", "")
                
                if machine_type:
                    machine_types.append({
                        "type": machine_type,
                        "especificacao": especificacao if especificacao else "N√£o especificada",
                        "has_impostos": "impostos" in machine,
                        "has_options": "options" in machine and machine["options"]
                    })
            
            return machine_types
            
        except Exception as e:
            print(f"‚ùå Erro ao obter tipos de m√°quinas: {e}")
            return []
    
    def validate_obra_for_pc(self, obra_id):
        """Valida se a obra tem todos os dados necess√°rios para gerar PC"""
        try:
            obra_data = self.get_obra_data(obra_id)
            if not obra_data:
                return False, "Obra n√£o encontrada"
            
            # Verificar dados b√°sicos
            required_fields = ["nome", "empresaNome", "clienteFinal"]
            for field in required_fields:
                if not obra_data.get(field):
                    return False, f"Campo obrigat√≥rio faltando: {field}"
            
            # Verificar se tem projetos
            projetos = obra_data.get("projetos", [])
            if not projetos:
                return False, "Obra n√£o tem projetos"
            
            # Verificar se pelo menos um projeto tem m√°quinas
            has_machines = False
            for projeto in projetos:
                if isinstance(projeto, dict):
                    salas = projeto.get("salas", [])
                    for sala in salas:
                        if isinstance(sala, dict) and sala.get("maquinas"):
                            has_machines = True
                            break
                if has_machines:
                    break
            
            if not has_machines:
                return False, "Nenhuma m√°quina encontrada nos projetos"
            
            return True, "Obra v√°lida para gera√ß√£o de PC"
            
        except Exception as e:
            print(f"‚ùå Erro ao validar obra: {e}")
            return False, f"Erro na valida√ß√£o: {str(e)}"
    
    def get_obra_summary(self, obra_id):
        """Retorna resumo da obra para debug/log"""
        try:
            obra_data = self.get_obra_data(obra_id)
            if not obra_data:
                return {"error": "Obra n√£o encontrada"}
            
            projetos = obra_data.get("projetos", [])
            total_machines = 0
            total_value = obra_data.get("valorTotalObra", 0)
            
            for projeto in projetos:
                if isinstance(projeto, dict):
                    salas = projeto.get("salas", [])
                    for sala in salas:
                        if isinstance(sala, dict):
                            maquinas = sala.get("maquinas", [])
                            total_machines += len(maquinas)
            
            return {
                "obra_id": obra_id,
                "obra_nome": obra_data.get("nome", ""),
                "empresa_nome": obra_data.get("empresaNome", ""),
                "cliente_final": obra_data.get("clienteFinal", ""),
                "numero_projetos": len(projetos),
                "total_machines": total_machines,
                "valor_total": total_value,
                "valor_total_formatado": f"R$ {total_value:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."),
                "data_cadastro": obra_data.get("dataCadastro", "")
            }
            
        except Exception as e:
            print(f"‚ùå Erro ao obter resumo da obra: {e}")
            return {"error": str(e)}
/* ==== FIM: handlers/word_handler.py ==== */

/* ==== IN√çCIO: generators/wordPC_generator.py ==== */
# codigo/servidor_modules/generators/wordPC_generator.py
"""
wordPC_generator.py - Gerador de Proposta Comercial (PC)
"""

import json
import os
from datetime import datetime
from pathlib import Path
from docxtpl import DocxTemplate
import traceback
from typing import Dict, List, Any, Optional


class WordPCGenerator:
    """Gerador espec√≠fico para Proposta Comercial"""
    
    def __init__(self, project_root: Path, file_utils):
        self.project_root = project_root
        self.file_utils = file_utils
        
    def get_dados_data(self) -> Dict:
        """Obt√©m dados do sistema (machines, constants, etc.)"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            if not dados_file.exists():
                return {}
            
            with open(dados_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados.json: {e}")
            return {}
    
    def get_backup_data(self) -> Dict:
        """Obt√©m dados de backup"""
        try:
            backup_file = self.project_root / "json" / "backup.json"
            if not backup_file.exists():
                return {}
            
            with open(backup_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ùå Erro ao carregar backup.json: {e}")
            return {}
    
    def get_obra_by_id(self, obra_id: str) -> Optional[Dict]:
        """Busca obra espec√≠fica no backup"""
        backup_data = self.get_backup_data()
        obras = backup_data.get("obras", [])
        
        for obra in obras:
            if str(obra.get("id")) == obra_id:
                return obra
        
        return None
    
    def get_machine_data_by_type(self, machine_type: str) -> Optional[Dict]:
        """Busca dados de m√°quina espec√≠fica"""
        dados_data = self.get_dados_data()
        machines = dados_data.get("machines", [])
        
        for machine in machines:
            if machine.get("type") == machine_type:
                return machine
        
        return None
    
    def format_currency(self, value: float) -> str:
        """Formata valor monet√°rio"""
        return f"R$ {value:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    
# No m√©todo extract_machines_by_specification, atualize a parte que prepara a m√°quina:

    def extract_machines_by_specification(self, projetos: List[Dict]) -> Dict[str, List[Dict]]:
        """
        Extrai m√°quinas agrupadas por especifica√ß√£o
        Retorna: {"Climatiza√ß√£o": [m√°quinas], "Pressuriza√ß√£o": [m√°quinas], etc.}
        """
        machines_by_spec = {}
        
        for projeto in projetos:
            if not isinstance(projeto, dict):
                continue
                
            salas = projeto.get("salas", [])
            for sala in salas:
                if not isinstance(sala, dict):
                    continue
                    
                maquinas = sala.get("maquinas", [])
                for maquina in maquinas:
                    if not isinstance(maquina, dict):
                        continue
                    
                    # Obter tipo da m√°quina
                    tipo_maquina = maquina.get("tipo", "")
                    machine_data = self.get_machine_data_by_type(tipo_maquina)
                    
                    # Obter especifica√ß√£o do BD
                    especificacao = machine_data.get("especificacao", "Geral") if machine_data else "Geral"
                    
                    # Se n√£o tiver especifica√ß√£o, tentar inferir do nome
                    if not especificacao or especificacao == "":
                        tipo_lower = tipo_maquina.lower()
                        if "press" in tipo_lower or "ventil" in tipo_lower or "exaust" in tipo_lower:
                            especificacao = "Pressuriza√ß√£o/Ventila√ß√£o"
                        elif "climat" in tipo_lower or "split" in tipo_lower or "wall" in tipo_lower:
                            especificacao = "Climatiza√ß√£o"
                        elif "filtro" in tipo_lower:
                            especificacao = "Filtragem"
                        else:
                            especificacao = "Equipamentos"
                    
                    # Buscar fornecedor nos impostos (CORRE√á√ÉO: usar "FORNECEDOR" se existir, sen√£o buscar em outro lugar)
                    impostos = machine_data.get("impostos", {}) if machine_data else {}
                    fornecedor = "N√£o especificado"
                    
                    # Verificar diferentes poss√≠veis nomes para fornecedor
                    fornecedor_keys = ["FORNECEDOR", "FABRICANTE", "MARCA"]
                    for key in fornecedor_keys:
                        if key in impostos:
                            fornecedor = impostos[key]
                            break
                    
                    # Preparar dados da m√°quina para o template
                    maquina_template = {
                        "tipo": maquina.get("tipo", ""),
                        "nome": maquina.get("nome", ""),
                        "potencia": maquina.get("potencia", ""),
                        "quantidade": maquina.get("quantidade", 1),
                        "preco_total": maquina.get("precoTotal", 0),
                        "preco_total_formatado": self.format_currency(maquina.get("precoTotal", 0)),
                        "ambiente": sala.get("nome", ""),
                        "opcoes": maquina.get("opcoesSelecionadas", []),
                        "configuracoes": maquina.get("configuracoesSelecionadas", []),
                        "fornecedor": fornecedor,
                        "frete": impostos.get("FRETE", "") if impostos else "",
                        "icms": impostos.get("ICMS", "") if impostos else "",
                        "ipi": impostos.get("IPI", "") if impostos else "",
                        "dados_completos": maquina  # Mant√©m dados completos para refer√™ncia
                    }
                    
                    # Adicionar ao grupo correto
                    if especificacao not in machines_by_spec:
                        machines_by_spec[especificacao] = []
                    
                    machines_by_spec[especificacao].append(maquina_template)
        
        return machines_by_spec
    
    def calculate_totals(self, obra_data: Dict) -> Dict:
        """Calcula totais da obra"""
        total_obra = obra_data.get("valorTotalObra", 0)
        
        # Calcular total de m√°quinas
        total_maquinas = 0
        total_servicos = 0
        
        projetos = obra_data.get("projetos", [])
        for projeto in projetos:
            if isinstance(projeto, dict):
                # Valor do projeto
                valor_projeto = projeto.get("valorTotalProjeto", 0)
                
                # Servi√ßos
                servicos = projeto.get("servicos", {})
                if isinstance(servicos, dict):
                    # Engenharia
                    engenharia = servicos.get("engenharia", {})
                    if isinstance(engenharia, dict):
                        total_servicos += engenharia.get("valor", 0)
                    
                    # Adicionais
                    adicionais = servicos.get("adicionais", [])
                    if isinstance(adicionais, list):
                        for adicional in adicionais:
                            if isinstance(adicional, dict):
                                total_servicos += adicional.get("valor", 0)
        
        return {
            "total_obra": total_obra,
            "total_obra_formatado": self.format_currency(total_obra),
            "total_maquinas": total_maquinas,
            "total_maquinas_formatado": self.format_currency(total_maquinas),
            "total_servicos": total_servicos,
            "total_servicos_formatado": self.format_currency(total_servicos)
        }
    
    def extract_servicos(self, projetos: List[Dict]) -> Dict:
        """Extrai informa√ß√µes de servi√ßos"""
        servicos_info = {
            "engenharia": {
                "valor": 0,
                "descricao": "",
                "valor_formatado": "R$ 0,00"
            },
            "adicionais": [],
            "tem_adicionais": False
        }
        
        for projeto in projetos:
            if not isinstance(projeto, dict):
                continue
                
            servicos = projeto.get("servicos", {})
            if not isinstance(servicos, dict):
                continue
            
            # Engenharia
            engenharia = servicos.get("engenharia", {})
            if isinstance(engenharia, dict):
                servicos_info["engenharia"]["valor"] = engenharia.get("valor", 0)
                servicos_info["engenharia"]["descricao"] = engenharia.get("descricao", "")
                servicos_info["engenharia"]["valor_formatado"] = self.format_currency(engenharia.get("valor", 0))
            
            # Adicionais
            adicionais = servicos.get("adicionais", [])
            if isinstance(adicionais, list) and adicionais:
                servicos_info["tem_adicionais"] = True
                for adicional in adicionais:
                    if isinstance(adicional, dict):
                        servicos_info["adicionais"].append({
                            "descricao": adicional.get("descricao", ""),
                            "valor": adicional.get("valor", 0),
                            "valor_formatado": self.format_currency(adicional.get("valor", 0))
                        })
        
        return servicos_info
    
    def generate_context_for_pc(self, obra_id: str) -> Dict:
        """Gera contexto completo para Proposta Comercial"""
        try:
            # Obter dados da obra
            obra_data = self.get_obra_by_id(obra_id)
            if not obra_data:
                raise ValueError(f"Obra {obra_id} n√£o encontrada")
            
            # Dados b√°sicos
            obra_nome = obra_data.get("nome", "Obra n√£o especificada")
            empresa_nome = obra_data.get("empresaNome", "Empresa n√£o especificada")
            cliente_final = obra_data.get("clienteFinal", "Cliente n√£o especificado")
            data_cadastro = obra_data.get("dataCadastro", "")
            
            # Projetos
            projetos = obra_data.get("projetos", [])
            
            # Extrair m√°quinas por especifica√ß√£o
            machines_by_spec = self.extract_machines_by_specification(projetos)
            
            # Calcular totais
            totals = self.calculate_totals(obra_data)
            
            # Extrair servi√ßos
            servicos = self.extract_servicos(projetos)
            
            # Data atual
            data_atual = datetime.now()
            
            # Contexto para o template
            context = {
                # Cabe√ßalho
                "data_emissao": data_atual.strftime("%d/%m/%Y"),
                "data_emissao_completa": data_atual.strftime("%d de %B de %Y"),
                "empresa_nome": empresa_nome.upper(),
                "obra_nome": obra_nome,
                "cliente_final": cliente_final,
                
                # Projetos
                "projetos": projetos,
                "projeto_nome": projetos[0].get("nome", "Projeto Principal") if projetos else "Projeto",
                
                # M√°quinas agrupadas por especifica√ß√£o
                "machines_by_specification": machines_by_spec,
                "tem_climatizacao": "Climatiza√ß√£o" in machines_by_spec,
                "tem_pressurizacao": any("press" in spec.lower() for spec in machines_by_spec.keys()),
                "tem_filtragem": any("filtro" in spec.lower() for spec in machines_by_spec.keys()),
                
                # Exemplos espec√≠ficos para cada especifica√ß√£o
                "especificador_climatizacao": "Climatiza√ß√£o" if "Climatiza√ß√£o" in machines_by_spec else "",
                "especificador_pressurizacao": "Pressuriza√ß√£o" if any("press" in spec.lower() for spec in machines_by_spec.keys()) else "",
                "especificador_filtragem": "Filtragem" if any("filtro" in spec.lower() for spec in machines_by_spec.keys()) else "",
                
                # Lista de m√°quinas para itera√ß√£o no template
                "machines_list": [],
                # Processar cada grupo de especifica√ß√£o
                "machines_spec_groups": []
            }
            
            # Processar m√°quinas por grupo de especifica√ß√£o
            for spec, machines in machines_by_spec.items():
                group_total = sum(m.get("preco_total", 0) for m in machines)
                
                # Para cada m√°quina no grupo, adicionar √† lista
                for machine in machines:
                    context["machines_list"].append({
                        "especificacao": spec,
                        **machine
                    })
                
                # Adicionar grupo
                context["machines_spec_groups"].append({
                    "especificacao": spec,
                    "machines": machines,
                    "total_grupo": group_total,
                    "total_grupo_formatado": self.format_currency(group_total),
                    "quantidade_total": len(machines)
                })
            
            # Servi√ßos
            context.update({
                "servicos": servicos,
                "engenharia_valor": servicos["engenharia"]["valor_formatado"],
                "engenharia_descricao": servicos["engenharia"]["descricao"] or "Servi√ßos de engenharia",
                "tem_adicionais": servicos["tem_adicionais"],
                "adicionais": servicos["adicionais"]
            })
            
            # Totais
            context.update({
                "valor_total_obra": totals["total_obra_formatado"],
                "valor_total_projeto": totals["total_obra_formatado"],  # Para o template usar
                "total_global": totals["total_obra_formatado"]
            })
            
            # Informa√ß√µes da empresa ESI (fixas)
            context.update({
                "empresa_esi_razao_social": "ESI ‚Äì ENERGIA SOLU√á√ïES INTELIGENTES LTDA.",
                "empresa_esi_cnpj": "20.232.429/0001-11",
                "validade_proposta": "10 (dez) dias",
                "forma_pagamento_maquinas": "50% sinal, 50% contra embarque",
                "forma_pagamento_servicos": "100% na entrega da REV0 do projeto",
                "prazo_pagamento_maquinas": "30ddl",
                "prazo_pagamento_servicos": "30ddl",
                "responsavel": "Matheus Pacheco Herzeberg Gon√ßalves",
                "cargo": "Engenheiro Mec√¢nico ‚Äì ESI Energia"
            })
            
            return context
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar contexto PC: {e}")
            traceback.print_exc()
            return {}
        
    def generate_proposta_comercial(self, obra_id: str, template_path: Path) -> Optional[str]:
        """Gera documento de Proposta Comercial"""
        try:
            # Verificar template
            if not template_path.exists():
                print(f"‚ùå Template n√£o encontrado: {template_path}")
                return None
            
            # Gerar contexto
            context = self.generate_context_for_pc(obra_id)
            if not context:
                raise ValueError("N√£o foi poss√≠vel gerar contexto para a PC")
            
            print(f"üìä Contexto gerado:")
            print(f"  - Empresa: {context.get('empresa_nome')}")
            print(f"  - Obra: {context.get('obra_nome')}")
            print(f"  - Grupos de m√°quinas: {len(context.get('machines_spec_groups', []))}")
            
            # Debug: mostrar grupos e m√°quinas
            for i, group in enumerate(context.get('machines_spec_groups', [])):
                print(f"  Grupo {i+1}: {group['especificacao']} - {len(group['machines'])} m√°quinas")
                for j, machine in enumerate(group['machines']):
                    print(f"    M√°quina {j+1}: {machine['quantidade']}x {machine['tipo']} - {machine['fornecedor']}")
            
            # Carregar e preencher template
            doc = DocxTemplate(str(template_path))
            
            try:
                # Testar o template com contexto reduzido primeiro
                test_context = {
                    "data_emissao": context.get("data_emissao", ""),
                    "empresa_nome": context.get("empresa_nome", ""),
                    "obra_nome": context.get("obra_nome", ""),
                    "cliente_final": context.get("cliente_final", ""),
                    "machines_spec_groups": [],
                    "projetos": [],
                    "engenharia_valor": context.get("engenharia_valor", ""),
                    "engenharia_descricao": context.get("engenharia_descricao", ""),
                    "valor_total_projeto": context.get("valor_total_projeto", ""),
                    "total_global": context.get("total_global", "")
                }
                
                print("üß™ Testando template com contexto b√°sico...")
                doc.render(test_context)
                print("‚úÖ Template testado com sucesso")
                
                # Agora renderizar com contexto completo
                print("üé® Renderizando template completo...")
                doc = DocxTemplate(str(template_path))  # Recarregar template
                doc.render(context)
                
            except Exception as template_error:
                print(f"‚ùå Erro no template: {template_error}")
                print("üîç Contexto enviado ao template:")
                print(json.dumps({k: v for k, v in context.items() if k != 'machines_list'}, indent=2, default=str))
                raise
            
            # Salvar arquivo tempor√°rio
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as tmp:
                output_path = tmp.name
                doc.save(output_path)
            
            print(f"‚úÖ Proposta Comercial gerada: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar Proposta Comercial: {e}")
            traceback.print_exc()
            return None
/* ==== FIM: generators/wordPC_generator.py ==== */
