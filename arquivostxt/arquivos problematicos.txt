# servidor_modules/handlers/http_handler.py

import http.server
import json
import time
from urllib.parse import urlparse
from pathlib import Path
import os
import gzip
import threading
import re

# IMPORTS
from servidor_modules.utils.file_utils import FileUtils

class UniversalHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """Handler ULTRA-R√ÅPIDO com CACHE BUSTER AUTOM√ÅTICO PARA TODOS OS ARQUIVOS"""
    
    # Arquivos que NUNCA devem ser logados (acelera MUITO)
    SILENT_PATHS = {
        '/static/', '.css', '.js', '.png', '.jpg', '.jpeg',
        '/public/static/', '/public/scripts/', '.woff', '.woff2', '.ico',
        '.svg', '.gif', '.map', '.ttf', '.eot'
    }
    
    # Roteamento direto para m√°xima velocidade
    API_ROUTES = {
        '/constants': 'handle_get_constants',
        '/system-constants': 'handle_get_constants', 
        '/dados': 'handle_get_dados',
        '/backup': 'handle_get_backup',
        '/machines': 'handle_get_machines',
        '/health-check': 'handle_health_check',
        '/session-obras': 'handle_get_session_obras',
        '/api/session-obras': 'handle_get_session_obras',
        '/api/sessions/current': 'handle_get_sessions_current',
        '/api/backup-completo': 'handle_get_backup_completo',
        '/api/dados/empresas': 'handle_get_empresas',
        '/obras': 'handle_get_obras',
        '/api/server/uptime': 'handle_get_server_uptime',
    }

    def __init__(self, *args, **kwargs):
        # INICIALIZA√á√ÉO R√ÅPIDA
        self.file_utils = FileUtils()
        self.project_root = self.file_utils.find_project_root()
        
        # Timestamp √∫nico para TODOS os arquivos (muda a cada execu√ß√£o do servidor)
        self.CACHE_BUSTER = f"v{int(time.time())}"
        print(f"üîÑ CACHE BUSTER INICIADO: {self.CACHE_BUSTER}")
        
        # Inicializa√ß√£o Pregui√ßosa - s√≥ quando necess√°rio
        self._routes_core = None
        self._route_handler = None
        
        serve_directory = self.project_root
        super().__init__(*args, directory=str(serve_directory), **kwargs)
    
    @property
    def routes_core(self):
        """Inicializa√ß√£o pregui√ßosa do RoutesCore"""
        if self._routes_core is None:
            from servidor_modules.core.routes_core import RoutesCore
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner
            
            self._routes_core = RoutesCore(
                self.project_root,
                sessions_manager,
                self.file_utils,
                CacheCleaner()
            )
        return self._routes_core
    
    @property
    def route_handler(self):
        """Inicializa√ß√£o pregui√ßosa do RouteHandler"""
        if self._route_handler is None:
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner
            from servidor_modules.handlers.route_handler import RouteHandler
            
            self._route_handler = RouteHandler(
                self.project_root, 
                sessions_manager, 
                self.file_utils, 
                CacheCleaner()
            )
            self._route_handler.set_routes_core(self.routes_core)
        return self._route_handler

    def do_GET(self):
        """GET com CACHE BUSTER AUTOM√ÅTICO para CSS/JS/HTML"""
        parsed_path = urlparse(self.path)
        original_path = self.path
        path = parsed_path.path
        
        # Normaliza√ß√£o r√°pida de path
        if path.startswith('/codigo/'):
            path = path[7:]
        
        # Log apenas para rotas importantes (acelera MUITO)
        if not any(silent in path for silent in self.SILENT_PATHS):
            print(f"üì• GET: {path}")
        
        # CACHE BUSTER AUTOM√ÅTICO: Adiciona versionamento a CSS, JS e HTML
        if any(path.endswith(ext) for ext in ['.css', '.js', '.html', '.htm']):
            new_path = self._add_cache_buster(original_path)
            if new_path != original_path:
                print(f"üîÑ AUTO CACHE BUSTER: {original_path} -> {new_path}")
                self.path = new_path
        
        # Roteamento R√ÅPIDO para APIs
        if path in self.API_ROUTES:
            handler_name = self.API_ROUTES[path]
            getattr(self.route_handler, handler_name)(self)
        elif path.startswith('/api/dados/empresas/'):
            self.handle_empresa_routes(path)
        elif path.startswith('/obras/'):
            self.handle_obra_routes(path)
        else:
            # Serve arquivo est√°tico COM HEADERS ANTI-CACHE
            self.serve_static_file_no_cache(path)
    
    def do_POST(self):
        """POST com todas as rotas necess√°rias"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üì® POST: {path}")
        
        # ROTAS PRINCIPAIS - SHUTDOWN CORRIGIDAS
        if path == '/obras':
            self.route_handler.handle_post_obras(self)
        elif path == '/api/sessions/shutdown':
            self.route_handler.handle_post_sessions_shutdown(self)
        elif path == '/api/shutdown':
            self.route_handler.handle_shutdown(self)
        elif path == '/dados':
            self.route_handler.handle_post_dados(self)
        elif path == '/backup':
            self.route_handler.handle_post_backup(self)
        elif path == '/api/sessions/ensure-single':
            self.route_handler.handle_post_sessions_ensure_single(self)
        elif path == '/api/sessions/add-obra':
            self.route_handler.handle_post_sessions_add_obra(self)
        elif path == '/api/reload-page':
            self.route_handler.handle_post_reload_page(self)
        # ROTAS DE EMPRESAS
        elif path == '/api/dados/empresas':
            self.route_handler.handle_post_empresas(self)
        # ROTAS LEGACY (COMPATIBILIDADE)
        elif path in ['/projetos', '/projects']:
            self.route_handler.handle_post_projetos(self)
        else:
            print(f"‚ùå POST n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: POST {path}")

    def do_PUT(self):
        """PUT para atualiza√ß√µes"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üì® PUT: {path}")
        
        # ROTAS PRINCIPAIS - OBRAS
        if path.startswith('/obras/'):
            print(f"üéØ Roteando PUT para obra: {path}")
            self.route_handler.handle_put_obra(self)
        else:
            print(f"‚ùå PUT n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: PUT {path}")

    def do_DELETE(self):
        """DELETE para remo√ß√£o de recursos"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üóëÔ∏è  DELETE: {path}")
        
        # ========== NOVA ROTA UNIVERSAL ==========
        if path == '/api/delete':
            self.handle_delete_universal()
        # =========================================
        # ROTAS PRINCIPAIS - OBRAS
        elif path.startswith('/obras/'):
            obra_id = path.split('/')[-1]
            print(f"üéØ Roteando DELETE para obra: {obra_id}")
            self.route_handler.handle_delete_obra(self, obra_id)
        # ROTAS PRINCIPAIS - SESS√ïES OBRAS
        elif path.startswith('/api/sessions/remove-obra/'):
            obra_id = path.split('/')[-1]
            self.route_handler.handle_delete_sessions_remove_obra(self, obra_id)

        else:
            print(f"‚ùå DELETE n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: DELETE {path}")

    def handle_delete_universal(self):
        """API universal para deletar qualquer item do backup.json usando path"""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length).decode('utf-8')
            data = json.loads(post_data)
            
            # Obrigat√≥rio: path como array (ex: ["obras", "obra_id", "projetos", "projeto_id"])
            path = data.get('path')
            
            if not path or not isinstance(path, list):
                self.send_json_response({
                    "success": False,
                    "error": "Path inv√°lido. Deve ser um array (ex: ['obras', 'id_da_obra'])"
                }, status=400)
                return
            
            print(f"üóëÔ∏è  DELETE UNIVERSAL - Path: {path}")
            
            # Chama o m√©todo no RoutesCore
            result = self.routes_core.handle_delete_universal(path)
            
            if result["success"]:
                self.send_json_response(result)
            else:
                self.send_json_response(result, status=500)
                
        except json.JSONDecodeError:
            self.send_json_response({
                "success": False,
                "error": "JSON inv√°lido"
            }, status=400)
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_universal: {e}")
            self.send_json_response({
                "success": False,
                "error": f"Erro interno: {str(e)}"
            }, status=500)

    def handle_health_check(self):
        """Health check r√°pido"""
        self.send_json_response({"status": "online", "timestamp": time.time()})
    
    def handle_empresa_routes(self, path):
        """Rotas de empresa otimizadas"""
        if path.startswith('/api/dados/empresas/buscar/'):
            termo = path.split('/')[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith('/api/dados/empresas/numero/'):
            sigla = path.split('/')[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)
    
    def handle_obra_routes(self, path):
        """Rotas de obra otimizadas"""
        if self.command == 'GET':
            obra_id = path.split('/')[-1]
            self.route_handler.handle_get_obra_by_id(self, obra_id)

    def _add_cache_buster(self, path):
        """Adiciona cache buster √† URL se n√£o tiver"""
        if '?' in path:
            # J√° tem par√¢metros, adiciona ou atualiza o v=
            if 'v=' in path:
                # Substitui vers√£o existente
                path = re.sub(r'[?&]v=[^&]+', f'&v={self.CACHE_BUSTER}', path)
                # Corrige se ficou ?& substituindo por ?
                path = path.replace('?&', '?')
            else:
                # Adiciona novo par√¢metro
                path += f'&v={self.CACHE_BUSTER}'
        else:
            # Primeiro par√¢metro
            path += f'?v={self.CACHE_BUSTER}'
        
        return path
    
    def serve_static_file_no_cache(self, path):
        """Serve arquivos est√°ticos - sempre do disco com headers anti-cache"""
        try:
            # Remove par√¢metros para encontrar arquivo real
            clean_path = path.split('?')[0]
            file_path = self.translate_path(clean_path)
            
            if os.path.isfile(file_path):
                self.send_response(200)
                
                # Determina content-type
                if clean_path.endswith('.css'):
                    content_type = 'text/css'
                elif clean_path.endswith('.js'):
                    content_type = 'application/javascript'
                elif clean_path.endswith(('.html', '.htm')):
                    content_type = 'text/html'
                elif clean_path.endswith('.json'):
                    content_type = 'application/json'
                elif clean_path.endswith('.png'):
                    content_type = 'image/png'
                elif clean_path.endswith('.jpg') or clean_path.endswith('.jpeg'):
                    content_type = 'image/jpeg'
                elif clean_path.endswith('.svg'):
                    content_type = 'image/svg+xml'
                else:
                    content_type = self.guess_type(clean_path)
                
                self.send_header('Content-type', content_type)
                
                # HEADERS ANTI-CACHE DEFINITIVOS
                self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate, max-age=0')
                self.send_header('Pragma', 'no-cache')
                self.send_header('Expires', '0')
                self.send_header('Last-Modified', self.date_time_string(time.time()))
                
                self.end_headers()
                
                with open(file_path, 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self.send_error(404, f"File not found: {clean_path}")
                
        except Exception as e:
            print(f"‚ùå Erro em {path}: {e}")
            self.send_error(404, f"Recurso n√£o encontrado: {path}")
    
    def send_json_response(self, data, status=200):
        """Resposta JSON R√ÅPIDA SEM compress√£o para simplicidade"""
        try:
            response = json.dumps(data, ensure_ascii=False).encode('utf-8')
            
            # Resposta direta SEM compress√£o
            self.send_response(status)
            self.send_header('Content-type', 'application/json; charset=utf-8')
            self.send_header('Content-Length', str(len(response)))
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
            self.send_header('Pragma', 'no-cache')
            self.send_header('Expires', '0')
            self.end_headers()
            self.wfile.write(response)
                
        except Exception as e:
            print(f"‚ùå Erro em send_json_response: {e}")
            self.send_error(500, "Erro interno")
    
    def end_headers(self):
        """Headers CORS otimizados """
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        # Headers anti-cache
        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        self.send_header('Pragma', 'no-cache')
        self.send_header('Expires', '0')
        super().end_headers()
    
    def do_OPTIONS(self):
        """CORS r√°pido"""
        self.send_response(200)
        self.end_headers()

    def log_message(self, format, *args):
        """Log SILENCIOSO - apenas erros e APIs importantes"""
        message = format % args
        # Apenas logs importantes
        if any(keyword in message for keyword in [' 404', ' 500', ' 403', '/api/', '/obras', '/empresas']):
            print(f"üåê {self.address_string()} - {message}")
"""
route_handler.py
Handler principal de rotas - Interface entre HTTP e Core
"""

import json
from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import os

class RouteHandler:
    """Manipula o roteamento de requisi√ß√µes HTTP"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        
        # RoutesCore ser√° injetado depois para evitar import circular
        self.routes_core = None
    
    def set_routes_core(self, routes_core):
        """Define o RoutesCore ap√≥s a inicializa√ß√£o para evitar import circular"""
        self.routes_core = routes_core

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self, handler):
        """GET /obras"""
        obras = self.routes_core.handle_get_obras()
        handler.send_json_response(obras)

    def handle_get_obra_by_id(self, handler, obra_id):
        """GET /obras/{id}"""
        obra = self.routes_core.handle_get_obra_by_id(obra_id)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_post_obras(self, handler):
        """POST /obras"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_post_obras(post_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(500, "Erro ao salvar obra")

    def handle_put_obra(self, handler):
        """PUT /obras/{id}"""
        obra_id = handler.path.split('/')[-1]
        content_length = int(handler.headers['Content-Length'])
        put_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_put_obra(obra_id, put_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_delete_obra(self, handler, obra_id):
        """DELETE /obras/{id}"""
        success = self.routes_core.handle_delete_obra(obra_id)
        if success:
            handler.send_json_response({
                "success": True,
                "message": f"Obra {obra_id} deletada com sucesso"
            })
        else:
            handler.send_error(500, "Erro ao deletar obra")

    # ========== ROTAS DE EMPRESAS ==========

    def handle_get_empresas(self, handler):
        """GET /api/dados/empresas"""
        empresas = self.routes_core.handle_get_empresas()
        handler.send_json_response(empresas)
        
    def handle_get_proximo_numero(self, handler, sigla):
        """GET /api/dados/empresas/numero/{sigla}"""
        numero = self.routes_core.handle_get_proximo_numero(sigla)
        handler.send_json_response(numero)

    def handle_post_empresas(self, handler):
        """POST /api/dados/empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas(post_data)
        handler.send_json_response(result)

    def handle_buscar_empresas(self, handler, termo):
        """GET /api/dados/empresas/buscar/{termo}"""
        result = self.routes_core.handle_buscar_empresas(termo)
        handler.send_json_response(result)

    # ========== ROTAS DE SESS√ÉO ==========

    def handle_get_sessions_current(self, handler):
        """GET /api/sessions/current"""
        session_data = self.routes_core.handle_get_sessions_current()
        handler.send_json_response(session_data)

    def handle_post_sessions_add_obra(self, handler):
        """POST /api/sessions/add-obra"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_sessions_add_obra(post_data)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_delete_sessions_remove_obra(self, handler, obra_id):
        """DELETE /api/sessions/remove-obra/{id}"""
        result = self.routes_core.handle_delete_sessions_remove_obra(obra_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_get_session_obras(self, handler):
        """GET /api/session-obras"""
        result = self.routes_core.handle_get_session_obras()
        handler.send_json_response(result)

    def handle_post_sessions_shutdown(self, handler):
        """POST /api/sessions/shutdown"""
        result = self.routes_core.handle_post_sessions_shutdown()
        handler.send_json_response(result)

    def handle_shutdown(self, handler):
        """POST /api/shutdown"""
        response = self.routes_core.handle_shutdown()
        handler.send_json_response(response)

    def handle_post_sessions_ensure_single(self, handler):
        """POST /api/sessions/ensure-single"""
        result = self.routes_core.handle_post_sessions_ensure_single()
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    # ========== ROTAS DE SISTEMA ==========

    def handle_get_server_uptime(self, handler):
        """GET /api/server/uptime"""
        result = self.routes_core.handle_get_server_uptime()
        handler.send_json_response(result)

    def handle_get_constants(self, handler):
        """GET /constants"""
        constants = self.routes_core.handle_get_constants()
        handler.send_json_response(constants)

    def handle_get_machines(self, handler):
        """GET /machines"""
        machines = self.routes_core.handle_get_machines()
        handler.send_json_response(machines)

    def handle_get_dados(self, handler):
        """GET /dados"""
        dados = self.routes_core.handle_get_dados()
        handler.send_json_response(dados)

    def handle_get_backup(self, handler):
        """GET /backup"""
        backup = self.routes_core.handle_get_backup()
        handler.send_json_response(backup)

    def handle_get_backup_completo(self, handler):
        """GET /api/backup-completo"""
        backup = self.routes_core.handle_get_backup_completo()
        handler.send_json_response(backup)

    def handle_post_dados(self, handler):
        """POST /dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_dados(post_data)
        handler.send_json_response(result)

    def handle_post_backup(self, handler):
        """POST /backup"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_backup(post_data)
        handler.send_json_response(result)

    def handle_post_reload_page(self, handler):
        """POST /api/reload-page"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_reload_page(post_data)
        handler.send_json_response(result)

    # ========== ROTAS DE COMPATIBILIDADE ==========

    def handle_get_projetos(self, handler):
        """GET /projetos (legacy)"""
        projetos = self.routes_core.handle_get_projetos()
        handler.send_json_response(projetos)

    def handle_post_projetos(self, handler):
        """POST /projetos (legacy)"""
        handler.send_error(501, "Use o endpoint /obras em vez de /projetos")

    def handle_get_session_projects(self, handler):
        """GET /api/session-projects (legacy)"""
        handler.send_json_response([])

    def handle_delete_sessions_remove_project(self, handler, project_id):
        """DELETE /api/sessions/remove-project/{id} (legacy)"""
        result = self.routes_core.handle_delete_sessions_remove_project(project_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])
        
    def handle_post_empresas_auto(self, handler):
        """POST /api/dados/empresas/auto"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas_auto(post_data)
        handler.send_json_response(result)
        
            # ========== ROTA UNIVERSAL DELETE ==========
    
    def handle_delete_universal(self, handler):
        """DELETE /api/delete - Rota universal para deletar qualquer item"""
        result = self.routes_core.handle_delete_universal_from_handler(handler)
        handler.send_json_response(result)
# servidor_modules/core/routes_core.py

"""
routes_core.py
N√∫cleo das rotas - Divis√£o l√≥gica das funcionalidades
"""

import json
import time
import threading
from pathlib import Path
# from servidor_modules.handlers.empresa_handler import EmpresaHandler  # REMOVA esta linha

class RoutesCore:
    """N√∫cleo das funcionalidades de rotas organizadas por categoria"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        
        # Inicializa EmpresaHandler com file_utils injetado
        from servidor_modules.handlers.empresa_handler import EmpresaHandler
        self.empresa_handler = EmpresaHandler(file_utils=self.file_utils)


    # ========== ROTAS DE OBRAS ==========
    
    def handle_get_obras(self):
        """Obt√©m todas as obras da sess√£o atual"""
        try:
            print("üéØ [OBRAS] Obtendo obras da sess√£o")
            
            current_session_id = self.sessions_manager.get_current_session_id()
            session_data = self.sessions_manager._load_sessions_data()
            session_obra_ids = session_data["sessions"].get(current_session_id, {}).get("obras", [])
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return []
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_data = json.loads(f.read())
            
            obras = backup_data.get('obras', [])
            if not isinstance(obras, list):
                obras = []
                
            obras_da_sessao = []
            for obra in obras:
                if not isinstance(obra, dict):
                    continue
                    
                obra_id = str(obra.get('id', ''))
                if obra_id in session_obra_ids:
                    obras_da_sessao.append(obra)
            
            print(f"üéØ ENVIANDO: {len(obras_da_sessao)} obras da sess√£o")
            return obras_da_sessao
            
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obras: {str(e)}")
            return []

    def handle_get_obra_by_id(self, obra_id):
        """Obt√©m uma obra espec√≠fica por ID"""
        try:
            print(f"üéØ [OBRA POR ID] Buscando obra {obra_id}")
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return None
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_data = json.loads(f.read())
            
            obras = backup_data.get('obras', [])
            
            for obra in obras:
                if str(obra.get('id')) == obra_id:
                    print(f"‚úÖ Obra {obra_id} encontrada")
                    return obra
            
            print(f"‚ùå Obra {obra_id} n√£o encontrada")
            return None
                
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obra_by_id: {str(e)}")
            return None


    def handle_post_obras(self, post_data):
        """Salva nova obra e adiciona √† sess√£o - COM VERIFICA√á√ÉO DE EMPRESA"""
        try:
            nova_obra = json.loads(post_data)
            
            # üÜï VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE SALVAR OBRA
            print("üîç [OBRA] Verificando se precisa criar empresa automaticamente...")
            nova_obra = self.empresa_handler.verificar_e_criar_empresa_automatica(nova_obra)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": [], "projetos": []})
            
            obra_id = nova_obra.get('id')
            
            if not obra_id or obra_id.isdigit():
                import random
                import string
                letters = 'abcdefghjkmnpqrstwxyz'
                random_letter1 = random.choice(letters)
                random_letter2 = random.choice(letters)
                random_num = random.randint(10, 99)
                obra_id = f"obra_{random_letter1}{random_num}"
                
                print(f"üÜï Backend gerou ID seguro: {obra_id}")
            
            nova_obra['id'] = obra_id
            
            print(f"üìù Tentando adicionar obra {obra_id} √† sess√£o...")
            success = self.sessions_manager.add_obra_to_session(obra_id)
            
            if not success:
                print(f"‚ùå FALHA ao adicionar obra {obra_id} √† sess√£o")
                return None
            
            obras = backup_data.get('obras', [])
            obras.append(nova_obra)
            backup_data['obras'] = obras
            
            print(f"‚ûï ADICIONANDO nova obra ID: {obra_id}")
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                print(f"‚úÖ Obra {obra_id} salva com sucesso")
                return nova_obra
            else:
                return None
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra: {str(e)}")
            return None

# NO routes_core.py, MODIFIQUE tamb√©m o m√©todo handle_put_obra:

    def handle_put_obra(self, obra_id, put_data):
        """Atualiza obra existente - COM VERIFICA√á√ÉO DE EMPRESA"""
        try:
            obra_atualizada = json.loads(put_data)
            
            # üÜï VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE ATUALIZAR OBRA
            print("üîç [OBRA UPDATE] Verificando se precisa criar empresa automaticamente...")
            obra_atualizada = self.empresa_handler.verificar_e_criar_empresa_automatica(obra_atualizada)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file)
            
            if not backup_data:
                return None
            
            obras = backup_data.get('obras', [])
            obra_encontrada = False
            
            for i, obra in enumerate(obras):
                if str(obra.get('id')) == obra_id:
                    obras[i] = obra_atualizada
                    obra_encontrada = True
                    print(f"‚úèÔ∏è  ATUALIZANDO obra {obra_id}")
                    break
            
            if not obra_encontrada:
                return None
            
            backup_data['obras'] = obras
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                return obra_atualizada
            else:
                return None
            
        except Exception as e:
            print(f"‚ùå Erro ao atualizar obra: {str(e)}")
            return None

    def handle_delete_obra(self, obra_id):
        """Deleta uma obra do servidor"""
        try:
            print(f"üóëÔ∏è  Deletando obra {obra_id} do servidor")
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": []})
            
            obras = backup_data.get('obras', [])
            obra_encontrada = False
            
            obras_atualizadas = []
            for obra in obras:
                if str(obra.get('id')) != obra_id:
                    obras_atualizadas.append(obra)
                else:
                    obra_encontrada = True
                    print(f"‚úÖ Obra {obra_id} encontrada para remo√ß√£o")
            
            if not obra_encontrada:
                return False
            
            backup_data['obras'] = obras_atualizadas
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                self.sessions_manager.remove_obra(obra_id)
                return True
            else:
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao deletar obra: {str(e)}")
            return False


    # ========= Metodos para empresas ========
    def handle_get_empresas(self):
        """Obt√©m todas as empresas"""
        try:
            empresas = self.empresa_handler.obter_empresas()
            return {
                "success": True,
                "empresas": empresas
            }
        except Exception as e:
            print(f"‚ùå Erro ao obter empresas: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def handle_post_empresas(self, post_data):
        """Adiciona nova empresa"""
        try:
            empresa_data = json.loads(post_data)
            sucesso, mensagem = self.empresa_handler.adicionar_empresa(empresa_data)
            
            return {
                "success": sucesso,
                "message": mensagem
            }
        except Exception as e:
            print(f"‚ùå Erro ao adicionar empresa: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def handle_buscar_empresas(self, termo):
        """Busca empresas por termo"""
        try:
            from urllib.parse import unquote
            termo_decodificado = unquote(termo)
            resultados = self.empresa_handler.buscar_empresa_por_termo(termo_decodificado)
            
            return {
                "success": True,
                "resultados": resultados
            }
        except Exception as e:
            print(f"‚ùå Erro ao buscar empresas: {e}")
            return {
                "success": False,
                "error": str(e),
                "resultados": []
            }

    def handle_get_proximo_numero(self, sigla):
        """Obt√©m pr√≥ximo n√∫mero para sigla"""
        try:
            from urllib.parse import unquote
            sigla_decodificada = unquote(sigla)
            numero = self.empresa_handler.obter_proximo_numero_cliente(sigla_decodificada)
            
            return {
                "success": True,
                "numero": numero
            }
        except Exception as e:
            print(f"‚ùå Erro ao obter pr√≥ximo n√∫mero: {e}")
            return {
                "success": False,
                "error": str(e),
                "numero": 1
            }

    # ========== ROTAS DE SESS√ÉO ==========
    
    def handle_get_sessions_current(self):
        """Retorna a sess√£o atual"""
        try:
            data = self.sessions_manager._load_sessions_data()
            current_session_id = self.sessions_manager.get_current_session_id()
            
            if current_session_id not in data["sessions"]:
                return {"sessions": {}}
            
            current_session = {
                current_session_id: data["sessions"][current_session_id]
            }
            
            print(f"üìä Retornando sess√£o {current_session_id}")
            return {"sessions": current_session}
            
        except Exception as e:
            print(f"‚ùå Erro ao obter sess√£o atual: {str(e)}")
            return {"sessions": {}}

    def handle_post_sessions_add_obra(self, post_data):
        """Adiciona uma obra √† sess√£o atual"""
        try:
            data = json.loads(post_data)
            obra_id = data.get('obra_id')
            
            if not obra_id:
                return {"success": False, "error": "ID da obra n√£o fornecido"}
            
            print(f"‚ûï Adicionando obra {obra_id} √† sess√£o")
            success = self.sessions_manager.add_obra_to_session(obra_id)
            
            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} adicionada √† sess√£o"
                }
            else:
                return {"success": False, "error": "Erro ao adicionar obra √† sess√£o"}
                
        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra √† sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_delete_sessions_remove_obra(self, obra_id):
        """Remove uma obra da sess√£o atual"""
        try:
            print(f"üóëÔ∏è  Removendo obra {obra_id} da sess√£o")
            
            success = self.sessions_manager.remove_obra(obra_id)
            
            if success:
                return {
                    "success": True, 
                    "message": f"Obra {obra_id} removida da sess√£o"
                }
            else:
                return {"success": False, "error": "Erro ao remover obra da sess√£o"}
                
        except Exception as e:
            print(f"‚ùå Erro ao remover obra da sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_get_session_obras(self):
        """Retorna apenas os IDs das obras da sess√£o atual"""
        try:
            session_obras = self.sessions_manager.get_session_obras()
            current_session_id = self.sessions_manager.get_current_session_id()
            
            print(f"üìã [SESSION-OBRAS] Sess√£o {current_session_id} - Obras: {session_obras}")
            
            return {
                "session_id": current_session_id,
                "obras": session_obras
            }
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_session_obras: {str(e)}")
            return {"session_id": "error", "obras": []}

    def handle_post_sessions_shutdown(self):
        """Limpa COMPLETAMENTE TODAS as sess√µes"""
        try:
            print(f"üî¥ SHUTDOWN COMPLETO: Deletando TODAS as sess√µes")
            
            data_before = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado ANTES do shutdown: {data_before}")
            
            success = self.sessions_manager.clear_session()
            
            data_after = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado DEPOIS do shutdown: {data_after}")
            
            is_empty = (
                not data_after.get("sessions") or 
                data_after["sessions"] == {} or
                (data_after.get("sessions", {}).get("session_active", {}).get("obras", []) == [])
            )
            
            if success and is_empty:
                return {
                    "success": True,
                    "message": "Sess√µes DELETADAS completamente",
                    "final_state": data_after
                }
            else:
                print("üîÑ M√©todo normal falhou - for√ßando limpeza...")
                success = self.sessions_manager.force_clear_all_sessions()
                data_final = self.sessions_manager._load_sessions_data()
                
                final_is_empty = (
                    not data_final.get("sessions") or 
                    data_final["sessions"] == {} or
                    (data_final.get("sessions", {}).get("session_active", {}).get("obras", []) == [])
                )
                
                if success and final_is_empty:
                    return {
                        "success": True,
                        "message": "Sess√µes DELETADAS (for√ßado)",
                        "final_state": data_final
                    }
                else:
                    print(f"‚ö†Ô∏è  Sess√£o final n√£o est√° completamente vazia, mas considerando sucesso: {data_final}")
                    return {
                        "success": True,
                        "message": "Sess√µes limpas com aviso",
                        "final_state": data_final,
                        "warning": "Sess√£o pode conter dados residuais"
                    }
                    
        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")
            return {
                "success": True,
                "message": "Sess√µes limpas (com erro ignorado)",
                "error_ignored": str(e)
            }

    def handle_post_sessions_ensure_single(self):
        """Garante que apenas uma sess√£o esteja ativa por vez"""
        try:
            print(f"üîí Garantindo sess√£o √∫nica")
            
            success = self.sessions_manager.ensure_single_session()
            current_session_id = self.sessions_manager.get_current_session_id()
            obra_ids = self.sessions_manager.get_session_obras()
            
            if success:
                return {
                    "success": True,
                    "message": "Sess√£o √∫nica configurada",
                    "session_id": current_session_id,
                    "obras_count": len(obra_ids),
                    "obras": obra_ids
                }
            else:
                return {"success": False, "error": "Erro ao configurar sess√£o √∫nica"}
                
        except Exception as e:
            print(f"‚ùå Erro ao configurar sess√£o √∫nica: {str(e)}")
            return {"success": False, "error": str(e)}

    # ========== ROTAS DE SISTEMA ==========
    
    def handle_shutdown(self):
        """Encerra o servidor com limpeza de cache"""
        try:
            print("üî¥ SHUTDOWN SOLICITADO VIA BOT√ÉO - ENCERRANDO SERVIDOR")
            
            response = {
                "status": "shutting_down", 
                "message": "Servidor encerrado com sucesso via bot√£o",
                "action": "close_window",
                "close_delay": 3000
            }
            
            print("‚úÖ Resposta enviada ao cliente - servidor ser√° encerrado")
            
            def shutdown_sequence():
                print("üîÑ Iniciando sequ√™ncia de encerramento...")
                
                try:
                    print("üßπ Executando limpeza de cache...")
                    self.cache_cleaner.clean_pycache_async()
                except Exception as cache_error:
                    print(f"‚ö†Ô∏è  Erro na limpeza de cache: {cache_error}")
                
                time.sleep(2)
                print("üí• For√ßando encerramento do processo Python...")
                
                import os
                os._exit(0)
            
            shutdown_thread = threading.Thread(target=shutdown_sequence)
            shutdown_thread.daemon = True
            shutdown_thread.start()
            
            return response
            
        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")
            
            try:
                self.cache_cleaner.clean_pycache_async()
            except:
                pass
                
            import os
            os._exit(0)

    def handle_get_constants(self):
        """Constants do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            constants = dados_data.get('constants', {})
            print(f"‚öôÔ∏è  Retornando constants")
            return constants
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar constants: {str(e)}")
            return {}

    def handle_get_machines(self):
        """Machines do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get('machines', [])
            print(f"üñ•Ô∏è  Retornando {len(machines)} m√°quinas")
            return machines
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar machines: {str(e)}")
            return []

    def handle_get_dados(self):
        """DADOS.json completo"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {"constants": {}, "machines": []})
            
            print("üìÅ Retornando DADOS.json")
            return dados_data
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados: {str(e)}")
            return {"constants": {}, "machines": []}

    def handle_get_backup(self):
        """BACKUP.json completo"""
        try:
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": [], "projetos": []})
            
            print("üíæ Retornando BACKUP.json")
            return backup_data
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar backup: {str(e)}")
            return {"obras": [], "projetos": []}

    def handle_get_backup_completo(self):
        """Obt√©m TODAS as obras do backup (sem filtro de sess√£o)"""
        try:
            print("üéØ [BACKUP COMPLETO] Obtendo TODAS as obras")
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return {"obras": []}
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_content = f.read()
                
            backup_data = json.loads(backup_content)
            obras = backup_data.get('obras', [])
            
            print(f"üìÅ Total de obras no backup: {len(obras)}")
            return {"obras": obras}
            
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_backup_completo: {str(e)}")
            return {"obras": []}

    def handle_post_dados(self, post_data):
        """Salva DADOS.json"""
        try:
            new_data = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            
            if self.file_utils.save_json_file(dados_file, new_data):
                print("üíæ DADOS.json salvo")
                return {"status": "success", "message": "Dados salvos"}
            else:
                return {"status": "error", "message": "Erro ao salvar dados"}
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar dados: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_backup(self, post_data):
        """Salva BACKUP.json"""
        try:
            new_data = json.loads(post_data)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            
            if self.file_utils.save_json_file(backup_file, new_data):
                print("üíæ BACKUP.json salvo")
                return {"status": "success", "message": "Backup salvo"}
            else:
                return {"status": "error", "message": "Erro ao salvar backup"}
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar backup: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_reload_page(self, post_data):
        """For√ßa recarregamento da p√°gina via Python"""
        try:
            data = json.loads(post_data)
            
            action = data.get('action', 'unknown')
            obra_id = data.get('obraId')
            obra_name = data.get('obraName')
            
            print(f"üîÑ [RECARREGAMENTO] A√ß√£o: {action}, Obra: {obra_name} (ID: {obra_id})")
            
            if action == 'undo':
                print(f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o da obra {obra_name} - mantendo na sess√£o")
            elif action == 'undo_no_data':
                print(f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o (dados insuficientes) - recarregando p√°gina")
            elif action.startswith('timeout'):
                print(f"‚è∞ Timeout completo - obra {obra_name} removida da sess√£o")
            
            return {
                "reload_required": True,
                "action": action,
                "obra_id": obra_id,
                "obra_name": obra_name,
                "message": "P√°gina ser√° recarregada",
                "reload_delay": 500
            }
            
            print(f"‚úÖ Comando de recarregamento enviado para o frontend")
                
        except Exception as e:
            print(f"‚ùå Erro no recarregamento: {str(e)}")
            return {
                "reload_required": True,
                "error": str(e),
                "message": "Recarregamento for√ßado devido a erro"
            }

            # ========== ROTA UNIVERSAL DELETE ==========
    
    def handle_delete_universal(self, path_array):
        """Deleta qualquer item no backup.json seguindo um caminho espec√≠fico"""
        try:
            # Carrega backup.json
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {})
            
            current = backup_data
            parent = None
            parent_key = None
            
            # Navega at√© o pen√∫ltimo n√≠vel (parent do item a ser deletado)
            for i, key in enumerate(path_array[:-1]):
                if key not in current:
                    return {
                        "success": False,
                        "error": f"Caminho inv√°lido: '{key}' n√£o encontrado",
                        "path": path_array
                    }
                parent = current
                parent_key = key
                current = current[key]
            
            # √öltimo elemento √© o ID a ser deletado
            item_id = path_array[-1]
            
            # Verifica se existe no n√≠vel atual
            if isinstance(current, list):
                # Para arrays, precisamos encontrar pelo ID
                item_index = -1
                for i, item in enumerate(current):
                    if isinstance(item, dict) and str(item.get('id')) == item_id:
                        item_index = i
                        break
                
                if item_index == -1:
                    return {
                        "success": False,
                        "error": f"Item '{item_id}' n√£o encontrado no array",
                        "path": path_array
                    }
                
                # Remove o item do array
                deleted_item = current.pop(item_index)
                print(f"‚úÖ Item deletado do array: {path_array}")
                
            elif isinstance(current, dict):
                # Para dicion√°rios, remover pela chave
                if item_id not in current:
                    return {
                        "success": False,
                        "error": f"Item '{item_id}' n√£o encontrado no dicion√°rio",
                        "path": path_array
                    }
                
                deleted_item = current.pop(item_id)
                print(f"‚úÖ Item deletado do dicion√°rio: {path_array}")
            
            else:
                return {
                    "success": False,
                    "error": f"Tipo inv√°lido no caminho: {type(current)}",
                    "path": path_array
                }
            
            # Salva backup atualizado
            if self.file_utils.save_json_file(backup_file, backup_data):
                # Se for uma obra, tamb√©m remove da sess√£o atual
                if len(path_array) == 2 and path_array[0] == 'obras':
                    obra_id = path_array[1]
                    self.sessions_manager.remove_obra(obra_id)
                    print(f"üóëÔ∏è  Obra {obra_id} tamb√©m removida da sess√£o")
                
                return {
                    "success": True,
                    "message": f"Item deletado com sucesso",
                    "path": path_array,
                    "deleted_id": item_id,
                    "item_type": "array" if isinstance(current, list) else "dict"
                }
            else:
                return {
                    "success": False,
                    "error": "Erro ao salvar backup.json",
                    "path": path_array
                }
            
        except Exception as e:
            print(f"‚ùå Erro ao deletar item universal: {e}")
            return {
                "success": False,
                "error": f"Erro ao deletar: {str(e)}",
                "path": path_array
            }

    def handle_delete_universal_from_handler(self, handler):
        """Wrapper para receber dados do handler HTTP"""
        try:
            content_length = int(handler.headers['Content-Length'])
            post_data = handler.rfile.read(content_length).decode('utf-8')
            data = json.loads(post_data)
            
            path = data.get('path')
            
            if not path or not isinstance(path, list):
                return {
                    "success": False,
                    "error": "Path inv√°lido. Deve ser um array (ex: ['obras', 'id_da_obra'])"
                }
            
            return self.handle_delete_universal(path)
            
        except json.JSONDecodeError:
            return {
                "success": False,
                "error": "JSON inv√°lido"
            }
        except Exception as e:
            print(f"‚ùå Erro em handle_delete_universal_from_handler: {e}")
            return {
                "success": False,
                "error": f"Erro no handler: {str(e)}"
            }
        
/* ==== IN√çCIO: main-folder/system-init.js ==== */
/**
 * system-init.js - INICIALIZA√á√ÉO DO SISTEMA
 * üéØ Carrega constantes, m√≥dulos e componentes principais
 * üî• AGORA COM: Sistemas de dele√ß√£o universal REAL via import
 */

// ‚úÖ IMPORTAR M√ìDULOS COM CAMINHOS CORRETOS
import { loadObrasFromServer } from '../data/adapters/obra-adapter.js';
import { getGeralCount } from '../data/adapters/session-adapter.js';
import { shutdownManual } from '../data/adapters/shutdown-adapter.js';
import EmpresaCadastroInline from '../data/builders/empresa-cadastro-inline.js';

// üî• NOVOS IMPORTS: Sistemas de dele√ß√£o universal REAL
import { ButtonDeleteUniversal } from '../features/filters/button-delete-universal.js';
import { ButtonModeManager } from '../features/filters/button-mode-manager.js';
import { UniversalDeleteModal } from '../features/filters/universal-delete-modal.js';

/**
 * Sistema de Shutdown Manual
 */
class ShutdownManager {
  constructor() {
    this.init();
  }

  init() {
    console.log('üîí Sistema de shutdown manual ativado');
    this.disableAutoShutdown();
    this.createShutdownButton();
  }

  disableAutoShutdown() {
    window.removeEventListener('beforeunload', this.autoShutdown);
    window.removeEventListener('unload', this.autoShutdown);
    window.removeEventListener('pagehide', this.autoShutdown);
  }

  createShutdownButton() {
    if (document.querySelector('.shutdown-btn')) return;

    const headerRight = document.querySelector('.header-right');
    if (headerRight) {
      const shutdownBtn = document.createElement('button');
      shutdownBtn.className = 'shutdown-btn';
      shutdownBtn.innerHTML = '‚èª';
      shutdownBtn.title = 'Encerrar Servidor';
      shutdownBtn.onclick = () => this.shutdownManual();

      headerRight.appendChild(shutdownBtn);
      console.log('‚úÖ Bot√£o de shutdown adicionado ao header');
    }
  }

  async shutdownManual() {
    if (confirm('Deseja realmente ENCERRAR o servidor?')) {
      try {
        console.log('üîÑ Executando shutdown COMPLETO...');
        await shutdownManual();
      } catch (error) {
        console.log('üîå Servidor encerrado ou n√£o responde:', error);
      }
    }
  }
}

/**
 * Carrega as constantes do sistema do servidor
 */
async function loadSystemConstants() {
  try {
    console.log("üîç Carregando constantes do sistema...");
    const response = await fetch(`/constants`);

    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }

    const constantsData = await response.json();
    window.systemConstants = constantsData;
    console.log("‚úÖ Constantes carregadas do JSON:", window.systemConstants);

    if (!window.systemConstants.VARIAVEL_PD || !window.systemConstants.VARIAVEL_PS) {
      throw new Error("Constantes essenciais n√£o encontradas no JSON");
    }

    return true;
  } catch (error) {
    console.error("‚ùå ERRO CR√çTICO ao carregar constantes:", error);
    throw error;
  }
}

/**
 * Carrega todos os m√≥dulos do sistema dinamicamente
 */
async function loadAllModules() {
  if (window.modulesLoaded) return;

  try {
    console.log("üì¶ Iniciando carregamento de m√≥dulos...");

    const modules = await Promise.all([
      import('../ui/interface.js'),
      import('../ui/components/edit.js'),
      import('../ui/components/status.js'),
      import('../ui/components/modal/modal.js'),
      import('../ui/components/modal/exit-modal.js'),
      import('../ui/helpers.js'),
      import('../features/managers/obra-manager.js'),
      import('../features/managers/project-manager.js'),
      import('../data/modules/rooms.js'),
      import('../data/modules/climatizacao.js'),
      import('../data/modules/acessorios.js'),
      import('../data/modules/machines/machines-core.js'),
      import('../data/modules/machines/capacity-calculator.js'),
      import('../features/calculations/air-flow.js'),
      import('../features/calculations/calculations-core.js'),
      import('../data/utils/id-generator.js'),
      import('../data/utils/data-utils.js'),
      import('../data/builders/ui-builders.js'),
      import('../data/builders/data-builders.js')
    ]);

    const [
      interfaceModule,
      editModule,
      statusModule,
      modalModule,
      modalExitModule,
      helpersModule,
      obraManagerModule,
      projectManagerModule,
      roomsModule,
      climatizationModule,
      configuracaoModule,
      machinesCoreModule,
      capacityCalculatorModule,
      airFlowModule,
      calculationsCoreModule,
      idGeneratorModule,
      dataUtilsModule,
      uiBuildersModule,
      dataBuildersModule
    ] = modules;

    const allFunctions = {
      toggleSection: interfaceModule.toggleSection,
      toggleSubsection: interfaceModule.toggleSubsection,
      toggleObra: interfaceModule.toggleObra,
      toggleProject: interfaceModule.toggleProject,
      toggleRoom: interfaceModule.toggleRoom,
      collapseElement: helpersModule.collapseElement,
      expandElement: helpersModule.expandElement,
      showSystemStatus: statusModule.showSystemStatus,

      addNewObra: obraManagerModule.addNewObra,
      saveOrUpdateObra: obraManagerModule.saveObra,
      verifyObraData: obraManagerModule.verifyObraData,
      deleteObra: obraManagerModule.deleteObra,
      saveObra: obraManagerModule.saveObra,
      fetchObras: obraManagerModule.fetchObras,
      supportFrom_saveObra: obraManagerModule.supportFrom_saveObra,
      atualizarObra: obraManagerModule.atualizarObra,

      addNewProjectToObra: projectManagerModule.addNewProjectToObra,
      deleteProject: projectManagerModule.deleteProject,

      addNewRoom: roomsModule.addNewRoom,
      deleteRoom: roomsModule.deleteRoom,
      createEmptyRoom: roomsModule.createEmptyRoom,

      buildClimatizationSection: climatizationModule.buildClimatizationSection,
      buildMachinesSection: machinesCoreModule.buildMachinesSection,
      buildAccessoriesSection: configuracaoModule.buildAccessoriesSection,

      calculateVazaoArAndThermalGains: airFlowModule.calculateVazaoArAndThermalGains,
      calculateVazaoArAndThermalGainsDebounced: calculationsCoreModule.calculateVazaoArAndThermalGainsDebounced,

      calculateCapacitySolution: capacityCalculatorModule.calculateCapacitySolution,
      updateBackupConfiguration: capacityCalculatorModule.updateBackupConfiguration,
      toggleOption: machinesCoreModule.toggleOption,
      addMachine: machinesCoreModule.addMachine,
      deleteMachine: machinesCoreModule.deleteMachine,

      makeEditable: editModule.makeEditable,

      ensureStringId: idGeneratorModule.ensureStringId,
      getNextObraNumber: dataUtilsModule.getNextObraNumber,
      getNextProjectNumber: dataUtilsModule.getNextProjectNumber,
      getNextRoomNumber: dataUtilsModule.getNextRoomNumber,

      showConfirmationModal: modalModule.showConfirmationModal,
      closeConfirmationModal: modalModule.closeConfirmationModal,
      undoDeletion: modalModule.undoDeletion,

      removeEmptyObraMessage: helpersModule.removeEmptyObraMessage,
      showEmptyObraMessageIfNeeded: helpersModule.showEmptyObraMessageIfNeeded,
      removeEmptyProjectMessage: helpersModule.removeEmptyProjectMessage,
      showEmptyProjectMessageIfNeeded: helpersModule.showEmptyProjectMessageIfNeeded,

      populateObraData: uiBuildersModule.populateObraData,
      renderObraFromData: uiBuildersModule.renderObraFromData,
      renderProjectFromData: uiBuildersModule.renderProjectFromData,
      renderRoomFromData: uiBuildersModule.renderRoomFromData,
      fillMachinesData: uiBuildersModule.fillMachinesData,
      fillClimatizationInputs: uiBuildersModule.fillClimatizationInputs,
      fillThermalGainsData: uiBuildersModule.fillThermalGainsData,
      fillCapacityData: uiBuildersModule.fillCapacityData,
      fillAccessoriesData: uiBuildersModule.fillAccessoriesData,
      ensureAllRoomSections: uiBuildersModule.ensureAllRoomSections,
      ensureMachinesSection: uiBuildersModule.ensureMachinesSection,
      populateMachineData: uiBuildersModule.populateMachineData,

      buildObraData: dataBuildersModule.buildObraData,
      buildProjectData: dataBuildersModule.buildProjectData,
      extractRoomData: dataBuildersModule.extractRoomData,
      extractMachinesData: dataBuildersModule.extractMachinesData,
      extractThermalGainsData: dataBuildersModule.extractThermalGainsData,
      extractClimatizationInputs: dataBuildersModule.extractClimatizationInputs,
      extractCapacityData: dataBuildersModule.extractCapacityData,
      extractAccessoriesData: dataBuildersModule.extractAccessoriesData,

      loadObrasFromServer: loadObrasFromServer
    };

    window.systemFunctions = {};

    Object.keys(allFunctions).forEach(funcName => {
      if (typeof allFunctions[funcName] === 'function') {
        window[funcName] = allFunctions[funcName];
        window.systemFunctions[funcName] = allFunctions[funcName];
        console.log(`‚úÖ ${funcName} atribu√≠da ao window e systemFunctions`);
      }
    });

    window.modulesLoaded = true;
    console.log("‚úÖ Todos os m√≥dulos foram carregados com sucesso");
    return true;

  } catch (error) {
    console.error("‚ùå Erro ao carregar m√≥dulos:", error);
    throw error;
  }
}

/**
 * Inicializa o sistema de cadastro de empresas
 */
async function initializeEmpresaCadastro() {
  try {
    console.log("üè¢ Inicializando sistema de cadastro de empresas...");

    await new Promise(resolve => setTimeout(resolve, 500));

    window.empresaCadastro = new EmpresaCadastroInline();

    console.log("‚úÖ Sistema de cadastro de empresas inicializado");

    const spansCadastro = document.querySelectorAll('.projetc-header-record.very-dark span');
    console.log(`üîç Encontrados ${spansCadastro.length} elementos de cadastro de empresas`);

    return true;
  } catch (error) {
    console.error("‚ùå Erro ao inicializar sistema de cadastro de empresas:", error);
    throw error;
  }
}

/**
 * üî• Configura integra√ß√£o com FilterSystem
 */
function setupFilterSystemIntegration() {
  console.log("üîß [SYSTEM-INIT] Configurando integra√ß√£o com FilterSystem...");

  if (!window.FilterSystem) {
    console.warn("‚ö†Ô∏è [SYSTEM-INIT] FilterSystem n√£o dispon√≠vel para integra√ß√£o");
    return;
  }

  if (!window.ButtonModeManager) {
    console.error("‚ùå [SYSTEM-INIT] ButtonModeManager n√£o dispon√≠vel para integra√ß√£o");
    return;
  }

  const originalHandleToggleChange = window.FilterSystem.handleFilterToggleChange;

  if (typeof originalHandleToggleChange === 'function') {
    window.FilterSystem.handleFilterToggleChange = function (isActive) {
      console.log(`üéõÔ∏è [INTEGRA√á√ÉO] Filtro ${isActive ? 'ATIVADO' : 'DESATIVADO'}`);

      originalHandleToggleChange.call(this, isActive);

      if (isActive) {
        window.ButtonModeManager.enableFilterMode();
      } else {
        window.ButtonModeManager.disableFilterMode();
      }

      if (window.ButtonModeManager && typeof window.ButtonModeManager.applyMode === 'function') {
        window.ButtonModeManager.applyMode();
      }
    };

    console.log("‚úÖ [SYSTEM-INIT] Integra√ß√£o FilterSystem-ButtonModeManager configurada");
  }
}

/**
 * üî• Aplica configura√ß√£o inicial dos bot√µes ap√≥s carregar obras
 */
function setupInitialButtonConfiguration() {
  console.log("üîß [SYSTEM-INIT] Configurando bot√µes inicialmente...");

  if (window.ButtonDeleteUniversal && typeof window.ButtonDeleteUniversal.setupAllDeleteButtons === 'function') {
    setTimeout(() => {
      const buttonsConfigured = window.ButtonDeleteUniversal.setupAllDeleteButtons();
      console.log(`‚úÖ [SYSTEM-INIT] ${buttonsConfigured} bot√µes de dele√ß√£o REAL configurados`);
    }, 500);
  }

  if (window.ButtonModeManager && typeof window.ButtonModeManager.applyMode === 'function') {
    setTimeout(() => {
      window.ButtonModeManager.applyMode();
      console.log("‚úÖ [SYSTEM-INIT] Modo inicial aplicado aos bot√µes");
    }, 600);
  }
}

/**
 * üî• Configura dele√ß√£o universal para substituir sistema antigo
 */
function setupUniversalDeletionOverride() {
  console.log("üîÑ [SYSTEM-INIT] Configurando sobrescrita do sistema de dele√ß√£o...");

  const handleUniversalDeletion = async (itemType, itemName, itemId, additionalIds = {}) => {
    console.log(`üîÑ [UNIVERSAL-DELETE] Iniciando dele√ß√£o para ${itemType}: ${itemName} (ID: ${itemId})`);

    const confirmed = await window.UniversalDeleteModal.confirmDelete(
      itemType,
      itemName,
      `ID: ${itemId}`
    );

    if (!confirmed) {
      console.log(`‚ùå Dele√ß√£o de ${itemType} cancelada pelo usu√°rio`);
      return false;
    }

    // üî• CORRE√á√ÉO: Determinar path correto baseado na estrutura real do backup.json
    let pathArray = null;
    
    switch (itemType.toLowerCase()) {
      case 'obra':
        // Path: ['obras', itemId]
        pathArray = ['obras', itemId];
        break;
      case 'projeto':
        // Para projeto, precisamos encontrar na estrutura da obra
        // Path: ['obras', obraId, 'projetos', itemId]
        const obraId = additionalIds.obraId;
        if (!obraId) {
          console.error(`‚ùå Obra ID n√£o fornecido para deletar projeto ${itemId}`);
          return false;
        }
        pathArray = ['obras', obraId, 'projetos', itemId];
        break;
      case 'sala':
        // Para sala, precisamos navegar: obra ‚Üí projeto ‚Üí sala
        // Path: ['obras', obraId, 'projetos', projectId, 'salas', itemId]
        const salaObraId = additionalIds.obraId;
        const salaProjectId = additionalIds.projectId;
        if (!salaObraId || !salaProjectId) {
          console.error(`‚ùå IDs necess√°rios n√£o fornecidos para deletar sala ${itemId}`);
          return false;
        }
        pathArray = ['obras', salaObraId, 'projetos', salaProjectId, 'salas', itemId];
        break;
      case 'maquina':
        // Para m√°quina, √© mais complexo - m√°quinas est√£o dentro de salas
        // Path: ['obras', obraId, 'projetos', projectId, 'salas', roomId, 'maquinas', machineIndex]
        const machineObraId = additionalIds.obraId;
        const machineProjectId = additionalIds.projectId;
        const machineRoomId = additionalIds.roomId;
        
        if (!machineObraId || !machineProjectId || !machineRoomId) {
          console.error(`‚ùå IDs necess√°rios n√£o fornecidos para deletar m√°quina ${itemId}`);
          return false;
        }
        
        // Extrair √≠ndice da m√°quina do machineId
        const machineIndexMatch = itemId.match(/maquina_(\d+)$/);
        const machineIndex = machineIndexMatch ? parseInt(machineIndexMatch[1]) : 0;
        
        // Encontrar a posi√ß√£o real da m√°quina na sala
        const realMachineIndex = await findMachineIndexInRoom(machineObraId, machineProjectId, machineRoomId, itemId);
        
        pathArray = ['obras', machineObraId, 'projetos', machineProjectId, 'salas', machineRoomId, 'maquinas', realMachineIndex];
        break;
    }

    if (!pathArray) {
      console.error(`‚ùå N√£o foi poss√≠vel determinar path para ${itemType}`);
      return false;
    }

    console.log(`üîß Path para dele√ß√£o:`, pathArray);

    // Executar dele√ß√£o via API
    const response = await fetch('/api/delete', {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        path: pathArray,
        itemType: itemType,
        itemName: itemName,
        timestamp: new Date().toISOString()
      })
    });

    const result = await response.json();

    if (result.success) {
      console.log(`‚úÖ ${itemType} "${itemName}" deletado com sucesso`);

      if (window.ButtonDeleteUniversal && window.ButtonDeleteUniversal.showToast) {
        window.ButtonDeleteUniversal.showToast(`${itemType} "${itemName}" deletado permanentemente`, 'success');
      }

      removeElementFromDOM(itemType, itemId, additionalIds);

      if (itemType === 'obra') {
        setTimeout(() => {
          if (window.FilterSystem) {
            window.FilterSystem.reloadObras();
          }
        }, 1500);
      }

      return true;
    } else {
      console.error(`‚ùå Erro ao deletar ${itemType}:`, result.error);
      
      if (window.ButtonDeleteUniversal && window.ButtonDeleteUniversal.showToast) {
        window.ButtonDeleteUniversal.showToast(`Erro ao deletar ${itemType}: ${result.error}`, 'error');
      }

      return false;
    }
  };

  /**
   * Encontra o √≠ndice real da m√°quina na estrutura da sala
   */
  const findMachineIndexInRoom = async (obraId, projectId, roomId, machineId) => {
    try {
      // Buscar a obra completa para encontrar a posi√ß√£o da m√°quina
      const response = await fetch(`/obras/${obraId}`);
      if (!response.ok) {
        console.warn(`‚ö†Ô∏è N√£o foi poss√≠vel buscar obra para encontrar √≠ndice da m√°quina`);
        return 0; // Fallback para √≠ndice 0
      }
      
      const obra = await response.json();
      if (!obra || !obra.projetos) return 0;
      
      // Encontrar o projeto
      const projeto = obra.projetos.find(p => p.id === projectId);
      if (!projeto || !projeto.salas) return 0;
      
      // Encontrar a sala
      const sala = projeto.salas.find(s => s.id === roomId);
      if (!sala || !sala.maquinas) return 0;
      
      // Encontrar o √≠ndice da m√°quina
      const machineIndex = sala.maquinas.findIndex(m => {
        // Comparar por ID ou por nome se o ID n√£o estiver dispon√≠vel
        return m.id === machineId || 
               (m.nome && machineId.includes(m.nome)) ||
               (m.id && m.id.includes(machineId));
      });
      
      return machineIndex !== -1 ? machineIndex : 0;
      
    } catch (error) {
      console.error(`‚ùå Erro ao encontrar √≠ndice da m√°quina:`, error);
      return 0;
    }
  };

  /**
   * Remove elemento do DOM baseado no tipo e ID
   */
  const removeElementFromDOM = (itemType, itemId, additionalIds = {}) => {
    console.log(`üóëÔ∏è Removendo ${itemType} ${itemId} do DOM...`);

    let element = null;

    switch (itemType.toLowerCase()) {
      case 'obra':
        element = document.querySelector(`[data-obra-id="${itemId}"]`);
        if (!element) element = document.getElementById(itemId);
        break;
      case 'projeto':
        element = document.getElementById(itemId);
        if (!element) {
          // Tentar encontrar pelo data attribute
          element = document.querySelector(`[data-project-id="${itemId}"]`);
        }
        break;
      case 'sala':
        element = document.getElementById(itemId);
        if (!element) {
          element = document.querySelector(`[data-room-id="${itemId}"]`);
        }
        break;
      case 'maquina':
        element = document.getElementById(itemId);
        if (!element) {
          element = document.querySelector(`[data-machine-id="${itemId}"]`);
        }
        break;
    }

    if (element) {
      // Efeito visual de remo√ß√£o
      element.style.transition = 'all 0.5s ease';
      element.style.opacity = '0';
      element.style.transform = 'translateX(-100%)';
      element.style.maxHeight = '0';
      element.style.overflow = 'hidden';
      element.style.margin = '0';
      element.style.padding = '0';

      setTimeout(() => {
        if (element.parentNode) {
          element.remove();
          console.log(`‚úÖ Elemento ${itemType} removido do DOM`);
        }
      }, 500);
    } else {
      console.warn(`‚ö†Ô∏è N√£o encontrou elemento ${itemType} ${itemId} no DOM`);
      
      // Se for sala, projeto ou m√°quina, remover o container pai
      if (itemType === 'sala' && additionalIds.projectId) {
        const projectElement = document.getElementById(additionalIds.projectId);
        if (projectElement) {
          const roomElements = projectElement.querySelectorAll('[data-room-id]');
          if (roomElements.length === 0) {
            // Se n√£o tem mais salas, remover o projeto
            console.log(`üóëÔ∏è Projeto ${additionalIds.projectId} n√£o tem mais salas, removendo...`);
            projectElement.remove();
          }
        }
      }
    }
  };

  // üî• SOBRESCREVER FUN√á√ïES ORIGINAIS
  if (window.deleteObra) {
    window.deleteObra = async function (obraName, obraId) {
      return handleUniversalDeletion('obra', obraName, obraId);
    };
    console.log("‚úÖ Fun√ß√£o deleteObra sobrescrita para dele√ß√£o universal");
  }

  if (window.deleteProject) {
    window.deleteProject = async function (obraId, projectId) {
      // Extrair nome do projeto do DOM
      const projectElement = document.getElementById(projectId);
      let projectName = `Projeto ${projectId}`;

      if (projectElement) {
        const header = projectElement.querySelector('.project-header h3');
        if (header) {
          projectName = header.textContent || projectName;
        }
      }

      return handleUniversalDeletion('projeto', projectName, projectId, { obraId });
    };
    console.log("‚úÖ Fun√ß√£o deleteProject sobrescrita para dele√ß√£o universal");
  }

  if (window.deleteRoom) {
    window.deleteRoom = async function (obraId, projectId, roomId) {
      // Extrair nome da sala do DOM
      const roomElement = document.getElementById(roomId);
      let roomName = `Sala ${roomId}`;

      if (roomElement) {
        const header = roomElement.querySelector('.room-header h4');
        if (header) {
          roomName = header.textContent || roomName;
        }
      }

      return handleUniversalDeletion('sala', roomName, roomId, { obraId, projectId });
    };
    console.log("‚úÖ Fun√ß√£o deleteRoom sobrescrita para dele√ß√£o universal");
  }

  if (window.deleteMachine) {
    window.deleteMachine = async function (machineId) {
      // Extrair nome da m√°quina do DOM
      const machineElement = document.getElementById(machineId);
      let machineName = `M√°quina ${machineId}`;

      if (machineElement) {
        const nameElement = machineElement.querySelector('.machine-name');
        if (nameElement) {
          machineName = nameElement.textContent || machineName;
        }
      }

      // Extrair IDs da estrutura do machineId
      const parts = machineId.split('_');
      if (parts.length >= 5) {
        const obraId = `obra_${parts[1]}`;
        const projectId = `${obraId}_proj_${parts[3]}_${parts[4]}`;
        const roomId = `${projectId}_sala_${parts[6]}_${parts[7]}`;

        return handleUniversalDeletion('maquina', machineName, machineId, {
          obraId,
          projectId,
          roomId
        });
      }
      
      console.error(`‚ùå Estrutura inv√°lida de machineId: ${machineId}`);
      return false;
    };
    console.log("‚úÖ Fun√ß√£o deleteMachine sobrescrita para dele√ß√£o universal");
  }

  console.log("‚úÖ Sistema de dele√ß√£o universal configurado para substituir fun√ß√µes originais");
}

/**
 * Inicializa o sistema completo
 */
export async function initializeSystem() {
  try {
    console.log("üöÄ [SYSTEM-INIT] Iniciando sistema completo...");
    
    window.systemLoadingStart = Date.now();

    console.log("üîß [SYSTEM-INIT] Criando sistemas de dele√ß√£o...");

    window.ButtonDeleteUniversal = new ButtonDeleteUniversal();
    window.ButtonModeManager = new ButtonModeManager();
    window.UniversalDeleteModal = UniversalDeleteModal;

    console.log("‚úÖ [SYSTEM-INIT] Sistemas de dele√ß√£o preparados:", {
      ButtonDeleteUniversal: !!window.ButtonDeleteUniversal,
      ButtonModeManager: !!window.ButtonModeManager,
      UniversalDeleteModal: !!window.UniversalDeleteModal
    });

    console.log("üîí [SYSTEM-INIT] Inicializando shutdown manager...");
    window.shutdownManager = new ShutdownManager();

    console.log("üìä [SYSTEM-INIT] Carregando constantes do sistema...");
    await loadSystemConstants();
    console.log("‚úÖ [SYSTEM-INIT] Constantes carregadas");

    console.log("üì¶ [SYSTEM-INIT] Carregando m√≥dulos do sistema...");
    await loadAllModules();
    console.log("‚úÖ [SYSTEM-INIT] M√≥dulos carregados");

    console.log("üè¢ [SYSTEM-INIT] Inicializando sistema de empresas...");
    await initializeEmpresaCadastro();
    console.log("‚úÖ [SYSTEM-INIT] Sistema de empresas inicializado");

    console.log("üîß [SYSTEM-INIT] Inicializando ButtonModeManager...");
    await window.ButtonModeManager.initialize();
    console.log("‚úÖ [SYSTEM-INIT] ButtonModeManager inicializado");

    console.log("üîÑ [SYSTEM-INIT] Configurando sistema de dele√ß√£o universal...");
    setupUniversalDeletionOverride();

    console.log("üîó [SYSTEM-INIT] Configurando integra√ß√µes...");
    setupFilterSystemIntegration();

    console.log("üîß [SYSTEM-INIT] Agendando configura√ß√£o inicial dos bot√µes...");
    setupInitialButtonConfiguration();

    console.log("üîó [SYSTEM-INIT] Configurando listeners de carregamento...");

    const observer = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
          const hasObras = Array.from(mutation.addedNodes).some(node =>
            node.nodeType === 1 &&
            (node.classList?.contains('obra-wrapper') ||
              node.querySelector?.('.obra-wrapper'))
          );

          if (hasObras) {
            console.log("üëÄ [SYSTEM-INIT] Novas obras detectadas, reconfigurando bot√µes...");
            setTimeout(() => {
              window.ButtonModeManager.applyMode();
              window.ButtonDeleteUniversal.setupAllDeleteButtons();
            }, 500);
          }
        }
      });
    });

    const projectsContainer = document.getElementById('projects-container');
    if (projectsContainer) {
      observer.observe(projectsContainer, { childList: true, subtree: true });
      console.log("üîç [SYSTEM-INIT] Observer configurado para projetos-container");
    }

    setTimeout(() => {
      console.log("‚è∞ [SYSTEM-INIT] For√ßando configura√ß√£o de bot√µes");
      window.ButtonDeleteUniversal.setupAllDeleteButtons();
    }, 3000);

    const loadingTime = Date.now() - window.systemLoadingStart;
    window.systemLoaded = true;
    window.systemLoadTime = loadingTime;
    
    console.log(`üéâ [SYSTEM-INIT] Sistema completamente inicializado em ${loadingTime}ms!`);
    
    const event = new CustomEvent('systemInitialized', { 
      detail: { 
        time: loadingTime,
        timestamp: new Date().toISOString(),
        modules: window.modulesLoaded,
        constants: !!window.systemConstants
      }
    });
    document.dispatchEvent(event);
    
    return true;

  } catch (error) {
    console.error("‚ùå [SYSTEM-INIT] ERRO CR√çTICO na inicializa√ß√£o do sistema:", error);
    throw error;
  }
}
/* ==== FIM: main-folder/system-init.js ==== */
