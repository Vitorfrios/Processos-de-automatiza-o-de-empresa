
/* ==== IN√çCIO: handlers/word_handler.py ==== */
# servidor_modules/handlers/word_handler.py
"""
word_handler.py - Manipula√ß√£o de documentos Word
"""

import json
import os
import tempfile
from pathlib import Path
from datetime import datetime
from docxtpl import DocxTemplate
import traceback
from http.server import BaseHTTPRequestHandler
from typing import Dict, List, Any, Optional

class WordHandler:
    """Handler para gera√ß√£o de documentos Word"""
    
    def __init__(self, project_root, file_utils):
        self.project_root = project_root
        self.file_utils = file_utils
        self.templates_dir = project_root / "word_templates"
        self.ensure_templates_dir()
        
    def ensure_templates_dir(self):
        """Garante que a pasta de templates existe"""
        self.templates_dir.mkdir(exist_ok=True)
        
        # Cria templates padr√£o se n√£o existirem
        default_templates = {
            "proposta_comercial_template.docx": {
                "name": "Proposta Comercial",
                "description": "Documento comercial com valores, condi√ß√µes de pagamento"
            },
            "proposta_tecnica_template.docx": {
                "name": "Proposta T√©cnica", 
                "description": "Documento t√©cnico com especifica√ß√µes e c√°lculos"
            }
        }
        
        # Cria arquivos de placeholder se n√£o existirem
        for filename, info in default_templates.items():
            template_path = self.templates_dir / filename
            if not template_path.exists():
                self.create_placeholder_template(template_path, info["name"])
                
    def create_placeholder_template(self, template_path, template_name):
        """Cria um template placeholder se n√£o existir"""
        try:
            from docx import Document
            from docx.shared import Pt, Inches, RGBColor
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            doc = Document()
            
            # T√≠tulo
            title = doc.add_heading(f'Template: {template_name}', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Informa√ß√µes
            doc.add_paragraph(f'Template criado em: {datetime.now().strftime("%d/%m/%Y")}')
            doc.add_paragraph('Este √© um template placeholder. Substitua com seu template real.')
            doc.add_paragraph('Vari√°veis dispon√≠veis:')
            
            # Vari√°veis exemplo para Proposta Comercial
            if "comercial" in template_name.lower():
                vars_list = doc.add_paragraph()
                vars_list.add_run('‚Ä¢ {{data_emissao}} - Data de emiss√£o\n').bold = True
                vars_list.add_run('‚Ä¢ {{empresa_nome}} - Nome da empresa cliente\n')
                vars_list.add_run('‚Ä¢ {{obra_nome}} - Nome da obra\n')
                vars_list.add_run('‚Ä¢ {{cliente_final}} - Nome do cliente final\n')
                vars_list.add_run('‚Ä¢ {{valor_total_projeto}} - Valor total do projeto\n')
                vars_list.add_run('‚Ä¢ {{total_global}} - Valor total global\n')
                vars_list.add_run('‚Ä¢ {{aplicacoes_groups}} - Lista de aplica√ß√µes com m√°quinas, dutos e acess√≥rios\n')
                vars_list.add_run('‚Ä¢ {{engenharia_valor}} - Valor da engenharia\n')
                vars_list.add_run('‚Ä¢ {{engenharia_descricao}} - Descri√ß√£o da engenharia\n')
                vars_list.add_run('‚Ä¢ {{adicionais}} - Lista de servi√ßos adicionais\n')
            # Vari√°veis exemplo para Proposta T√©cnica
            elif "tecnica" in template_name.lower():
                vars_list = doc.add_paragraph()
                vars_list.add_run('‚Ä¢ {{data_emissao}} - Data de emiss√£o\n').bold = True
                vars_list.add_run('‚Ä¢ {{empresa_nome}} - Nome da empresa\n')
                vars_list.add_run('‚Ä¢ {{obra_nome}} - Nome da obra\n')
                vars_list.add_run('‚Ä¢ {{cliente_final}} - Cliente final\n')
                vars_list.add_run('‚Ä¢ {{normas_aplicaveis}} - Normas t√©cnicas aplicadas\n')
                vars_list.add_run('‚Ä¢ {{escopo_trabalho}} - Escopo do trabalho\n')
                vars_list.add_run('‚Ä¢ {{memoria_calculo}} - Mem√≥ria de c√°lculo\n')
                vars_list.add_run('‚Ä¢ {{especificacoes_tecnicas}} - Especifica√ß√µes t√©cnicas\n')
            
            doc.save(str(template_path))
            print(f"‚úÖ Template placeholder criado: {template_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar template placeholder: {e}")
            return False
    
    def get_available_templates(self):
        """Retorna templates dispon√≠veis"""
        templates = []
        for file in self.templates_dir.glob("*.docx"):
            templates.append({
                "filename": file.name,
                "path": str(file),
                "size": file.stat().st_size,
                "modified": datetime.fromtimestamp(file.stat().st_mtime).isoformat()
            })
        return templates
    
    def get_obra_data(self, obra_id):
        """Obt√©m dados completos de uma obra"""
        try:
            backup_file = self.project_root / "json" / "backup.json"
            if not backup_file.exists():
                return None
                
            with open(backup_file, "r", encoding="utf-8") as f:
                backup_data = json.load(f)
            
            obras = backup_data.get("obras", [])
            for obra in obras:
                if str(obra.get("id")) == obra_id:
                    return obra
            return None
        except Exception as e:
            print(f"‚ùå Erro ao buscar obra: {e}")
            return None
    
    def generate_context_for_pc(self, obra_id: str) -> Optional[Dict]:
        """Gera contexto para Proposta Comercial - M√âTODO LEGADO"""
        try:
            # Importar o gerador avan√ßado
            from servidor_modules.generators.wordPC_generator import WordPCGenerator
            
            # Criar inst√¢ncia do gerador
            pc_generator = WordPCGenerator(self.project_root, self.file_utils)
            
            # Usar o m√©todo do gerador
            return pc_generator.generate_context_for_pc(obra_id)
                
        except Exception as e:
            print(f"‚ùå Erro em generate_context_for_pc: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def generate_proposta_comercial(self, obra_id: str, template_path: Path) -> Optional[str]:
        """Gera documento de Proposta Comercial com tratamento de erros melhorado"""
        try:
            # Verificar template
            if not template_path.exists():
                print(f"‚ùå Template n√£o encontrado: {template_path}")
                return None
            
            # Verificar se √© um arquivo v√°lido
            if template_path.stat().st_size == 0:
                print(f"‚ùå Template est√° vazio: {template_path}")
                return None
            
            # Usar o gerador avan√ßado
            from servidor_modules.generators.wordPC_generator import WordPCGenerator
            pc_generator = WordPCGenerator(self.project_root, self.file_utils)
            
            # Gerar contexto
            context = pc_generator.generate_context_for_pc(obra_id)
            if not context:
                raise ValueError("N√£o foi poss√≠vel gerar contexto para a PC")
            
            print(f"üìä Contexto gerado com {len(context.get('aplicacoes_groups', []))} aplica√ß√µes")
            
            # Testar contexto b√°sico primeiro
            test_context = {
                "data_emissao": context.get("data_emissao", ""),
                "empresa_nome": context.get("empresa_nome", ""),
                "obra_nome": context.get("obra_nome", ""),
                "cliente_final": context.get("cliente_final", ""),
                "projeto_nome": context.get("projeto_nome", ""),
                "aplicacoes_groups": [],
                "engenharia_valor": context.get("engenharia_valor", ""),
                "engenharia_descricao": context.get("engenharia_descricao", ""),
                "tem_adicionais": False,
                "adicionais": [],
                "valor_total_projeto": context.get("valor_total_projeto", ""),
                "total_global": context.get("total_global", "")
            }
            
            print("üß™ Testando template com contexto b√°sico...")
            
            try:
                doc = DocxTemplate(str(template_path))
                doc.render(test_context)
                print("‚úÖ Template b√°sico funciona!")
            except Exception as template_error:
                print(f"‚ùå Erro no template: {template_error}")
            
            # Agora renderizar com contexto completo
            print("üîÑ Renderizando com contexto completo...")
            doc = DocxTemplate(str(template_path))
            doc.render(context)
            
            # Salvar arquivo tempor√°rio
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as tmp:
                output_path = tmp.name
                doc.save(output_path)
            
            print(f"‚úÖ Proposta Comercial gerada: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar Proposta Comercial: {e}")
            traceback.print_exc()
            return None
    
    def generate_proposta_tecnica_avancada(self, obra_id):
        """Gera proposta t√©cnica usando m√©todo gen√©rico por enquanto"""
        try:
            # Para proposta t√©cnica, podemos usar o m√©todo existente
            # ou criar uma implementa√ß√£o espec√≠fica
            template_path = self.templates_dir / "proposta_tecnica_template.docx"
            if not template_path.exists():
                return None, None, "Template de proposta t√©cnica n√£o encontrado"
            
            # Obter dados da obra
            obra_data = self.get_obra_data(obra_id)
            if not obra_data:
                return None, None, "Obra n√£o encontrada"
            
            # Gerar contexto
            context = self.generate_context_for_obra(obra_data, "tecnica")
            
            # Carregar e preencher template
            from docxtpl import DocxTemplate
            doc = DocxTemplate(str(template_path))
            doc.render(context)
            
            # Salvar arquivo tempor√°rio
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as tmp:
                output_path = tmp.name
                doc.save(output_path)
            
            # Gerar nome do arquivo no formato PT_Obra_sigla_numero_data
            filename = self.generate_pt_filename(obra_data)
            
            return output_path, filename, None
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar proposta t√©cnica: {e}")
            import traceback
            traceback.print_exc()
            return None, None, str(e)
    
    def generate_context_for_obra(self, obra_data, template_type="comercial"):
        """Gera contexto para preenchimento do template (m√©todo gen√©rico - mantido para compatibilidade)"""
        try:
            # Dados b√°sicos da obra
            obra_nome = obra_data.get("nome", "Obra n√£o especificada")
            cliente = obra_data.get("cliente", {})
            cliente_nome = cliente.get("nome", "Cliente n√£o especificado") if isinstance(cliente, dict) else "Cliente n√£o especificado"
            
            # Endere√ßo
            endereco_completo = ""
            if isinstance(cliente, dict):
                endereco_parts = []
                if cliente.get("endereco"):
                    endereco_parts.append(cliente["endereco"])
                if cliente.get("bairro"):
                    endereco_parts.append(cliente["bairro"])
                if cliente.get("cidade"):
                    endereco_parts.append(cliente["cidade"])
                if cliente.get("estado"):
                    endereco_parts.append(cliente["estado"])
                if cliente.get("cep"):
                    endereco_parts.append(f"CEP: {cliente['cep']}")
                endereco_completo = ", ".join(filter(None, endereco_parts))
            
            # Formatar valores
            def formatar_valor(valor):
                return f"R$ {valor:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
            
            # Data atual - usar data de gera√ß√£o, n√£o data de cadastro
            from datetime import datetime
            import pytz
            
            try:
                tz = pytz.timezone('America/Sao_Paulo')
                data_atual = datetime.now(tz)
            except:
                data_atual = datetime.now()
            
            # Contexto base
            context = {
                "obra_nome": obra_nome,
                "cliente_nome": cliente_nome,
                "endereco": endereco_completo,
                "data_emissao": data_atual.strftime("%d/%m/%Y"),  # Data atual
                "data_emissao_completa": data_atual.strftime("%d de %B de %Y"),
                "hora_emissao": data_atual.strftime("%H:%M"),
            }
            
            # Adicionar dados espec√≠ficos por tipo de template
            if template_type == "comercial":
                context.update({
                    "titulo_documento": "PROPOSTA COMERCIAL",
                    "tipo_proposta": "Comercial",
                    "condicoes_pagamento": "50% na assinatura do contrato, 50% na entrega",
                    "validade_proposta": "10 dias √∫teis",
                    "garantia": "12 meses",
                    "prazo_entrega": "60 dias √∫teis",
                })
            elif template_type == "tecnica":
                context.update({
                    "titulo_documento": "PROPOSTA T√âCNICA",
                    "tipo_proposta": "T√©cnica",
                    "normas_aplicaveis": "NBR 16401, NBR 7256, NBR 14606",
                    "escopo_trabalho": "Fornecimento e instala√ß√£o completa do sistema de climatiza√ß√£o",
                    "memoria_calculo": "C√°lculos realizados conforme normas t√©cnicas vigentes",
                    "especificacoes_tecnicas": "Todos os equipamentos conforme cat√°logo t√©cnico",
                })
            
            return context
        except Exception as e:
            print(f"‚ùå Erro ao gerar contexto: {e}")
            return {}
        
    def generate_proposta_comercial_avancada(self, obra_id):
        """Gera proposta comercial usando o gerador avan√ßado"""
        try:
            # Importar o gerador avan√ßado
            from servidor_modules.generators.wordPC_generator import WordPCGenerator
            
            # Criar inst√¢ncia do gerador
            pc_generator = WordPCGenerator(self.project_root, self.file_utils)
            
            # Localizar template
            template_path = self.templates_dir / "proposta_comercial_template.docx"
            if not template_path.exists():
                # Tentar encontrar qualquer template .docx
                docx_files = list(self.templates_dir.glob("*.docx"))
                if docx_files:
                    template_path = docx_files[0]
                else:
                    return None, None, "Nenhum template encontrado na pasta word_templates"
            
            # Gerar proposta
            output_path = pc_generator.generate_proposta_comercial(obra_id, template_path)
            
            if output_path:
                # Gerar nome do arquivo usando o m√©todo do gerador
                obra_data = self.get_obra_data(obra_id)
                if obra_data:
                    filename = pc_generator.generate_filename(obra_data, "comercial")
                else:
                    # Fallback
                    from datetime import datetime
                    import pytz
                    try:
                        tz = pytz.timezone('America/Sao_Paulo')
                        data_atual = datetime.now(tz)
                    except:
                        data_atual = datetime.now()
                    filename = f"PC_Obra_{obra_id}_{data_atual.strftime('%d-%m-%Y')}.docx"
                
                return output_path, filename, None
            else:
                return None, None, "Falha ao gerar documento"
                
        except Exception as e:
            print(f"‚ùå Erro em generate_proposta_comercial_avancada: {e}")
            import traceback
            traceback.print_exc()
            return None, None, str(e)
            
    def generate_word_document(self, obra_id, template_type="comercial"):
        """Gera documento Word baseado no template"""
        try:
            # Para Proposta Comercial, usar o m√©todo avan√ßado
            if template_type == "comercial":
                return self.generate_proposta_comercial_avancada(obra_id)
            # Para Proposta T√©cnica, usar o m√©todo avan√ßado
            elif template_type == "tecnica":
                return self.generate_proposta_tecnica_avancada(obra_id)
            else:
                return None, None, f"Tipo de template n√£o suportado: {template_type}"
                    
        except Exception as e:
            print(f"‚ùå Erro na gera√ß√£o do Word: {e}")
            import traceback
            traceback.print_exc()
            return None, None, str(e)
    
    def generate_both_documents(self, obra_id):
        """Gera ambos os documentos (comercial e t√©cnico)"""
        try:
            # Gerar proposta comercial
            pc_path, pc_filename, pc_error = self.generate_proposta_comercial_avancada(obra_id)
            if pc_error:
                return None, None, pc_error
            
            # Gerar proposta t√©cnica
            pt_path, pt_filename, pt_error = self.generate_proposta_tecnica_avancada(obra_id)
            if pt_error:
                # Limpar arquivo gerado anteriormente
                if pc_path and os.path.exists(pc_path):
                    os.unlink(pc_path)
                return None, None, pt_error
            
            # Para ambos, criar um ZIP com os dois arquivos
            import zipfile
            import tempfile
            from datetime import datetime
            
            # Criar arquivo ZIP tempor√°rio
            with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as tmp_zip:
                zip_path = tmp_zip.name
            
            # Criar ZIP com os dois documentos
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                # Adicionar PC
                if pc_path and os.path.exists(pc_path):
                    zipf.write(pc_path, pc_filename)
                
                # Adicionar PT
                if pt_path and os.path.exists(pt_path):
                    zipf.write(pt_path, pt_filename)
            
            # Limpar arquivos individuais
            if pc_path and os.path.exists(pc_path):
                os.unlink(pc_path)
            if pt_path and os.path.exists(pt_path):
                os.unlink(pt_path)
            
            # Gerar nome do arquivo ZIP
            obra_data = self.get_obra_data(obra_id)
            if obra_data:
                # Extrair base do nome (sigla_numero)
                base_name = self.extract_filename_base(obra_data)
                zip_filename = f"PC_PT_{base_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            else:
                zip_filename = f"PC_PT_{obra_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            
            return zip_path, zip_filename, None
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar ambos documentos: {e}")
            return None, None, str(e)
    
    def get_machine_types_with_specifications(self):
        """Obt√©m tipos de m√°quinas com suas especifica√ß√µes do BD"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            if not dados_file.exists():
                return []
            
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            machines = dados_data.get("machines", [])
            machine_types = []
            
            for machine in machines:
                machine_type = machine.get("type", "")
                especificacao = machine.get("especificacao", "")
                
                if machine_type:
                    machine_types.append({
                        "type": machine_type,
                        "especificacao": especificacao if especificacao else "N√£o especificada",
                        "has_impostos": "impostos" in machine,
                        "has_options": "options" in machine and machine["options"]
                    })
            
            return machine_types
            
        except Exception as e:
            print(f"‚ùå Erro ao obter tipos de m√°quinas: {e}")
            return []
    
    def validate_obra_for_pc(self, obra_id):
        """Valida se a obra tem todos os dados necess√°rios para gerar PC"""
        try:
            obra_data = self.get_obra_data(obra_id)
            if not obra_data:
                return False, "Obra n√£o encontrada"
            
            # Verificar dados b√°sicos
            required_fields = ["nome", "empresaNome", "clienteFinal"]
            for field in required_fields:
                if not obra_data.get(field):
                    return False, f"Campo obrigat√≥rio faltando: {field}"
            
            # Verificar se tem projetos
            projetos = obra_data.get("projetos", [])
            if not projetos:
                return False, "Obra n√£o tem projetos"
            
            # Verificar se tem itens (m√°quinas, dutos ou acess√≥rios)
            has_items = False
            for projeto in projetos:
                if isinstance(projeto, dict):
                    salas = projeto.get("salas", [])
                    for sala in salas:
                        if isinstance(sala, dict):
                            if (sala.get("maquinas") or 
                                sala.get("dutos") or 
                                sala.get("acessorios")):
                                has_items = True
                                break
                if has_items:
                    break
            
            if not has_items:
                return False, "Nenhum item (m√°quina, duto ou acess√≥rio) encontrado nos projetos"
            
            return True, "Obra v√°lida para gera√ß√£o de PC"
            
        except Exception as e:
            print(f"‚ùå Erro ao validar obra: {e}")
            return False, f"Erro na valida√ß√£o: {str(e)}"
    
    def get_obra_summary(self, obra_id):
        """Retorna resumo da obra para debug/log"""
        try:
            obra_data = self.get_obra_data(obra_id)
            if not obra_data:
                return {"error": "Obra n√£o encontrada"}
            
            projetos = obra_data.get("projetos", [])
            total_machines = 0
            total_dutos = 0
            total_acessorios = 0
            total_value = obra_data.get("valorTotalObra", 0)
            
            for projeto in projetos:
                if isinstance(projeto, dict):
                    salas = projeto.get("salas", [])
                    for sala in salas:
                        if isinstance(sala, dict):
                            maquinas = sala.get("maquinas", [])
                            dutos = sala.get("dutos", [])
                            acessorios = sala.get("acessorios", [])
                            total_machines += len(maquinas)
                            total_dutos += len(dutos)
                            total_acessorios += len(acessorios)
            
            return {
                "obra_id": obra_id,
                "obra_nome": obra_data.get("nome", ""),
                "empresa_nome": obra_data.get("empresaNome", ""),
                "cliente_final": obra_data.get("clienteFinal", ""),
                "numero_projetos": len(projetos),
                "total_machines": total_machines,
                "total_dutos": total_dutos,
                "total_acessorios": total_acessorios,
                "valor_total": total_value,
                "valor_total_formatado": f"R$ {total_value:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."),
            }
            
        except Exception as e:
            print(f"‚ùå Erro ao obter resumo da obra: {e}")
            return {"error": str(e)}
        
    def extract_filename_base(self, obra_data):
        """Extrai base do nome do arquivo (sigla_numero)"""
        try:
            import re
            
            # Extrair sigla
            sigla = obra_data.get("empresaSigla", "")
            if not sigla:
                empresa_nome = obra_data.get("empresaNome", "")
                if empresa_nome:
                    # Extrair sigla entre par√™nteses
                    match = re.search(r'\(([^)]+)\)', empresa_nome)
                    if match:
                        sigla = match.group(1)
                    else:
                        # Usar iniciais (primeiras 3 palavras, m√°ximo 5 caracteres)
                        palavras = empresa_nome.split()
                        if palavras:
                            # Pegar iniciais das primeiras 3 palavras
                            iniciais = ''.join([p[0].upper() for p in palavras[:3] if p and p[0].isalpha()])
                            sigla = iniciais[:5] if iniciais else "EMP"
            
            if not sigla:
                sigla = "EMP"
            
            # Extrair n√∫mero do cliente
            cliente_numero = obra_data.get("clienteNumero", "")
            if not cliente_numero:
                # Verificar se tem n√∫mero no nome do cliente
                cliente_final = obra_data.get("clienteFinal", "")
                if cliente_final:
                    # Procurar por padr√µes como "Cliente 001" ou "001 - Cliente"
                    numeros = re.findall(r'\b(\d{2,})\b', cliente_final)
                    if numeros:
                        cliente_numero = numeros[0]
                    else:
                        # Tentar extrair n√∫mero da obra_id
                        obra_id = str(obra_data.get("id", ""))
                        numeros_obra = re.findall(r'\d+', obra_id)
                        if numeros_obra:
                            cliente_numero = numeros_obra[-1]  # Pegar o √∫ltimo n√∫mero
            
            # Se ainda n√£o tiver n√∫mero, usar "001" como padr√£o
            if not cliente_numero:
                cliente_numero = "001"
            # Garantir que o n√∫mero tenha pelo menos 3 d√≠gitos
            elif len(cliente_numero) < 3:
                cliente_numero = cliente_numero.zfill(3)
            
            # Limpar caracteres n√£o alfanum√©ricos
            sigla_limpa = re.sub(r'[^a-zA-Z0-9]', '', sigla)
            numero_limpo = re.sub(r'[^a-zA-Z0-9]', '', str(cliente_numero))
            
            return f"{sigla_limpa}_{numero_limpo}"
            
        except Exception as e:
            print(f"‚ùå Erro ao extrair base do nome: {e}")
            return "EMP_001"
    
    def generate_pc_filename(self, obra_data):
        """Gera nome do arquivo para Proposta Comercial no formato PC_Obra_sigla_numero_data"""
        try:
            from datetime import datetime
            import pytz
            
            try:
                tz = pytz.timezone('America/Sao_Paulo')
                data_atual = datetime.now(tz)
            except:
                data_atual = datetime.now()
            
            # Extrair base do nome (sigla_numero)
            base_name = self.extract_filename_base(obra_data)
            
            # Formatar data como DD-MM-AAAA
            data_formatada = data_atual.strftime("%d-%m-%Y")
            
            # Gerar nome no formato: PC_Obra_sigla_numero_data
            return f"PC_Obra_{base_name}_{data_formatada}.docx"
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar nome PC: {e}")
            # Fallback: PC_Obra_data
            from datetime import datetime
            data_fallback = datetime.now().strftime("%d-%m-%Y")
            return f"PC_Obra_{data_fallback}.docx"
    
    def generate_pt_filename(self, obra_data):
        """Gera nome do arquivo para Proposta T√©cnica no formato PT_Obra_sigla_numero_data"""
        try:
            from datetime import datetime
            import pytz
            
            try:
                tz = pytz.timezone('America/Sao_Paulo')
                data_atual = datetime.now(tz)
            except:
                data_atual = datetime.now()
            
            # Extrair base do nome (sigla_numero)
            base_name = self.extract_filename_base(obra_data)
            
            # Formatar data como DD-MM-AAAA
            data_formatada = data_atual.strftime("%d-%m-%Y")
            
            # Gerar nome no formato: PT_Obra_sigla_numero_data
            return f"PT_Obra_{base_name}_{data_formatada}.docx"
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar nome PT: {e}")
            # Fallback: PT_Obra_data
            from datetime import datetime
            data_fallback = datetime.now().strftime("%d-%m-%Y")
            return f"PT_Obra_{data_fallback}.docx"
/* ==== FIM: handlers/word_handler.py ==== */

/* ==== IN√çCIO: generators/wordPC_generator.py ==== */
# servidor_modules/generators/wordPC_generator.py
"""
wordPC_generator.py - Gerador de Proposta Comercial (PC)
"""

import json
import os
from datetime import datetime
from pathlib import Path
from docxtpl import DocxTemplate
import traceback
from typing import Dict, List, Any, Optional


class WordPCGenerator:
    """Gerador espec√≠fico para Proposta Comercial"""
    
    def __init__(self, project_root: Path, file_utils):
        self.project_root = project_root
        self.file_utils = file_utils
        
    def get_dados_data(self) -> Dict:
        """Obt√©m dados do sistema (machines, constants, etc.)"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            if not dados_file.exists():
                return {}
            
            with open(dados_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados.json: {e}")
            return {}
    
    def get_backup_data(self) -> Dict:
        """Obt√©m dados de backup"""
        try:
            backup_file = self.project_root / "json" / "backup.json"
            if not backup_file.exists():
                return {}
            
            with open(backup_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ùå Erro ao carregar backup.json: {e}")
            return {}
    
    def get_obra_by_id(self, obra_id: str) -> Optional[Dict]:
        """Busca obra espec√≠fica no backup"""
        backup_data = self.get_backup_data()
        obras = backup_data.get("obras", [])
        
        for obra in obras:
            if str(obra.get("id")) == obra_id:
                return obra
        
        return None
    
    def get_machine_data_by_type(self, machine_type: str) -> Optional[Dict]:
        """Busca dados de m√°quina espec√≠fica"""
        dados_data = self.get_dados_data()
        machines = dados_data.get("machines", [])
        
        for machine in machines:
            if machine.get("type") == machine_type:
                return machine
        
        return None
    
    def format_currency(self, value: float) -> str:
        """Formata valor monet√°rio"""
        if not value:
            return "R$ 0,00"
        return f"R$ {value:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")
    
    def extract_items_by_aplicacao(self, projetos: List[Dict]) -> List[Dict]:
        """
        Extrai m√°quinas, dutos e acess√≥rios agrupados por aplica√ß√£o
        Ordem das aplica√ß√µes:
        1. Climatiza√ß√£o
        2. Pressuriza√ß√£o/Ventila√ß√£o
        3. Exaust√£o sala de bateria
        4. Exaust√£o baia de trafo
        """
        # Defini√ß√£o das aplica√ß√µes na ordem correta
        aplicacoes = [
            {"tipo": "climatizacao", "nome": "Climatiza√ß√£o", "maquinas": [], "dutos": [], "acessorios": []},
            {"tipo": "pressurizacao", "nome": "Pressuriza√ß√£o/Ventila√ß√£o", "maquinas": [], "dutos": [], "acessorios": []},
            {"tipo": "exaustao_bateria", "nome": "Exaust√£o Sala de Bateria", "maquinas": [], "dutos": [], "acessorios": []},
            {"tipo": "exaustao_baia_trafo", "nome": "Exaust√£o Baia de Trafo", "maquinas": [], "dutos": [], "acessorios": []}
        ]
        
        aplicacoes_dict = {app["tipo"]: app for app in aplicacoes}
        
        for projeto in projetos:
            if not isinstance(projeto, dict):
                continue
                
            salas = projeto.get("salas", [])
            for sala in salas:
                if not isinstance(sala, dict):
                    continue
                
                ambiente_nome = sala.get("nome", "Ambiente")
                
                # Processar m√°quinas
                maquinas = sala.get("maquinas", [])
                for maquina in maquinas:
                    if not isinstance(maquina, dict):
                        continue
                    
                    # Obter aplica√ß√£o da m√°quina
                    aplicacao_tipo = maquina.get("aplicacao_machines", "").lower()
                    if aplicacao_tipo in aplicacoes_dict:
                        # Buscar dados da m√°quina no BD
                        machine_data = self.get_machine_data_by_type(maquina.get("tipo", ""))
                        impostos = machine_data.get("impostos", {}) if machine_data else {}
                        
                        # Buscar fornecedor
                        fornecedor = "N√£o especificado"
                        fornecedor_keys = ["FORNECEDOR", "FABRICANTE", "MARCA"]
                        for key in fornecedor_keys:
                            if key in impostos:
                                fornecedor = impostos[key]
                                break
                        
                        maquina_template = {
                            "tipo": maquina.get("tipo", ""),
                            "nome": maquina.get("nome", ""),
                            "potencia": maquina.get("potencia", ""),
                            "quantidade": maquina.get("quantidade", 1),
                            "preco_total": maquina.get("precoTotal", 0),
                            "preco_total_formatado": self.format_currency(maquina.get("precoTotal", 0)),
                            "ambiente": ambiente_nome,
                            "opcoes": maquina.get("opcoesSelecionadas", []),
                            "configuracoes": maquina.get("configuracoesSelecionadas", []),
                            "fornecedor": fornecedor,
                            "frete": impostos.get("FRETE", ""),
                            "icms": impostos.get("ICMS", ""),
                            "ipi": impostos.get("IPI", ""),
                            "dados_completos": maquina
                        }
                        
                        aplicacoes_dict[aplicacao_tipo]["maquinas"].append(maquina_template)
                
                # Processar dutos
                dutos = sala.get("dutos", [])
                for duto in dutos:
                    if not isinstance(duto, dict):
                        continue
                    
                    aplicacao_tipo = duto.get("aplicacao_Dutos", "").lower()
                    if aplicacao_tipo in aplicacoes_dict:
                        # Usar tipo_descricao se existir, sen√£o tipo
                        tipo_duto = duto.get("tipo_descricao", duto.get("tipo", "Duto"))
                        
                        duto_template = {
                            "tipo": tipo_duto,
                            "tipo_descricao": tipo_duto,
                            "dimensao": duto.get("dimensao", ""),
                            "quantidade": duto.get("quantidade", 1),
                            "preco_total": duto.get("valor_total", 0),
                            "preco_total_formatado": self.format_currency(duto.get("valor_total", 0)),
                            "ambiente": ambiente_nome,
                            "material": duto.get("tipo", ""),
                            "valor_unitario": duto.get("valor_unitario", 0),
                            "valor_unitario_formatado": self.format_currency(duto.get("valor_unitario", 0))
                        }
                        
                        aplicacoes_dict[aplicacao_tipo]["dutos"].append(duto_template)
                
                # Processar acess√≥rios
                acessorios = sala.get("acessorios", [])
                for acessorio in acessorios:
                    if not isinstance(acessorio, dict):
                        continue
                    
                    aplicacao_tipo = acessorio.get("aplicacao_Acessorio", "").lower()
                    if aplicacao_tipo in aplicacoes_dict:
                        acessorio_template = {
                            "tipo": acessorio.get("tipo", "Acess√≥rio"),
                            "dimensao": acessorio.get("dimensao", ""),
                            "quantidade": acessorio.get("quantidade", 1),
                            "descricao": acessorio.get("descricao", ""),
                            "preco_total": acessorio.get("valor_total", 0),
                            "preco_total_formatado": self.format_currency(acessorio.get("valor_total", 0)),
                            "ambiente": ambiente_nome,
                            "valor_unitario": acessorio.get("valor_unitario", 0),
                            "valor_unitario_formatado": self.format_currency(acessorio.get("valor_unitario", 0))
                        }
                        
                        aplicacoes_dict[aplicacao_tipo]["acessorios"].append(acessorio_template)
        
        # Calcular totais por aplica√ß√£o e remover aplica√ß√µes vazias
        resultado = []
        for app in aplicacoes:
            # Calcular totais
            total_maquinas = sum(m.get("preco_total", 0) for m in app["maquinas"])
            total_dutos = sum(d.get("preco_total", 0) for d in app["dutos"])
            total_acessorios = sum(a.get("preco_total", 0) for a in app["acessorios"])
            total_aplicacao = total_maquinas + total_dutos + total_acessorios
            
            # Adicionar apenas se tiver itens
            if app["maquinas"] or app["dutos"] or app["acessorios"]:
                app.update({
                    "total_maquinas": total_maquinas,
                    "total_maquinas_formatado": self.format_currency(total_maquinas),
                    "total_dutos": total_dutos,
                    "total_dutos_formatado": self.format_currency(total_dutos),
                    "total_acessorios": total_acessorios,
                    "total_acessorios_formatado": self.format_currency(total_acessorios),
                    "total_aplicacao": total_aplicacao,
                    "total_aplicacao_formatado": self.format_currency(total_aplicacao),
                    "quantidade_maquinas": len(app["maquinas"]),
                    "quantidade_dutos": len(app["dutos"]),
                    "quantidade_acessorios": len(app["acessorios"])
                })
                resultado.append(app)
        
        return resultado
    
    def calculate_totals(self, obra_data: Dict) -> Dict:
        """Calcula totais da obra"""
        total_obra = obra_data.get("valorTotalObra", 0)
        
        # Calcular total de m√°quinas, dutos e acess√≥rios
        total_maquinas = 0
        total_dutos = 0
        total_acessorios = 0
        total_servicos = 0
        
        projetos = obra_data.get("projetos", [])
        for projeto in projetos:
            if isinstance(projeto, dict):
                # Servi√ßos
                servicos = projeto.get("servicos", {})
                if isinstance(servicos, dict):
                    # Engenharia
                    engenharia = servicos.get("engenharia", {})
                    if isinstance(engenharia, dict):
                        total_servicos += engenharia.get("valor", 0)
                    
                    # Adicionais
                    adicionais = servicos.get("adicionais", [])
                    if isinstance(adicionais, list):
                        for adicional in adicionais:
                            if isinstance(adicional, dict):
                                total_servicos += adicional.get("valor", 0)
        
        return {
            "total_obra": total_obra,
            "total_obra_formatado": self.format_currency(total_obra),
            "total_maquinas": total_maquinas,
            "total_maquinas_formatado": self.format_currency(total_maquinas),
            "total_dutos": total_dutos,
            "total_dutos_formatado": self.format_currency(total_dutos),
            "total_acessorios": total_acessorios,
            "total_acessorios_formatado": self.format_currency(total_acessorios),
            "total_servicos": total_servicos,
            "total_servicos_formatado": self.format_currency(total_servicos)
        }
    
    def extract_servicos(self, projetos: List[Dict]) -> Dict:
        """Extrai informa√ß√µes de servi√ßos"""
        servicos_info = {
            "engenharia": {
                "valor": 0,
                "descricao": "",
                "valor_formatado": "R$ 0,00"
            },
            "adicionais": [],
            "tem_adicionais": False
        }
        
        for projeto in projetos:
            if not isinstance(projeto, dict):
                continue
                
            servicos = projeto.get("servicos", {})
            if not isinstance(servicos, dict):
                continue
            
            # Engenharia
            engenharia = servicos.get("engenharia", {})
            if isinstance(engenharia, dict):
                servicos_info["engenharia"]["valor"] = engenharia.get("valor", 0)
                servicos_info["engenharia"]["descricao"] = engenharia.get("descricao", "")
                servicos_info["engenharia"]["valor_formatado"] = self.format_currency(engenharia.get("valor", 0))
            
            # Adicionais
            adicionais = servicos.get("adicionais", [])
            if isinstance(adicionais, list) and adicionais:
                servicos_info["tem_adicionais"] = True
                for adicional in adicionais:
                    if isinstance(adicional, dict):
                        servicos_info["adicionais"].append({
                            "descricao": adicional.get("descricao", ""),
                            "valor": adicional.get("valor", 0),
                            "valor_formatado": self.format_currency(adicional.get("valor", 0))
                        })
        
        return servicos_info
    
    def generate_context_for_pc(self, obra_id: str) -> Dict:
        """Gera contexto completo para Proposta Comercial"""
        try:
            # Obter dados da obra
            obra_data = self.get_obra_by_id(obra_id)
            if not obra_data:
                raise ValueError(f"Obra {obra_id} n√£o encontrada")
            
            # Dados b√°sicos
            obra_nome = obra_data.get("nome", "Obra n√£o especificada")
            empresa_nome = obra_data.get("empresaNome", "Empresa n√£o especificada")
            cliente_final = obra_data.get("clienteFinal", "Cliente n√£o especificado")
            
            # Projetos
            projetos = obra_data.get("projetos", [])
            
            # Extrair itens por aplica√ß√£o
            aplicacoes_groups = self.extract_items_by_aplicacao(projetos)
            
            # Calcular totais
            totals = self.calculate_totals(obra_data)
            
            # Extrair servi√ßos
            servicos = self.extract_servicos(projetos)
            
            # Data atual - ajustar fuso hor√°rio
            from datetime import datetime
            import pytz
            
            # Usar fuso hor√°rio de Bras√≠lia
            try:
                tz = pytz.timezone('America/Sao_Paulo')
                data_atual = datetime.now(tz)
            except:
                data_atual = datetime.now()
            
            # Contexto para o template
            context = {
                # Cabe√ßalho
                "data_emissao": data_atual.strftime("%d/%m/%Y"),
                "data_emissao_completa": data_atual.strftime("%d de %B de %Y"),
                "empresa_nome": empresa_nome.upper(),
                "obra_nome": obra_nome,
                "cliente_final": cliente_final,
                
                # Projetos
                "projetos": projetos,
                "projeto_nome": projetos[0].get("nome", "Projeto Principal") if projetos else "Projeto",
                
                # Itens agrupados por aplica√ß√£o
                "aplicacoes_groups": aplicacoes_groups,
                
                # Flags para verificar se existem itens em cada aplica√ß√£o
                "tem_climatizacao": any(app.get("tipo") == "climatizacao" for app in aplicacoes_groups),
                "tem_pressurizacao": any(app.get("tipo") == "pressurizacao" for app in aplicacoes_groups),
                "tem_exaustao_bateria": any(app.get("tipo") == "exaustao_bateria" for app in aplicacoes_groups),
                "tem_exaustao_baia_trafo": any(app.get("tipo") == "exaustao_baia_trafo" for app in aplicacoes_groups),
            }
            
            # Servi√ßos
            context.update({
                "servicos": servicos,
                "engenharia_valor": servicos["engenharia"]["valor_formatado"],
                "engenharia_descricao": servicos["engenharia"]["descricao"] or "Servi√ßos de engenharia",
                "tem_adicionais": servicos["tem_adicionais"],
                "adicionais": servicos["adicionais"]
            })
            
            # Totais
            context.update({
                "valor_total_obra": totals["total_obra_formatado"],
                "valor_total_projeto": totals["total_obra_formatado"],  # Para o template usar
                "total_global": totals["total_obra_formatado"]
            })
            
            # REMOVER INFORMA√á√ïES FIXAS DA ESI (j√° estar√£o no template Word)
            # Estas informa√ß√µes agora devem estar apenas no template Word
            
            return context
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar contexto PC: {e}")
            traceback.print_exc()
            return {}
    
    def generate_proposta_comercial(self, obra_id: str, template_path: Path) -> Optional[str]:
        """Gera documento de Proposta Comercial"""
        try:
            # Verificar template
            if not template_path.exists():
                print(f"‚ùå Template n√£o encontrado: {template_path}")
                return None
            
            # Gerar contexto
            context = self.generate_context_for_pc(obra_id)
            if not context:
                raise ValueError("N√£o foi poss√≠vel gerar contexto para a PC")
            
            print(f"üìä Contexto gerado:")
            print(f"  - Empresa: {context.get('empresa_nome')}")
            print(f"  - Obra: {context.get('obra_nome')}")
            print(f"  - Aplica√ß√µes: {len(context.get('aplicacoes_groups', []))}")
            
            # Carregar e preencher template
            doc = DocxTemplate(str(template_path))
            
            try:
                # Testar o template com contexto reduzido primeiro
                test_context = {
                    "data_emissao": context.get("data_emissao", ""),
                    "empresa_nome": context.get("empresa_nome", ""),
                    "obra_nome": context.get("obra_nome", ""),
                    "cliente_final": context.get("cliente_final", ""),
                    "aplicacoes_groups": [],
                    "projetos": [],
                    "engenharia_valor": context.get("engenharia_valor", ""),
                    "engenharia_descricao": context.get("engenharia_descricao", ""),
                    "valor_total_projeto": context.get("valor_total_projeto", ""),
                    "total_global": context.get("total_global", "")
                }
                
                print("üß™ Testando template com contexto b√°sico...")
                doc.render(test_context)
                print("‚úÖ Template testado com sucesso")
                
                # Agora renderizar com contexto completo
                print("üé® Renderizando template completo...")
                doc = DocxTemplate(str(template_path))  # Recarregar template
                doc.render(context)
                
            except Exception as template_error:
                print(f"‚ùå Erro no template: {template_error}")
                raise
            
            # Salvar arquivo tempor√°rio
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as tmp:
                output_path = tmp.name
                doc.save(output_path)
            
            print(f"‚úÖ Proposta Comercial gerada: {output_path}")
            return output_path
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar Proposta Comercial: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def generate_filename(self, obra_data: Dict, template_type: str) -> str:
        """Gera nome do arquivo no formato PC_Obra_empresaSigla_numeroClienteFinal_DD-MM-AAAA"""
        try:
            # Extrair sigla da empresa
            empresa_nome = obra_data.get("empresaNome", "")
            sigla = obra_data.get("empresaSigla", "")
            
            # Se n√£o tiver sigla espec√≠fica, tentar extrair do nome
            if not sigla and empresa_nome:
                import re
                match = re.search(r'\(([^)]+)\)', empresa_nome)
                if match:
                    sigla = match.group(1)
                else:
                    palavras = empresa_nome.split()
                    if palavras:
                        sigla = ''.join([p[0].upper() for p in palavras if p])
            
            # Sigla padr√£o se ainda n√£o tiver
            if not sigla:
                sigla = "EMP"
            
            # Extrair n√∫mero do cliente final
            cliente_numero = obra_data.get("clienteNumero", "")
            if not cliente_numero:
                cliente_final = obra_data.get("clienteFinal", "")
                if cliente_final:
                    import re
                    numeros = re.findall(r'\d+', cliente_final)
                    if numeros:
                        cliente_numero = numeros[0]
                    else:
                        cliente_numero = "001"
                else:
                    cliente_numero = "001"
            
            # Limpar caracteres especiais
            import re
            sigla_limpa = re.sub(r'[^a-zA-Z0-9]', '', sigla)
            numero_limpo = re.sub(r'[^a-zA-Z0-9]', '', str(cliente_numero))
            
            # Determinar prefixo
            if template_type.lower() in ["comercial", "pc"]:
                prefixo = "PC_Obra"
            elif template_type.lower() in ["tecnica", "pt"]:
                prefixo = "PT_Obra"
            else:
                prefixo = template_type.upper()
            
            # Data atual formatada como DD-MM-AAAA
            from datetime import datetime
            import pytz
            
            try:
                tz = pytz.timezone('America/Sao_Paulo')
                data_atual = datetime.now(tz)
            except:
                data_atual = datetime.now()
            
            data_formatada = data_atual.strftime("%d-%m-%Y")
            
            # Gerar nome do arquivo
            filename = f"{prefixo}_{sigla_limpa}_{numero_limpo}_{data_formatada}.docx"
            
            return filename
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar nome do arquivo: {e}")
            # Nome de fallback
            from datetime import datetime
            data_fallback = datetime.now().strftime("%d-%m-%Y")
            return f"PC_Obra_{data_fallback}.docx"
/* ==== FIM: generators/wordPC_generator.py ==== */
