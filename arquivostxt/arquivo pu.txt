
/* ==== INÃCIO: handlers/http_handler.py ==== */
# servidor_modules/handlers/http_handler.py

import http.server
import json
import time
from urllib.parse import parse_qs, urlparse
from pathlib import Path
import os
import gzip
import threading
import re

from ..PypExelAndJson.converter_exel import converter
import base64

# IMPORTS
from servidor_modules.utils.file_utils import FileUtils


class UniversalHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """Handler ULTRA-RÃPIDO com CACHE BUSTER AUTOMÃTICO PARA TODOS OS ARQUIVOS"""

    # Arquivos que NUNCA devem ser logados (acelera MUITO)
    SILENT_PATHS = {
        "/static/",
        ".css",
        ".js",
        ".png",
        ".jpg",
        ".jpeg",
        "/public/static/",
        "/public/scripts/",
        ".woff",
        ".woff2",
        ".ico",
        ".svg",
        ".gif",
        ".map",
        ".ttf",
        ".eot",
    }

    # Roteamento direto para mÃ¡xima velocidade
    API_ROUTES = {
        # ROTAS EXISTENTES DO SISTEMA
        "/constants": "handle_get_constants",
        "/system-constants": "handle_get_constants",
        "/dados": "handle_get_dados",
        "/backup": "handle_get_backup",
        "/machines": "handle_get_machines",
        "/health-check": "handle_health_check",
        "/session-obras": "handle_get_session_obras",
        "/api/session-obras": "handle_get_session_obras",
        "/api/sessions/current": "handle_get_sessions_current",
        "/api/backup-completo": "handle_get_backup_completo",
        "/api/dados/empresas": "handle_get_empresas",
        "/obras": "handle_get_obras",
        "/api/server/uptime": "handle_get_server_uptime",
        # ========== ROTAS PARA EQUIPAMENTOS ==========
        "/api/equipamentos": "handle_get_equipamentos",
        "/api/equipamentos/types": "handle_get_equipamento_types",
        "/api/equipamentos/dimensoes": "handle_get_equipamento_dimensoes",
        # ========== NOVAS ROTAS PARA SISTEMA DE EDIÃ‡ÃƒO ==========
        # ROTAS GET - DADOS DO SISTEMA
        "/api/system-data": "handle_get_system_data",
        "/api/constants": "handle_get_constants_json",
        "/api/materials": "handle_get_materials",
        "/api/empresas/all": "handle_get_all_empresas",
        "/api/empresas/": "handle_delete_empresa_route",
        # ROTAS GET - MÃQUINAS
        "/api/machines/types": "handle_get_machine_types",
        # '/api/machines/type/{type}' Ã© tratada separadamente no handle_machine_routes
        # ROTAS POST - SALVAMENTO DE DADOS
        "/api/system-data/save": "handle_post_save_system_data",
        "/api/constants/save": "handle_post_save_constants",
        "/api/materials/save": "handle_post_save_materials",
        "/api/empresas/save": "handle_post_save_empresas",
        "/api/machines/save": "handle_post_save_machines",
        "/api/machines/add": "handle_post_add_machine",
        "/api/machines/update": "handle_post_update_machine",
        # ROTAS DE EMPRESAS ESPECÃFICAS
        "/api/dados/empresas/auto": "handle_post_empresas_auto",
        # ROTAS DE SESSÃƒO
        "/api/sessions/shutdown": "handle_post_sessions_shutdown",
        "/api/sessions/ensure-single": "handle_post_sessions_ensure_single",
        "/api/sessions/add-obra": "handle_post_sessions_add_obra",
        "/api/reload-page": "handle_post_reload_page",
        # ROTAS DE SHUTDOWN
        "/api/shutdown": "handle_shutdown",
        # ROTA UNIVERSAL DELETE
        "/api/delete": "handle_delete_universal",
        # APIS do json
        "/api/excel/upload": "handle_post_excel_upload",
        "/api/excel/export": "handle_post_excel_export",
        "/api/json/validate": "handle_post_json_validate",
        "/api/json/normalize": "handle_post_json_normalize",
        "/api/system/apply-json": "handle_post_apply_json",
        "/api/system/compare": "handle_post_system_compare",
        
        # ========== ROTAS PARA DUTOS ==========
        "/api/dutos": "handle_get_dutos",
        "/api/dutos/types": "handle_get_duto_types",
        "/api/dutos/opcionais": "handle_get_duto_opcionais",
    }

    def __init__(self, *args, **kwargs):
        # INICIALIZAÃ‡ÃƒO RÃPIDA
        self.file_utils = FileUtils()
        self.project_root = self.file_utils.find_project_root()

        # Timestamp Ãºnico para TODOS os arquivos (muda a cada execuÃ§Ã£o do servidor)
        self.CACHE_BUSTER = f"v{int(time.time())}"
        print(f"ðŸ”„ CACHE BUSTER INICIADO: {self.CACHE_BUSTER}")

        # InicializaÃ§Ã£o PreguiÃ§osa - sÃ³ quando necessÃ¡rio
        self._routes_core = None
        self._route_handler = None

        serve_directory = self.project_root
        super().__init__(*args, directory=str(serve_directory), **kwargs)

    @property
    def routes_core(self):
        """InicializaÃ§Ã£o preguiÃ§osa do RoutesCore"""
        if self._routes_core is None:
            from servidor_modules.core.routes_core import RoutesCore
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner

            self._routes_core = RoutesCore(
                self.project_root, sessions_manager, self.file_utils, CacheCleaner()
            )
        return self._routes_core

    @property
    def route_handler(self):
        """InicializaÃ§Ã£o preguiÃ§osa do RouteHandler"""
        if self._route_handler is None:
            from servidor_modules.core.sessions_core import sessions_manager
            from servidor_modules.utils.cache_cleaner import CacheCleaner
            from servidor_modules.handlers.route_handler import RouteHandler

            self._route_handler = RouteHandler(
                self.project_root, sessions_manager, self.file_utils, CacheCleaner()
            )
            self._route_handler.set_routes_core(self.routes_core)
        return self._route_handler

    def do_GET(self):
        """GET com CACHE BUSTER AUTOMÃTICO para CSS/JS/HTML"""
        parsed_path = urlparse(self.path)
        original_path = self.path
        path = parsed_path.path

        # NormalizaÃ§Ã£o rÃ¡pida de path
        if path.startswith("/codigo/"):
            path = path[7:]

        # Log apenas para rotas importantes (acelera MUITO)
        if not any(silent in path for silent in self.SILENT_PATHS):
            print(f"ðŸ“¥ GET: {path}")

        # CACHE BUSTER AUTOMÃTICO: Adiciona versionamento a CSS, JS e HTML
        if any(path.endswith(ext) for ext in [".css", ".js", ".html", ".htm"]):
            new_path = self._add_cache_buster(original_path)
            if new_path != original_path:
                print(f"ðŸ”„ AUTO CACHE BUSTER: {original_path} -> {new_path}")
                self.path = new_path

        # ========== ROTEAMENTO RÃPIDO PARA APIs ==========

        # Rotas definidas no dicionÃ¡rio API_ROUTES
        if path in self.API_ROUTES:
            handler_name = self.API_ROUTES[path]
            try:
                getattr(self.route_handler, handler_name)(self)
            except AttributeError as e:
                print(f"âŒ Handler nÃ£o encontrado: {handler_name}")
                print(
                    f"âŒ MÃ©todos disponÃ­veis: {[m for m in dir(self.route_handler) if not m.startswith('_')]}"
                )
                self.send_error(501, f"Handler nÃ£o implementado: {handler_name}")

        # ========== ROTAS COM PARÃ‚METROS ==========

        # Rotas de empresas com parÃ¢metros
        elif path.startswith("/api/dados/empresas/buscar/"):
            termo = path.split("/")[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith("/api/dados/empresas/numero/"):
            sigla = path.split("/")[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)

        # Rotas de obras com ID
        elif path.startswith("/obras/"):
            self.handle_obra_routes(path)

        # Rotas de mÃ¡quinas com parÃ¢metros
        elif path.startswith("/api/machines/"):
            self.handle_machine_routes(path)

        # ========== ROTAS PARA EQUIPAMENTOS ==========

        # Rotas de equipamentos com parÃ¢metros
        elif path.startswith("/api/equipamentos/type/"):
            self.handle_get_equipamento_by_type()

        elif path.startswith("/api/equipamentos/search"):
            self.handle_get_search_equipamentos()
            
        # ========== ROTAS PARA DUTOS ==========
        elif path.startswith("/api/dutos/type/"):
            self.handle_get_duto_by_type()
            
        elif path.startswith("/api/dutos/search"):
            self.handle_get_search_dutos()

        # ========== ARQUIVOS ESTÃTICOS ==========
        else:
            # Serve arquivo estÃ¡tico COM HEADERS ANTI-CACHE
            self.serve_static_file_no_cache(path)

    def do_POST(self):
        """POST com todas as rotas necessÃ¡rias"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"ðŸ“¨ POST: {path}")

        # ========== ROTAS PARA EQUIPAMENTOS ==========

        # ROTAS PARA EQUIPAMENTOS
        if path == "/api/equipamentos/add":
            self.handle_post_add_equipamento()
        elif path == "/api/equipamentos/update":
            self.handle_post_update_equipamento()
        elif path == "/api/equipamentos/delete":
            self.handle_post_delete_equipamento()

        # ========== ROTAS PARA EXCEL/JSON ==========
        elif path == "/api/excel/upload":
            self.handle_post_excel_upload()
        elif path == "/api/excel/export":
            self.handle_post_excel_export()
        elif path == "/api/json/validate":
            self.handle_post_json_validate()
        elif path == "/api/json/normalize":
            self.handle_post_json_normalize()
        elif path == "/api/system/apply-json":
            self.handle_post_system_apply_json()
        elif path == "/api/system/compare":
            self.handle_post_system_apply_json()

        # ========== ROTAS EXISTENTES ==========
        elif path == "/obras":
            self.route_handler.handle_post_obras(self)

        # ========== ROTAS DE SESSÃƒO ==========
        elif path == "/api/sessions/shutdown":
            self.route_handler.handle_post_sessions_shutdown(self)
        elif path == "/api/shutdown":
            self.route_handler.handle_shutdown(self)
        elif path == "/api/sessions/ensure-single":
            self.route_handler.handle_post_sessions_ensure_single(self)
        elif path == "/api/sessions/add-obra":
            self.route_handler.handle_post_sessions_add_obra(self)
        elif path == "/api/reload-page":
            self.route_handler.handle_post_reload_page(self)

        # ========== ROTAS DE DADOS ==========
        elif path == "/dados":
            self.route_handler.handle_post_dados(self)
        elif path == "/backup":
            self.route_handler.handle_post_backup(self)

        # ========== ROTAS DE EMPRESAS ==========
        elif path == "/api/dados/empresas":
            self.route_handler.handle_post_empresas(self)
        elif path == "/api/dados/empresas/auto":
            self.route_handler.handle_post_empresas_auto(self)

        # ========== ROTAS LEGACY (COMPATIBILIDADE) ==========
        elif path in ["/projetos", "/projects"]:
            self.route_handler.handle_post_projetos(self)

        # ========== NOVAS ROTAS PARA EDIÃ‡ÃƒO DE DADOS ==========

        # ROTAS DE SALVAMENTO COMPLETO
        elif path == "/api/system-data/save":
            self.route_handler.handle_post_save_system_data(self)

        # ROTAS DE SALVAMENTO POR SEÃ‡ÃƒO
        elif path == "/api/constants/save":
            self.route_handler.handle_post_save_constants(self)
        elif path == "/api/materials/save":
            self.route_handler.handle_post_save_materials(self)
        elif path == "/api/empresas/save":
            self.route_handler.handle_post_save_empresas(self)
        elif path == "/api/machines/save":
            self.route_handler.handle_post_save_machines(self)

        # ROTAS ESPECÃFICAS DE MÃQUINAS
        elif path == "/api/machines/add":
            self.route_handler.handle_post_add_machine(self)
        elif path == "/api/machines/update":
            self.route_handler.handle_post_update_machine(self)
            
        # ========== ROTAS PARA DUTOS ==========
        elif path == "/api/dutos/add":
            self.handle_post_add_duto()
        elif path == "/api/dutos/update":
            self.handle_post_update_duto()
        elif path == "/api/dutos/delete":
            self.handle_post_delete_duto()

        # ========== ROTA NÃƒO ENCONTRADA ==========
        else:
            print(f"âŒ POST nÃ£o implementado: {path}")
            self.send_error(501, f"MÃ©todo nÃ£o suportado: POST {path}")

    def do_PUT(self):
        """PUT para atualizaÃ§Ãµes"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"ðŸ“¨ PUT: {path}")

        # ROTAS PRINCIPAIS - OBRAS
        if path.startswith("/obras/"):
            print(f"ðŸŽ¯ Roteando PUT para obra: {path}")
            self.route_handler.handle_put_obra(self)
        else:
            print(f"âŒ PUT nÃ£o implementado: {path}")
            self.send_error(501, f"MÃ©todo nÃ£o suportado: PUT {path}")

    def do_DELETE(self):
        """DELETE para remoÃ§Ã£o de recursos"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path

        if path.startswith("/codigo/"):
            path = path[7:]

        print(f"ðŸ—‘ï¸  DELETE: {path}")

        # ========== NOVA ROTA UNIVERSAL ==========
        if path == "/api/delete":
            self.handle_delete_universal()

        # ========== ROTA ESPECÃFICA PARA EMPRESAS ==========
        elif path.startswith("/api/empresas/"):
            self.handle_delete_empresa()

        # ROTAS PRINCIPAIS - OBRAS
        elif path.startswith("/obras/"):
            obra_id = path.split("/")[-1]
            print(f"ðŸŽ¯ Roteando DELETE para obra: {obra_id}")
            self.route_handler.handle_delete_obra(self, obra_id)
        # ROTAS PRINCIPAIS - SESSÃ•ES OBRAS
        elif path.startswith("/api/sessions/remove-obra/"):
            obra_id = path.split("/")[-1]
            self.route_handler.handle_delete_sessions_remove_obra(self, obra_id)

        else:
            print(f"âŒ DELETE nÃ£o implementado: {path}")
            self.send_error(501, f"MÃ©todo nÃ£o suportado: DELETE {path}")

    def handle_delete_universal(self):
        """API universal para deletar qualquer item do backup.json usando path"""
        try:
            content_length = int(self.headers["Content-Length"])
            post_data = self.rfile.read(content_length).decode("utf-8")
            data = json.loads(post_data)

            # ObrigatÃ³rio: path como array (ex: ["obras", "obra_id", "projetos", "projeto_id"])
            path = data.get("path")

            if not path or not isinstance(path, list):
                self.send_json_response(
                    {
                        "success": False,
                        "error": "Path invÃ¡lido. Deve ser um array (ex: ['obras', 'id_da_obra'])",
                    },
                    status=400,
                )
                return

            print(f"ðŸ—‘ï¸  DELETE UNIVERSAL - Path: {path}")

            # Chama o mÃ©todo no RoutesCore
            result = self.routes_core.handle_delete_universal(path)

            if result["success"]:
                self.send_json_response(result)
            else:
                self.send_json_response(result, status=500)

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_delete_universal: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_health_check(self):
        """Health check rÃ¡pido"""
        self.send_json_response({"status": "online", "timestamp": time.time()})

    def handle_empresa_routes(self, path):
        """Rotas de empresa otimizadas"""
        if path.startswith("/api/dados/empresas/buscar/"):
            termo = path.split("/")[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith("/api/dados/empresas/numero/"):
            sigla = path.split("/")[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)

    def handle_obra_routes(self, path):
        """Rotas de obra otimizadas"""
        if self.command == "GET":
            obra_id = path.split("/")[-1]
            self.route_handler.handle_get_obra_by_id(self, obra_id)

    def _add_cache_buster(self, path):
        """Adiciona cache buster Ã  URL se nÃ£o tiver"""
        if "?" in path:
            # JÃ¡ tem parÃ¢metros, adiciona ou atualiza o v=
            if "v=" in path:
                # Substitui versÃ£o existente
                path = re.sub(r"[?&]v=[^&]+", f"&v={self.CACHE_BUSTER}", path)
                # Corrige se ficou ?& substituindo por ?
                path = path.replace("?&", "?")
            else:
                # Adiciona novo parÃ¢metro
                path += f"&v={self.CACHE_BUSTER}"
        else:
            # Primeiro parÃ¢metro
            path += f"?v={self.CACHE_BUSTER}"

        return path

    def serve_static_file_no_cache(self, path):
        """Serve arquivos estÃ¡ticos - sempre do disco com headers anti-cache"""
        try:
            # Remove parÃ¢metros para encontrar arquivo real
            clean_path = path.split("?")[0]
            file_path = self.translate_path(clean_path)

            if os.path.isfile(file_path):
                self.send_response(200)

                # Determina content-type
                if clean_path.endswith(".css"):
                    content_type = "text/css"
                elif clean_path.endswith(".js"):
                    content_type = "application/javascript"
                elif clean_path.endswith((".html", ".htm")):
                    content_type = "text/html"
                elif clean_path.endswith(".json"):
                    content_type = "application/json"
                elif clean_path.endswith(".png"):
                    content_type = "image/png"
                elif clean_path.endswith(".jpg") or clean_path.endswith(".jpeg"):
                    content_type = "image/jpeg"
                elif clean_path.endswith(".svg"):
                    content_type = "image/svg+xml"
                else:
                    content_type = self.guess_type(clean_path)

                self.send_header("Content-type", content_type)

                # HEADERS ANTI-CACHE DEFINITIVOS
                self.send_header(
                    "Cache-Control", "no-cache, no-store, must-revalidate, max-age=0"
                )
                self.send_header("Pragma", "no-cache")
                self.send_header("Expires", "0")
                self.send_header("Last-Modified", self.date_time_string(time.time()))

                self.end_headers()

                with open(file_path, "rb") as f:
                    self.wfile.write(f.read())
            else:
                self.send_error(404, f"File not found: {clean_path}")

        except Exception as e:
            print(f"âŒ Erro em {path}: {e}")
            self.send_error(404, f"Recurso nÃ£o encontrado: {path}")

    def send_json_response(self, data, status=200):
        """Resposta JSON RÃPIDA SEM compressÃ£o para simplicidade"""
        try:
            response = json.dumps(data, ensure_ascii=False).encode("utf-8")

            # Resposta direta SEM compressÃ£o
            self.send_response(status)
            self.send_header("Content-type", "application/json; charset=utf-8")
            self.send_header("Content-Length", str(len(response)))
            self.send_header("Cache-Control", "no-cache, no-store, must-revalidate")
            self.send_header("Pragma", "no-cache")
            self.send_header("Expires", "0")
            self.end_headers()
            self.wfile.write(response)

        except Exception as e:
            print(f"âŒ Erro em send_json_response: {e}")
            self.send_error(500, "Erro interno")

    def end_headers(self):
        """Headers CORS otimizados"""
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header(
            "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS"
        )
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        # Headers anti-cache
        self.send_header("Cache-Control", "no-cache, no-store, must-revalidate")
        self.send_header("Pragma", "no-cache")
        self.send_header("Expires", "0")
        super().end_headers()

    def do_OPTIONS(self):
        """CORS rÃ¡pido"""
        self.send_response(200)
        self.end_headers()

    def log_message(self, format, *args):
        """Log SILENCIOSO - apenas erros e APIs importantes"""
        message = format % args
        # Apenas logs importantes
        if any(
            keyword in message
            for keyword in [" 404", " 500", " 403", "/api/", "/obras", "/empresas"]
        ):
            print(f"ðŸŒ {self.address_string()} - {message}")

    def handle_machine_routes(self, path):
        """Rotas especÃ­ficas para mÃ¡quinas"""
        if self.command == "GET":
            if path == "/api/machines/types":
                self.route_handler.handle_get_machine_types(self)
            elif path.startswith("/api/machines/type/"):
                machine_type = path.split("/")[-1]
                self.route_handler.handle_get_machine_by_type(self, machine_type)
        elif self.command == "POST":
            # As rotas POST de mÃ¡quinas jÃ¡ sÃ£o tratadas no do_POST
            pass

    def handle_delete_empresa(self):
        """Handler para DELETE /api/empresas/{index}"""
        try:
            # Extrai o Ã­ndice da URL (ex: /api/empresas/21 -> index=21)
            index = self.path.split("/")[-1]
            print(f"ðŸ—‘ï¸  DELETE empresa - Ã­ndice: {index}")

            # Chama o mÃ©todo no RoutesCore
            result = self.routes_core.handle_delete_empresa_by_index(index)

            if result.get("success"):
                self.send_json_response(result)
            else:
                self.send_json_response(result, status=500)

        except Exception as e:
            print(f"âŒ Erro em handle_delete_empresa: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

            # PYTHON SOBRE JSON

    def handle_post_excel_upload(self):
        """Rota: /api/excel/upload"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            print(
                f"ðŸ“¤ Recebendo upload de Excel: {data.get('filename', 'desconhecido')}"
            )

            # Validar
            if "file" not in data or "filename" not in data:
                return self.send_json_response(
                    {"success": False, "error": "Arquivo ou nome nÃ£o fornecido"}, 400
                )

            # Decodificar base64
            excel_bytes = base64.b64decode(data["file"])

            # Converter
            result = converter.excel_to_json(excel_bytes, data["filename"])

            if result["success"]:
                print(f"âœ… Excel convertido com sucesso: {data['filename']}")
                self.send_json_response(result, 200)
            else:
                print(f"âŒ Erro na conversÃ£o: {result.get('error', 'desconhecido')}")
                self.send_json_response(
                    {
                        "success": False,
                        "error": result.get("error", "Erro desconhecido"),
                    },
                    400,
                )

        except json.JSONDecodeError:
            self.send_json_response({"success": False, "error": "JSON invÃ¡lido"}, 400)
        except Exception as e:
            print(f"âŒ Erro em handle_post_excel_upload: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )

    def handle_post_excel_export(self):
        """Rota: /api/excel/export"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            system_data = json.loads(post_data)

            print(f"ðŸ“¥ Recebendo dados para exportar para Excel")

            # Converter
            result = converter.json_to_excel(system_data)

            if result["success"]:
                print(f"âœ… Excel gerado com sucesso: {result['filename']}")
                self.send_json_response(result, 200)
            else:
                print(
                    f"âŒ Erro na geraÃ§Ã£o do Excel: {result.get('error', 'desconhecido')}"
                )
                self.send_json_response(
                    {
                        "success": False,
                        "error": result.get("error", "Erro desconhecido"),
                    },
                    400,
                )

        except json.JSONDecodeError:
            self.send_json_response({"success": False, "error": "JSON invÃ¡lido"}, 400)
        except Exception as e:
            print(f"âŒ Erro em handle_post_excel_export: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )

    def handle_post_system_apply_json(self):
        """Rota: /api/system/apply-json - Compara JSONs e retorna diferenÃ§as"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            current = data.get("current", {})
            proposed = data.get("proposed", {})

            print(
                f"ðŸ” Comparando JSONs: current={bool(current)}, proposed={bool(proposed)}"
            )

            # ValidaÃ§Ã£o bÃ¡sica ATUALIZADA
            required_sections = [
                "constants", 
                "machines", 
                "materials", 
                "empresas",
                "banco_equipamentos"  # ADICIONADO
            ]
            
            for section in required_sections:
                if section not in proposed:
                    return self.send_json_response(
                        {
                            "success": False,
                            "error": f"SeÃ§Ã£o '{section}' nÃ£o encontrada no JSON proposto",
                        },
                        400,
                    )

            # Calcular diferenÃ§as (jÃ¡ atualizada anteriormente)
            differences = self._calculate_simple_differences(current, proposed)
            summary = self._generate_simple_summary(differences)

            print(f"ðŸ“Š ComparaÃ§Ã£o concluÃ­da: {summary['total_changes']} alteraÃ§Ãµes")

            self.send_json_response(
                {
                    "success": True,
                    "differences": differences,
                    "summary": summary,
                    "message": "ComparaÃ§Ã£o realizada com sucesso",
                },
                200,
            )

        except json.JSONDecodeError:
            self.send_json_response({"success": False, "error": "JSON invÃ¡lido"}, 400)
        except Exception as e:
            print(f"âŒ Erro em handle_post_system_apply_json: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )

    def handle_post_json_validate(self):
        """Rota: /api/json/validate - Valida estrutura JSON"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            json_data = json.loads(post_data)
            
            print(f"ðŸ” Validando estrutura JSON")

            # Validar estrutura bÃ¡sica atualizada
            errors = []

            if not json_data.get("constants") or not isinstance(
                json_data["constants"], dict
            ):
                errors.append("constants deve ser um objeto nÃ£o vazio")

            if not json_data.get("machines") or not isinstance(
                json_data["machines"], list
            ):
                errors.append("machines deve ser um array nÃ£o vazio")

            if not json_data.get("materials") or not isinstance(
                json_data["materials"], dict
            ):
                errors.append("materials deve ser um objeto nÃ£o vazio")

            if not json_data.get("empresas") or not isinstance(
                json_data["empresas"], list
            ):
                errors.append("empresas deve ser um array nÃ£o vazio")

            # ADICIONADO: ValidaÃ§Ã£o para banco_equipamentos (opcional)
            if "banco_equipamentos" in json_data and not isinstance(
                json_data["banco_equipamentos"], dict
            ):
                errors.append("banco_equipamentos deve ser um objeto se existir")

            valid = len(errors) == 0

            print(f"âœ… ValidaÃ§Ã£o {'bem sucedida' if valid else 'com erros'}")

            self.send_json_response(
                {
                    "success": True,
                    "valid": valid,
                    "errors": errors if errors else [],
                    "message": "JSON vÃ¡lido" if valid else "JSON invÃ¡lido",
                },
                200,
            )

            if "dutos" in json_data and not isinstance(json_data["dutos"], list):
                errors.append("dutos deve ser um array se existir")
            elif "dutos" in json_data and isinstance(json_data["dutos"], list):
                # Validar estrutura de cada duto
                for i, duto in enumerate(json_data["dutos"]):
                    if not isinstance(duto, dict):
                        errors.append(f"duto no Ã­ndice {i} deve ser um objeto")
                        continue
                        
                    if "type" not in duto:
                        errors.append(f"duto no Ã­ndice {i} nÃ£o tem campo 'type'")
                    
                    if "valor" not in duto:
                        errors.append(f"duto no Ã­ndice {i} nÃ£o tem campo 'valor'")
                    
                    if "opcionais" in duto and not isinstance(duto["opcionais"], list):
                        errors.append(f"duto '{duto.get('type', f'Ã­ndice {i}')}' tem opcionais invÃ¡lidos")
            
            valid = len(errors) == 0
            
            print(f"âœ… ValidaÃ§Ã£o {'bem sucedida' if valid else 'com erros'}")
            
            self.send_json_response({
                "success": True,
                "valid": valid,
                "errors": errors if errors else [],
                "message": "JSON vÃ¡lido" if valid else "JSON invÃ¡lido"
            }, 200)
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, 400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_json_validate: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )
            
    def handle_post_json_normalize(self):
        """Rota: /api/json/normalize - Normaliza JSON"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            json_data = json.loads(post_data)

            print(f"ðŸ”„ Normalizando JSON")

            # NormalizaÃ§Ã£o completa com todas as seÃ§Ãµes
            normalized = {
                "constants": {},
                "machines": [],
                "materials": {},
                "empresas": [],
                "banco_equipamentos": {},
                "dutos": [],  # ADICIONADO
            }

            # 1. Constants
            if isinstance(json_data.get("constants"), dict):
                for key, value in json_data["constants"].items():
                    if isinstance(value, dict) and "value" in value:
                        # JÃ¡ estÃ¡ no formato correto
                        normalized["constants"][key] = {
                            "value": value.get("value", 0),
                            "description": value.get("description", ""),
                            "unit": value.get("unit", "un"),
                            "category": value.get("category", ""),
                        }
                    else:
                        # Normalizar para formato padrÃ£o
                        normalized["constants"][key] = {
                            "value": value,
                            "description": "",
                            "unit": "un",
                            "category": "",
                        }

            # 2. Machines
            if isinstance(json_data.get("machines"), list):
                for machine in json_data["machines"]:
                    if isinstance(machine, dict):
                        normalized_machine = {
                            "type": machine.get("type", ""),
                            "description": machine.get("description", ""),
                            "impostos": machine.get(
                                "impostos",
                                {
                                    "PIS_COFINS": "INCL",
                                    "IPI": "ISENTO",
                                    "ICMS": "12%",
                                    "PRAZO": "45 a 60 dias",
                                    "FRETE": "FOB/CabreÃºva/SP",
                                },
                            ),
                            "configuracoes_instalacao": machine.get(
                                "configuracoes_instalacao", []
                            ),
                            "baseValues": machine.get("baseValues", {}),
                            "options": machine.get("options", []),
                            "voltages": machine.get("voltages", []),
                            "dimensions": machine.get("dimensions", {}),
                            "peso": machine.get("peso", 0),
                            "categoria": machine.get("categoria", ""),
                        }
                        normalized["machines"].append(normalized_machine)

            # 3. Materials
            if isinstance(json_data.get("materials"), dict):
                for key, value in json_data["materials"].items():
                    if isinstance(value, dict) and "value" in value:
                        # JÃ¡ estÃ¡ no formato correto
                        normalized["materials"][key] = {
                            "value": value.get("value", 0),
                            "unit": value.get("unit", "un"),
                            "description": value.get("description", ""),
                            "category": value.get("category", ""),
                        }
                    else:
                        # Normalizar para formato padrÃ£o
                        normalized["materials"][key] = {
                            "value": value,
                            "unit": "un",
                            "description": "",
                            "category": "",
                        }

            # 4. Empresas
            if isinstance(json_data.get("empresas"), list):
                for empresa in json_data["empresas"]:
                    if isinstance(empresa, dict):
                        # Normalizar empresa para formato padrÃ£o
                        normalized_empresa = {}
                        for empresa_key, empresa_data in empresa.items():
                            if isinstance(empresa_data, dict):
                                normalized_empresa[empresa_key] = {
                                    "nome": empresa_data.get("nome", ""),
                                    "cnpj": empresa_data.get("cnpj", ""),
                                    "endereco": empresa_data.get("endereco", ""),
                                    "contato": empresa_data.get("contato", ""),
                                    "email": empresa_data.get("email", ""),
                                    "telefone": empresa_data.get("telefone", ""),
                                    "responsavel": empresa_data.get("responsavel", ""),
                                }
                            else:
                                normalized_empresa[empresa_key] = {
                                    "nome": empresa_data,
                                    "cnpj": "",
                                    "endereco": "",
                                    "contato": "",
                                    "email": "",
                                    "telefone": "",
                                    "responsavel": "",
                                }
                        normalized["empresas"].append(normalized_empresa)

            # 5. Banco de Equipamentos
            if isinstance(json_data.get("banco_equipamentos"), dict):
                for equip_type, equip_data in json_data["banco_equipamentos"].items():
                    if isinstance(equip_data, dict):
                        normalized["banco_equipamentos"][equip_type] = {
                            "descricao": equip_data.get("descricao", ""),
                            "valores_padrao": equip_data.get("valores_padrao", {}),
                            "unidade_valor": equip_data.get("unidade_valor", "un"),
                            "dimensoes": equip_data.get("dimensoes", []),
                            "categoria": equip_data.get("categoria", ""),
                            "observacoes": equip_data.get("observacoes", ""),
                        }
                    else:
                        # Se nÃ£o for dict, tratar como valores padrÃ£o simples
                        normalized["banco_equipamentos"][equip_type] = {
                            "descricao": "",
                            "valores_padrao": equip_data if isinstance(equip_data, dict) else {},
                            "unidade_valor": "un",
                            "dimensoes": [],
                            "categoria": "",
                            "observacoes": "",
                        }

            # 6. Dutos (NOVA SEÃ‡ÃƒO)
            if isinstance(json_data.get("dutos"), list):
                for duto in json_data["dutos"]:
                    if isinstance(duto, dict):
                        normalized_duto = {
                            "type": duto.get("type", ""),
                            "valor": duto.get("valor", 0),
                            "descricao": duto.get("descricao", ""),
                            "categoria": duto.get("categoria", ""),
                            "unidade": duto.get("unidade", "mÂ²"),
                            "opcionais": duto.get("opcionais", []),
                        }
                        
                        # Normalizar opcionais se existirem
                        opcionais = duto.get("opcionais", [])
                        if isinstance(opcionais, list):
                            normalized_opcionais = []
                            for opcional in opcionais:
                                if isinstance(opcional, dict):
                                    normalized_opcionais.append({
                                        "id": opcional.get("id", len(normalized_opcionais) + 1),
                                        "nome": opcional.get("nome", ""),
                                        "value": opcional.get("value", 0),
                                        "descricao": opcional.get("descricao", ""),
                                    })
                                else:
                                    # Se opcional nÃ£o for dict, criar estrutura bÃ¡sica
                                    normalized_opcionais.append({
                                        "id": len(normalized_opcionais) + 1,
                                        "nome": str(opcional),
                                        "value": 0,
                                        "descricao": "",
                                    })
                            normalized_duto["opcionais"] = normalized_opcionais
                        
                        normalized["dutos"].append(normalized_duto)
                    elif isinstance(duto, str):
                        # Se duto for string, criar estrutura bÃ¡sica
                        normalized["dutos"].append({
                            "type": duto,
                            "valor": 0,
                            "descricao": "",
                            "categoria": "",
                            "unidade": "mÂ²",
                            "opcionais": [],
                        })

            print(f"âœ… JSON normalizado - SeÃ§Ãµes: {list(normalized.keys())}")

            self.send_json_response(
                {
                    "success": True,
                    "data": normalized,
                    "summary": {
                        "constants_count": len(normalized["constants"]),
                        "machines_count": len(normalized["machines"]),
                        "materials_count": len(normalized["materials"]),
                        "empresas_count": len(normalized["empresas"]),
                        "equipamentos_count": len(normalized["banco_equipamentos"]),
                        "dutos_count": len(normalized["dutos"]),  # ADICIONADO
                        "total_items": (
                            len(normalized["constants"]) +
                            len(normalized["machines"]) +
                            len(normalized["materials"]) +
                            len(normalized["empresas"]) +
                            len(normalized["banco_equipamentos"]) +
                            len(normalized["dutos"])  # ADICIONADO
                        )
                    },
                    "message": "JSON normalizado com sucesso",
                },
                200,
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, 400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_json_normalize: {e}")
            import traceback
            traceback.print_exc()
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, 500
            )

    def _calculate_simple_differences(self, current, proposed):
        """Calcula diferenÃ§as simples entre JSONs"""
        diffs = {
            "constants": {"added": [], "modified": [], "removed": []},
            "machines": {"added": [], "modified": [], "removed": []},
            "materials": {"added": [], "modified": [], "removed": []},
            "empresas": {"added": [], "modified": [], "removed": []},
            "banco_equipamentos": {"added": [], "modified": [], "removed": []},
            "dutos": {"added": [], "modified": [], "removed": []},
        }

        # Constants
        current_const = current.get("constants", {})
        proposed_const = proposed.get("constants", {})

        for key in proposed_const:
            if key not in current_const:
                diffs["constants"]["added"].append(key)
            elif json.dumps(proposed_const[key]) != json.dumps(current_const[key]):
                diffs["constants"]["modified"].append(key)

        for key in current_const:
            if key not in proposed_const:
                diffs["constants"]["removed"].append(key)

        # Machines (por type)
        current_machines = {m.get("type", ""): m for m in current.get("machines", [])}
        proposed_machines = {m.get("type", ""): m for m in proposed.get("machines", [])}

        for type_name in proposed_machines:
            if type_name not in current_machines:
                diffs["machines"]["added"].append(type_name)
            elif json.dumps(proposed_machines[type_name]) != json.dumps(
                current_machines[type_name]
            ):
                diffs["machines"]["modified"].append(type_name)

        for type_name in current_machines:
            if type_name not in proposed_machines:
                diffs["machines"]["removed"].append(type_name)

        # Materials
        current_materials = current.get("materials", {})
        proposed_materials = proposed.get("materials", {})

        for key in proposed_materials:
            if key not in current_materials:
                diffs["materials"]["added"].append(key)
            elif json.dumps(proposed_materials[key]) != json.dumps(
                current_materials[key]
            ):
                diffs["materials"]["modified"].append(key)

        for key in current_materials:
            if key not in proposed_materials:
                diffs["materials"]["removed"].append(key)


        # Dutos (por type)
        current_dutos = {d.get("type", ""): d for d in current.get("dutos", [])}
        proposed_dutos = {d.get("type", ""): d for d in proposed.get("dutos", [])}
        
        for type_name in proposed_dutos:
            if type_name not in current_dutos:
                diffs["dutos"]["added"].append(type_name)
            elif json.dumps(proposed_dutos[type_name]) != json.dumps(current_dutos[type_name]):
                diffs["dutos"]["modified"].append(type_name)
        
        for type_name in current_dutos:
            if type_name not in proposed_dutos:
                diffs["dutos"]["removed"].append(type_name)
        
        return diffs



        # Empresas (por primeiro campo)
        def get_empresa_key(empresa):
            return next(iter(empresa)) if empresa else ""

        current_empresas_dict = {
            get_empresa_key(e): e for e in current.get("empresas", [])
        }
        proposed_empresas_dict = {
            get_empresa_key(e): e for e in proposed.get("empresas", [])
        }

        for key in proposed_empresas_dict:
            if key not in current_empresas_dict:
                diffs["empresas"]["added"].append(key)
            elif json.dumps(proposed_empresas_dict[key]) != json.dumps(
                current_empresas_dict[key]
            ):
                diffs["empresas"]["modified"].append(key)

        for key in current_empresas_dict:
            if key not in proposed_empresas_dict:
                diffs["empresas"]["removed"].append(key)

        current_equipamentos = current.get("banco_equipamentos", {})
        proposed_equipamentos = proposed.get("banco_equipamentos", {})

        for key in proposed_equipamentos:
            if key not in current_equipamentos:
                diffs["banco_equipamentos"]["added"].append(key)
            elif json.dumps(proposed_equipamentos[key]) != json.dumps(
                current_equipamentos[key]
            ):
                diffs["banco_equipamentos"]["modified"].append(key)

        for key in current_equipamentos:
            if key not in proposed_equipamentos:
                diffs["banco_equipamentos"]["removed"].append(key)

        return diffs

    def _generate_simple_summary(self, differences):
        """Gera resumo simples das diferenÃ§as"""
        total_added = (
            len(differences["constants"]["added"])
            + len(differences["machines"]["added"])
            + len(differences["materials"]["added"])
            + len(differences["empresas"]["added"])
            + len(differences["banco_equipamentos"]["added"])
            + len(differences["dutos"]["added"])  # ADICIONADO
        )
        
        total_modified = (
            len(differences["constants"]["modified"])
            + len(differences["machines"]["modified"])
            + len(differences["materials"]["modified"])
            + len(differences["empresas"]["modified"])
            + len(differences["banco_equipamentos"]["modified"])
            + len(differences["dutos"]["modified"])  # ADICIONADO
        )
        
        total_removed = (
            len(differences["constants"]["removed"])
            + len(differences["machines"]["removed"])
            + len(differences["materials"]["removed"])
            + len(differences["empresas"]["removed"])
            + len(differences["banco_equipamentos"]["removed"])
            + len(differences["dutos"]["removed"])  # ADICIONADO
        )
        
        return {
            "total_changes": total_added + total_modified + total_removed,
            "total_added": total_added,
            "total_modified": total_modified,
            "total_removed": total_removed,
            "has_changes": (total_added + total_modified + total_removed) > 0,
        }

    #    FIM DO PY SOBRE JSON

    def handle_get_equipamentos(self):
        """GET /api/equipamentos - Retorna todos os equipamentos"""
        try:
            # Carrega dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verifica se existe a seÃ§Ã£o banco_equipamentos
            banco_equipamentos = dados_data.get("banco_equipamentos", {})

            self.send_json_response(
                {
                    "success": True,
                    "equipamentos": banco_equipamentos,
                    "count": len(banco_equipamentos),
                }
            )

        except Exception as e:
            print(f"âŒ Erro em handle_get_equipamentos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_equipamento_types(self):
        """GET /api/equipamentos/types - Retorna tipos de equipamentos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            banco_equipamentos = dados_data.get("banco_equipamentos", {})
            types = list(banco_equipamentos.keys())

            # Ordenar tipos (opcional)
            types.sort()

            self.send_json_response(
                {"success": True, "types": types, "count": len(types)}
            )

        except Exception as e:
            print(f"âŒ Erro em handle_get_equipamento_types: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_equipamento_by_type(self):
        """GET /api/equipamentos/type/{type} - Retorna equipamentos por tipo"""
        try:
            # Extrair tipo da URL
            path_parts = self.path.split("/")
            if len(path_parts) < 5:
                self.send_json_response(
                    {"success": False, "error": "Tipo nÃ£o especificado na URL"},
                    status=400,
                )
                return

            tipo = path_parts[-1]

            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            banco_equipamentos = dados_data.get("banco_equipamentos", {})

            if tipo in banco_equipamentos:
                equipamento = banco_equipamentos[tipo]

                # Adicionar estatÃ­sticas
                valores = equipamento.get("valores_padrao", {})
                dimensoes = list(valores.keys())

                # Calcular preÃ§o mÃ©dio
                precos = list(valores.values())
                preco_medio = sum(precos) / len(precos) if precos else 0

                self.send_json_response(
                    {
                        "success": True,
                        "tipo": tipo,
                        "equipamento": equipamento,
                        "estatisticas": {
                            "quantidade_dimensoes": len(dimensoes),
                            "dimensoes": dimensoes[:10],  # Primeiras 10 dimensÃµes
                            "preco_medio": round(preco_medio, 2),
                            "preco_min": min(precos) if precos else 0,
                            "preco_max": max(precos) if precos else 0,
                        },
                    }
                )
            else:
                self.send_json_response(
                    {
                        "success": False,
                        "error": f"Tipo de equipamento '{tipo}' nÃ£o encontrado",
                    },
                    status=404,
                )

        except Exception as e:
            print(f"âŒ Erro em handle_get_equipamento_by_type: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_add_equipamento(self):
        """POST /api/equipamentos/add - Adiciona novo equipamento"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            # Validar dados
            required_fields = ["tipo", "descricao", "valores"]
            for field in required_fields:
                if field not in data:
                    self.send_json_response(
                        {
                            "success": False,
                            "error": f"Campo obrigatÃ³rio faltando: {field}",
                        },
                        status=400,
                    )
                    return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Garantir que existe a seÃ§Ã£o banco_equipamentos
            if "banco_equipamentos" not in dados_data:
                dados_data["banco_equipamentos"] = {}

            banco_equipamentos = dados_data["banco_equipamentos"]

            # Verificar se tipo jÃ¡ existe
            if tipo in banco_equipamentos:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' jÃ¡ existe"}, status=400
                )
                return

            # Adicionar novo equipamento
            novo_equipamento = {
                "descricao": data["descricao"],
                "valores_padrao": data["valores"],
            }

            # Adicionar dimensÃµes se fornecidas
            if "dimensoes" in data:
                novo_equipamento["dimensoes"] = data["dimensoes"]

            # Adicionar unidade se fornecida
            if "unidade_valor" in data:
                novo_equipamento["unidade_valor"] = data["unidade_valor"]

            banco_equipamentos[tipo] = novo_equipamento

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Equipamento '{tipo}' adicionado com sucesso",
                    "equipamento": novo_equipamento,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_add_equipamento: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_update_equipamento(self):
        """POST /api/equipamentos/update - Atualiza equipamento existente"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            # Validar dados
            if "tipo" not in data:
                self.send_json_response(
                    {"success": False, "error": "Campo 'tipo' Ã© obrigatÃ³rio"},
                    status=400,
                )
                return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a seÃ§Ã£o banco_equipamentos
            if "banco_equipamentos" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "SeÃ§Ã£o 'banco_equipamentos' nÃ£o encontrada",
                    },
                    status=404,
                )
                return

            banco_equipamentos = dados_data["banco_equipamentos"]

            # Verificar se tipo existe
            if tipo not in banco_equipamentos:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' nÃ£o encontrado"},
                    status=404,
                )
                return

            # Atualizar campos
            equipamento_atual = banco_equipamentos[tipo]

            if "descricao" in data:
                equipamento_atual["descricao"] = data["descricao"]

            if "valores" in data:
                equipamento_atual["valores_padrao"] = data["valores"]

            if "dimensoes" in data:
                equipamento_atual["dimensoes"] = data["dimensoes"]

            if "unidade_valor" in data:
                equipamento_atual["unidade_valor"] = data["unidade_valor"]

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Equipamento '{tipo}' atualizado com sucesso",
                    "equipamento": equipamento_atual,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_update_equipamento: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_post_delete_equipamento(self):
        """POST /api/equipamentos/delete - Remove equipamento"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)

            if "tipo" not in data:
                self.send_json_response(
                    {"success": False, "error": "Campo 'tipo' Ã© obrigatÃ³rio"},
                    status=400,
                )
                return

            tipo = data["tipo"]

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a seÃ§Ã£o banco_equipamentos
            if "banco_equipamentos" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "SeÃ§Ã£o 'banco_equipamentos' nÃ£o encontrada",
                    },
                    status=404,
                )
                return

            banco_equipamentos = dados_data["banco_equipamentos"]

            # Verificar se tipo existe
            if tipo not in banco_equipamentos:
                self.send_json_response(
                    {"success": False, "error": f"Tipo '{tipo}' nÃ£o encontrado"},
                    status=404,
                )
                return

            # Remover equipamento
            equipamento_removido = banco_equipamentos.pop(tipo)

            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)

            self.send_json_response(
                {
                    "success": True,
                    "message": f"Equipamento '{tipo}' removido com sucesso",
                    "equipamento_removido": equipamento_removido,
                }
            )

        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"}, status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_delete_equipamento: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_search_equipamentos(self):
        """GET /api/equipamentos/search?q=termo - Busca equipamentos"""
        try:
            # Extrair parÃ¢metro de busca da query string
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            termo = query_params.get("q", [""])[0].lower()

            if not termo:
                self.send_json_response(
                    {"success": False, "error": "Termo de busca nÃ£o fornecido"},
                    status=400,
                )
                return

            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a seÃ§Ã£o banco_equipamentos
            if "banco_equipamentos" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "SeÃ§Ã£o 'banco_equipamentos' nÃ£o encontrada",
                    },
                    status=404,
                )
                return

            banco_equipamentos = dados_data["banco_equipamentos"]

            resultados = []
            for tipo, dados in banco_equipamentos.items():
                # Buscar no tipo
                if termo in tipo.lower():
                    resultados.append(
                        {
                            "tipo": tipo,
                            "descricao": dados.get("descricao", ""),
                            "match": "tipo",
                            "valores_count": len(dados.get("valores_padrao", {})),
                        }
                    )
                    continue

                # Buscar na descriÃ§Ã£o
                descricao = dados.get("descricao", "").lower()
                if termo in descricao:
                    resultados.append(
                        {
                            "tipo": tipo,
                            "descricao": dados.get("descricao", ""),
                            "match": "descricao",
                            "valores_count": len(dados.get("valores_padrao", {})),
                        }
                    )
                    continue

                # Buscar nas dimensÃµes/valores
                valores = dados.get("valores_padrao", {})
                for dimensao, valor in valores.items():
                    if termo in dimensao.lower():
                        resultados.append(
                            {
                                "tipo": tipo,
                                "descricao": dados.get("descricao", ""),
                                "dimensao_encontrada": dimensao,
                                "valor": valor,
                                "match": "dimensao",
                                "valores_count": len(valores),
                            }
                        )
                        break

            self.send_json_response(
                {
                    "success": True,
                    "termo": termo,
                    "resultados": resultados,
                    "count": len(resultados),
                }
            )

        except Exception as e:
            print(f"âŒ Erro em handle_get_search_equipamentos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )

    def handle_get_equipamento_dimensoes(self):
        """GET /api/equipamentos/dimensoes - Retorna dimensÃµes disponÃ­veis"""
        try:
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"

            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404,
                )
                return

            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)

            # Verificar se existe a seÃ§Ã£o banco_equipamentos
            if "banco_equipamentos" not in dados_data:
                self.send_json_response(
                    {
                        "success": False,
                        "error": "SeÃ§Ã£o 'banco_equipamentos' nÃ£o encontrada",
                    },
                    status=404,
                )
                return

            banco_equipamentos = dados_data["banco_equipamentos"]

            # Coletar todas as dimensÃµes Ãºnicas
            todas_dimensoes = set()
            dimensoes_por_tipo = {}

            for tipo, dados in banco_equipamentos.items():
                valores = dados.get("valores_padrao", {})
                dimensoes = list(valores.keys())

                dimensoes_por_tipo[tipo] = {
                    "descricao": dados.get("descricao", ""),
                    "dimensoes": dimensoes,
                    "quantidade": len(dimensoes),
                }

                # Adicionar dimensÃµes ao conjunto geral
                todas_dimensoes.update(dimensoes)

            self.send_json_response(
                {
                    "success": True,
                    "dimensoes_por_tipo": dimensoes_por_tipo,
                    "todas_dimensoes": sorted(list(todas_dimensoes)),
                    "total_dimensoes": len(todas_dimensoes),
                }
            )

        except Exception as e:
            print(f"âŒ Erro em handle_get_equipamento_dimensoes: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"}, status=500
            )
            
            
    def handle_get_dutos(self):
        """GET /api/dutos - Retorna todos os dutos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verifica se existe a seÃ§Ã£o dutos
            dutos = dados_data.get("dutos", [])
            
            self.send_json_response({
                "success": True,
                "dutos": dutos,
                "count": len(dutos)
            })
            
        except Exception as e:
            print(f"âŒ Erro em handle_get_dutos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_types(self):
        """GET /api/dutos/types - Retorna tipos de dutos"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            # Retornar array de objetos com informaÃ§Ãµes completas
            types = []
            for duto in dutos:
                tipo = duto.get("type", "")
                if tipo:
                    types.append({
                        "value": tipo,
                        "label": tipo,
                        "descricao": duto.get("descricao", ""),
                        "valor_base": duto.get("valor", 0)
                    })
            
            # Ordenar tipos
            types.sort(key=lambda x: x["label"])
            
            self.send_json_response({
                "success": True,
                "types": types,  # Agora Ã© array de objetos
                "count": len(types)
            })
            
        except Exception as e:
            print(f"âŒ Erro em handle_get_duto_types: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_opcionais(self):
        """GET /api/dutos/opcionais - Retorna opcionais disponÃ­veis"""
        try:
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            opcionais_por_tipo = {}
            todos_opcionais = []
            todos_opcionais_dict = {}
            
            for duto in dutos:
                tipo = duto.get("type", "")
                opcionais = duto.get("opcionais", [])
                
                if not isinstance(opcionais, list):
                    opcionais = []
                
                opcionais_formatados = []
                for opcional in opcionais:
                    opcional_info = {
                        "id": opcional.get("id"),
                        "nome": opcional.get("nome", ""),
                        "value": opcional.get("value", 0),
                        "descricao": opcional.get("descricao", ""),
                        "tipo_duto": tipo
                    }
                    opcionais_formatados.append(opcional_info)
                    
                    # Adicionar Ã  lista geral de opcionais
                    if opcional.get("nome") and opcional.get("nome") not in todos_opcionais_dict:
                        todos_opcionais_dict[opcional.get("nome")] = True
                        todos_opcionais.append({
                            "nome": opcional.get("nome", ""),
                            "valor_medio": opcional.get("value", 0),
                            "descricao": opcional.get("descricao", "")
                        })
                
                opcionais_por_tipo[tipo] = {
                    "valor_base": duto.get("valor", 0),
                    "opcionais": opcionais_formatados,
                    "quantidade_opcionais": len(opcionais_formatados)
                }
            
            self.send_json_response({
                "success": True,
                "opcionais_por_tipo": opcionais_por_tipo,
                "todos_opcionais": todos_opcionais,
                "total_opcionais": len(todos_opcionais)
            })
            
        except Exception as e:
            print(f"âŒ Erro em handle_get_duto_opcionais: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_duto_by_type(self):
        """GET /api/dutos/type/{type} - Retorna duto por tipo"""
        try:
            # Extrair tipo da URL
            path_parts = self.path.split("/")
            if len(path_parts) < 5:
                self.send_json_response(
                    {"success": False, "error": "Tipo nÃ£o especificado na URL"},
                    status=400
                )
                return
                
            tipo = path_parts[-1]
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            
            for duto in dutos:
                if duto.get("type") == tipo:
                    # Garantir que opcionais Ã© um array
                    opcionais = duto.get("opcionais", [])
                    if not isinstance(opcionais, list):
                        opcionais = []
                    
                    # Calcular valor mÃ¡ximo (com todos os opcionais)
                    valor_base = duto.get("valor", 0)
                    valor_maximo = valor_base
                    for opcional in opcionais:
                        valor_maximo += opcional.get("value", 0)
                    
                    # Retornar estrutura completa que o frontend espera
                    response = {
                        "success": True,
                        "tipo": tipo,
                        "duto": {
                            "type": duto.get("type", ""),
                            "valor": valor_base,
                            "descricao": duto.get("descricao", ""),
                            "categoria": duto.get("categoria", ""),
                            "unidade": duto.get("unidade", "mÂ²"),
                            "opcionais": opcionais
                        },
                        "estatisticas": {
                            "valor_base": valor_base,
                            "valor_maximo": valor_maximo,
                            "quantidade_opcionais": len(opcionais),
                            "opcionais_disponiveis": [op.get("nome", "") for op in opcionais]
                        }
                    }
                    
                    print(f"âœ… Retornando duto '{tipo}': {len(opcionais)} opcionais")
                    self.send_json_response(response)
                    return
            
            self.send_json_response({
                "success": False,
                "error": f"Tipo de duto '{tipo}' nÃ£o encontrado"
            }, status=404)
            
        except Exception as e:
            print(f"âŒ Erro em handle_get_duto_by_type: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_get_search_dutos(self):
        """GET /api/dutos/search?q=termo - Busca dutos"""
        try:
            from urllib.parse import parse_qs
            
            parsed_path = urlparse(self.path)
            query_params = parse_qs(parsed_path.query)
            termo = query_params.get("q", [""])[0].lower()
            
            if not termo:
                self.send_json_response(
                    {"success": False, "error": "Termo de busca nÃ£o fornecido"},
                    status=400
                )
                return
            
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            dutos = dados_data.get("dutos", [])
            resultados = []
            
            for duto in dutos:
                tipo = duto.get("type", "").lower()
                
                # Buscar no tipo
                if termo in tipo:
                    resultados.append({
                        "tipo": duto.get("type", ""),
                        "valor_base": duto.get("valor", 0),
                        "match": "tipo",
                        "opcionais_count": len(duto.get("opcionais", []))
                    })
                    continue
                
                # Buscar nos opcionais
                opcionais = duto.get("opcionais", [])
                for opcional in opcionais:
                    nome_opcional = opcional.get("nome", "").lower()
                    if termo in nome_opcional:
                        resultados.append({
                            "tipo": duto.get("type", ""),
                            "valor_base": duto.get("valor", 0),
                            "opcional_encontrado": opcional.get("nome", ""),
                            "valor_opcional": opcional.get("value", 0),
                            "match": "opcional",
                            "opcionais_count": len(opcionais)
                        })
                        break
            
            self.send_json_response({
                "success": True,
                "termo": termo,
                "resultados": resultados,
                "count": len(resultados)
            })
            
        except Exception as e:
            print(f"âŒ Erro em handle_get_search_dutos: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_add_duto(self):
        """POST /api/dutos/add - Adiciona novo duto"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            required_fields = ["type", "valor"]
            for field in required_fields:
                if field not in data:
                    self.send_json_response({
                        "success": False,
                        "error": f"Campo obrigatÃ³rio faltando: {field}"
                    }, status=400)
                    return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Garantir que existe a seÃ§Ã£o dutos
            if "dutos" not in dados_data:
                dados_data["dutos"] = []
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo jÃ¡ existe
            for duto in dutos:
                if duto.get("type") == tipo:
                    self.send_json_response({
                        "success": False,
                        "error": f"Tipo '{tipo}' jÃ¡ existe"
                    }, status=400)
                    return
            
            # Adicionar novo duto
            novo_duto = {
                "type": data["type"],
                "valor": data["valor"]
            }
            
            # Adicionar opcionais se fornecidos
            if "opcionais" in data:
                novo_duto["opcionais"] = data["opcionais"]
            else:
                novo_duto["opcionais"] = []
            
            # Adicionar descriÃ§Ã£o se fornecida
            if "descricao" in data:
                novo_duto["descricao"] = data["descricao"]
            
            dutos.append(novo_duto)
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' adicionado com sucesso",
                "duto": novo_duto
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"},
                status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_add_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_update_duto(self):
        """POST /api/dutos/update - Atualiza duto existente"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Validar dados
            if "type" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'type' Ã© obrigatÃ³rio"
                }, status=400)
                return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a seÃ§Ã£o dutos
            if "dutos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "SeÃ§Ã£o 'dutos' nÃ£o encontrada"
                }, status=404)
                return
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo existe
            duto_encontrado = None
            duto_index = -1
            
            for i, duto in enumerate(dutos):
                if duto.get("type") == tipo:
                    duto_encontrado = duto
                    duto_index = i
                    break
            
            if duto_index == -1:
                self.send_json_response({
                    "success": False,
                    "error": f"Tipo '{tipo}' nÃ£o encontrado"
                }, status=404)
                return
            
            # Atualizar campos
            if "valor" in data:
                dutos[duto_index]["valor"] = data["valor"]
            
            if "opcionais" in data:
                dutos[duto_index]["opcionais"] = data["opcionais"]
            
            if "descricao" in data:
                dutos[duto_index]["descricao"] = data["descricao"]
            
            # Salvar dados atualizados
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' atualizado com sucesso",
                "duto": dutos[duto_index]
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"},
                status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_update_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )

    def handle_post_delete_duto(self):
        """POST /api/dutos/delete - Remove duto"""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            if "type" not in data:
                self.send_json_response({
                    "success": False,
                    "error": "Campo 'type' Ã© obrigatÃ³rio"
                }, status=400)
                return
            
            tipo = data["type"]
            
            # Carregar dados.json
            dados_file = self.project_root / "json" / "dados.json"
            
            if not dados_file.exists():
                self.send_json_response(
                    {"success": False, "error": "Arquivo dados.json nÃ£o encontrado"},
                    status=404
                )
                return
                
            with open(dados_file, "r", encoding="utf-8") as f:
                dados_data = json.load(f)
            
            # Verificar se existe a seÃ§Ã£o dutos
            if "dutos" not in dados_data:
                self.send_json_response({
                    "success": False,
                    "error": "SeÃ§Ã£o 'dutos' nÃ£o encontrada"
                }, status=404)
                return
            
            dutos = dados_data["dutos"]
            
            # Verificar se tipo existe
            duto_removido = None
            novos_dutos = []
            
            for duto in dutos:
                if duto.get("type") == tipo:
                    duto_removido = duto
                else:
                    novos_dutos.append(duto)
            
            if duto_removido is None:
                self.send_json_response({
                    "success": False,
                    "error": f"Tipo '{tipo}' nÃ£o encontrado"
                }, status=404)
                return
            
            # Salvar dados atualizados
            dados_data["dutos"] = novos_dutos
            with open(dados_file, "w", encoding="utf-8") as f:
                json.dump(dados_data, f, ensure_ascii=False, indent=2)
            
            self.send_json_response({
                "success": True,
                "message": f"Duto '{tipo}' removido com sucesso",
                "duto_removido": duto_removido
            })
            
        except json.JSONDecodeError:
            self.send_json_response(
                {"success": False, "error": "JSON invÃ¡lido"},
                status=400
            )
        except Exception as e:
            print(f"âŒ Erro em handle_post_delete_duto: {e}")
            self.send_json_response(
                {"success": False, "error": f"Erro interno: {str(e)}"},
                status=500
            )
/* ==== FIM: handlers/http_handler.py ==== */

/* ==== INÃCIO: handlers/route_handler.py ==== */
"""
route_handler.py
Handler principal de rotas - Interface entre HTTP e Core
"""

import json
from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import os

class RouteHandler:
    """Manipula o roteamento de requisiÃ§Ãµes HTTP"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        
        # RoutesCore serÃ¡ injetado depois para evitar import circular
        self.routes_core = None
    
    def set_routes_core(self, routes_core):
        """Define o RoutesCore apÃ³s a inicializaÃ§Ã£o para evitar import circular"""
        self.routes_core = routes_core

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self, handler):
        """GET /obras"""
        obras = self.routes_core.handle_get_obras()
        handler.send_json_response(obras)

    def handle_get_obra_by_id(self, handler, obra_id):
        """GET /obras/{id}"""
        obra = self.routes_core.handle_get_obra_by_id(obra_id)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} nÃ£o encontrada")

    def handle_post_obras(self, handler):
        """POST /obras"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_post_obras(post_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(500, "Erro ao salvar obra")

    def handle_put_obra(self, handler):
        """PUT /obras/{id}"""
        obra_id = handler.path.split('/')[-1]
        content_length = int(handler.headers['Content-Length'])
        put_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_put_obra(obra_id, put_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} nÃ£o encontrada")

    def handle_delete_obra(self, handler, obra_id):
        """DELETE /obras/{id}"""
        success = self.routes_core.handle_delete_obra(obra_id)
        if success:
            handler.send_json_response({
                "success": True,
                "message": f"Obra {obra_id} deletada com sucesso"
            })
        else:
            handler.send_error(500, "Erro ao deletar obra")

    # ========== ROTAS DE EMPRESAS ==========

    def handle_get_empresas(self, handler):
        """GET /api/dados/empresas"""
        empresas = self.routes_core.handle_get_empresas()
        handler.send_json_response(empresas)
        
    def handle_get_proximo_numero(self, handler, sigla):
        """GET /api/dados/empresas/numero/{sigla}"""
        numero = self.routes_core.handle_get_proximo_numero(sigla)
        handler.send_json_response(numero)

    def handle_post_empresas(self, handler):
        """POST /api/dados/empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas(post_data)
        handler.send_json_response(result)

    def handle_buscar_empresas(self, handler, termo):
        """GET /api/dados/empresas/buscar/{termo}"""
        result = self.routes_core.handle_buscar_empresas(termo)
        handler.send_json_response(result)

    # ========== ROTAS DE SESSÃƒO ==========

    def handle_get_sessions_current(self, handler):
        """GET /api/sessions/current"""
        session_data = self.routes_core.handle_get_sessions_current()
        handler.send_json_response(session_data)

    def handle_post_sessions_add_obra(self, handler):
        """POST /api/sessions/add-obra"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_sessions_add_obra(post_data)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_delete_sessions_remove_obra(self, handler, obra_id):
        """DELETE /api/sessions/remove-obra/{id}"""
        result = self.routes_core.handle_delete_sessions_remove_obra(obra_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_get_session_obras(self, handler):
        """GET /api/session-obras"""
        result = self.routes_core.handle_get_session_obras()
        handler.send_json_response(result)

    def handle_post_sessions_shutdown(self, handler):
        """POST /api/sessions/shutdown"""
        result = self.routes_core.handle_post_sessions_shutdown()
        handler.send_json_response(result)

    def handle_shutdown(self, handler):
        """POST /api/shutdown"""
        response = self.routes_core.handle_shutdown()
        handler.send_json_response(response)

    def handle_post_sessions_ensure_single(self, handler):
        """POST /api/sessions/ensure-single"""
        result = self.routes_core.handle_post_sessions_ensure_single()
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    # ========== ROTAS DE SISTEMA ==========

    def handle_get_server_uptime(self, handler):
        """GET /api/server/uptime"""
        result = self.routes_core.handle_get_server_uptime()
        handler.send_json_response(result)

    def handle_get_constants(self, handler):
        """GET /constants"""
        constants = self.routes_core.handle_get_constants()
        handler.send_json_response(constants)

    def handle_get_machines(self, handler):
        """GET /machines"""
        machines = self.routes_core.handle_get_machines()
        handler.send_json_response(machines)

    def handle_get_dados(self, handler):
        """GET /dados"""
        dados = self.routes_core.handle_get_dados()
        handler.send_json_response(dados)

    def handle_get_backup(self, handler):
        """GET /backup"""
        backup = self.routes_core.handle_get_backup()
        handler.send_json_response(backup)

    def handle_get_backup_completo(self, handler):
        """GET /api/backup-completo"""
        backup = self.routes_core.handle_get_backup_completo()
        handler.send_json_response(backup)

    def handle_post_dados(self, handler):
        """POST /dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_dados(post_data)
        handler.send_json_response(result)

    def handle_post_backup(self, handler):
        """POST /backup"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_backup(post_data)
        handler.send_json_response(result)

    def handle_post_reload_page(self, handler):
        """POST /api/reload-page"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_reload_page(post_data)
        handler.send_json_response(result)

    # ========== ROTAS DE COMPATIBILIDADE ==========

    def handle_get_projetos(self, handler):
        """GET /projetos (legacy)"""
        projetos = self.routes_core.handle_get_projetos()
        handler.send_json_response(projetos)

    def handle_post_projetos(self, handler):
        """POST /projetos (legacy)"""
        handler.send_error(501, "Use o endpoint /obras em vez de /projetos")

    def handle_get_session_projects(self, handler):
        """GET /api/session-projects (legacy)"""
        handler.send_json_response([])

    def handle_delete_sessions_remove_project(self, handler, project_id):
        """DELETE /api/sessions/remove-project/{id} (legacy)"""
        result = self.routes_core.handle_delete_sessions_remove_project(project_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])
        
    def handle_post_empresas_auto(self, handler):
        """POST /api/dados/empresas/auto"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas_auto(post_data)
        handler.send_json_response(result)
        
            # ========== ROTA UNIVERSAL DELETE ==========
    
    def handle_delete_universal(self, handler):
        """DELETE /api/delete - Rota universal para deletar qualquer item"""
        result = self.routes_core.handle_delete_universal_from_handler(handler)
        handler.send_json_response(result)
        
        
        
    # ========== ROTAS PARA SISTEMA DE EDIÃ‡ÃƒO ==========
    # ========== ROTAS PARA SISTEMA DE EDIÃ‡ÃƒO ==========

    def handle_get_system_data(self, handler):
        """GET /api/system-data - Retorna TODOS os dados do sistema"""
        system_data = self.routes_core.handle_get_system_data()
        handler.send_json_response(system_data)

    def handle_get_constants_json(self, handler):
        """GET /api/constants - Retorna apenas as constantes"""
        constants = self.routes_core.handle_get_constants_json()
        handler.send_json_response(constants)

    def handle_get_materials(self, handler):
        """GET /api/materials - Retorna materiais"""
        materials = self.routes_core.handle_get_materials()
        handler.send_json_response(materials)

    def handle_get_all_empresas(self, handler):
        """GET /api/empresas/all - Retorna todas empresas formatadas"""
        empresas = self.routes_core.handle_get_all_empresas()
        handler.send_json_response(empresas)

    def handle_get_machine_types(self, handler):
        """GET /api/machines/types - Retorna tipos de mÃ¡quinas"""
        machine_types = self.routes_core.handle_get_machine_types()
        handler.send_json_response(machine_types)

    def handle_get_machine_by_type(self, handler, machine_type):
        """GET /api/machines/type/{type} - Retorna mÃ¡quina especÃ­fica"""
        machine = self.routes_core.handle_get_machine_by_type(machine_type)
        if machine:
            handler.send_json_response(machine)
        else:
            handler.send_error(404, f"MÃ¡quina tipo {machine_type} nÃ£o encontrada")

    def handle_post_save_system_data(self, handler):
        """POST /api/system-data/save - Salva todos os dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_system_data(post_data)
        handler.send_json_response(result)

    def handle_post_save_constants(self, handler):
        """POST /api/constants/save - Salva constantes"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_constants(post_data)
        handler.send_json_response(result)

    def handle_post_save_materials(self, handler):
        """POST /api/materials/save - Salva materiais"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_materials(post_data)
        handler.send_json_response(result)

    def handle_post_save_empresas(self, handler):
        """POST /api/empresas/save - Salva empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_empresas(post_data)
        handler.send_json_response(result)

    def handle_post_save_machines(self, handler):
        """POST /api/machines/save - Salva mÃ¡quinas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_save_machines(post_data)
        handler.send_json_response(result)

    def handle_post_add_machine(self, handler):
        """POST /api/machines/add - Adiciona nova mÃ¡quina"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_add_machine(post_data)
        handler.send_json_response(result)

    def handle_post_update_machine(self, handler):
        """POST /api/machines/update - Atualiza mÃ¡quina existente"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_update_machine(post_data)
        handler.send_json_response(result)

    def handle_post_empresas_auto(self, handler):
        """POST /api/dados/empresas/auto"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas_auto(post_data)
        handler.send_json_response(result)

    # ========== ROTAS EXISTENTES QUE PODEM FALTAR ==========

    def handle_get_projetos(self, handler):
        """GET /projetos (legacy)"""
        projetos = self.routes_core.handle_get_projetos()
        handler.send_json_response(projetos)

    def handle_get_session_projects(self, handler):
        """GET /api/session-projects (legacy)"""
        handler.send_json_response([])

    def handle_health_check(self, handler):
        """GET /health-check"""
        handler.send_json_response({"status": "online", "timestamp": time.time()})

    def handle_get_server_uptime(self, handler):
        """GET /api/server/uptime"""
        result = self.routes_core.handle_get_server_uptime()
        handler.send_json_response(result)
        
        
    def handle_delete_empresa(self, handler, index):
        """DELETE /api/empresas/{index}"""
        result = self.routes_core.handle_delete_empresa(index)
        handler.send_json_response(result)
        
        
    def handle_post_excel_upload(self, handler):
        """POST /api/excel/upload"""
        # Delegar para o handler HTTP
        handler.handle_post_excel_upload()

    def handle_post_excel_export(self, handler):
        """POST /api/excel/export"""
        # Delegar para o handler HTTP
        handler.handle_post_excel_export()

    def handle_post_system_apply_json(self, handler):
        """POST /api/system/apply-json"""
        # Delegar para o handler HTTP
        handler.handle_post_system_apply_json()

    def handle_post_json_validate(self, handler):
        """POST /api/json/validate"""
        # Delegar para o handler HTTP
        handler.handle_post_json_validate()

    def handle_post_json_normalize(self, handler):
        """POST /api/json/normalize"""
        # Delegar para o handler HTTP
        handler.handle_post_json_normalize()

    def handle_post_system_compare(self, handler):
        """POST /api/system/compare (alias para apply-json)"""
        # Delegar para o handler HTTP
        handler.handle_post_system_apply_json()
        
    # route_handler.py - Adicionar estes mÃ©todos:

    def handle_get_equipamentos(self, handler):
        """GET /api/equipamentos"""
        handler.handle_get_equipamentos()

    def handle_get_equipamento_types(self, handler):
        """GET /api/equipamentos/types"""
        handler.handle_get_equipamento_types()

    def handle_get_equipamento_dimensoes(self, handler):
        """GET /api/equipamentos/dimensoes"""
        handler.handle_get_equipamento_dimensoes()

    def handle_get_equipamento_by_type(self, handler):
        """GET /api/equipamentos/type/{type}"""
        handler.handle_get_equipamento_by_type()

    def handle_get_search_equipamentos(self, handler):
        """GET /api/equipamentos/search"""
        handler.handle_get_search_equipamentos()

    def handle_post_add_equipamento(self, handler):
        """POST /api/equipamentos/add"""
        handler.handle_post_add_equipamento()

    def handle_post_update_equipamento(self, handler):
        """POST /api/equipamentos/update"""
        handler.handle_post_update_equipamento()

    def handle_post_delete_equipamento(self, handler):
        """POST /api/equipamentos/delete"""
        handler.handle_post_delete_equipamento()
        
            
    def handle_get_dutos(self, handler):
        """GET /api/dutos"""
        handler.handle_get_dutos()

    def handle_get_duto_types(self, handler):
        """GET /api/dutos/types"""
        handler.handle_get_duto_types()

    def handle_get_duto_opcionais(self, handler):
        """GET /api/dutos/opcionais"""
        handler.handle_get_duto_opcionais()

    def handle_get_duto_by_type(self, handler):
        """GET /api/dutos/type/{type}"""
        handler.handle_get_duto_by_type()

    def handle_get_search_dutos(self, handler):
        """GET /api/dutos/search"""
        handler.handle_get_search_dutos()

    def handle_post_add_duto(self, handler):
        """POST /api/dutos/add"""
        handler.handle_post_add_duto()

    def handle_post_update_duto(self, handler):
        """POST /api/dutos/update"""
        handler.handle_post_update_duto()

    def handle_post_delete_duto(self, handler):
        """POST /api/dutos/delete"""
        handler.handle_post_delete_duto()
/* ==== FIM: handlers/route_handler.py ==== */

/* ==== INÃCIO: core/routes_core.py ==== */
# servidor_modules/core/routes_core.py

"""
routes_core.py
NÃºcleo das rotas - DivisÃ£o lÃ³gica das funcionalidades
"""

import json
import time
import threading
from pathlib import Path



class RoutesCore:
    """NÃºcleo das funcionalidades de rotas organizadas por categoria"""

    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner

        # Inicializa EmpresaHandler com file_utils injetado
        from servidor_modules.handlers.empresa_handler import EmpresaHandler

        self.empresa_handler = EmpresaHandler(file_utils=self.file_utils)

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self):
        """ObtÃ©m todas as obras da sessÃ£o atual"""
        try:
            print("ðŸŽ¯ [OBRAS] Obtendo obras da sessÃ£o")

            current_session_id = self.sessions_manager.get_current_session_id()
            session_data = self.sessions_manager._load_sessions_data()
            session_obra_ids = (
                session_data["sessions"].get(current_session_id, {}).get("obras", [])
            )

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return []

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_data = json.loads(f.read())

            obras = backup_data.get("obras", [])
            if not isinstance(obras, list):
                obras = []

            obras_da_sessao = []
            for obra in obras:
                if not isinstance(obra, dict):
                    continue

                obra_id = str(obra.get("id", ""))
                if obra_id in session_obra_ids:
                    obras_da_sessao.append(obra)

            print(f"ðŸŽ¯ ENVIANDO: {len(obras_da_sessao)} obras da sessÃ£o")
            return obras_da_sessao

        except Exception as e:
            print(f"âŒ ERRO em handle_get_obras: {str(e)}")
            return []

    def handle_get_obra_by_id(self, obra_id):
        """ObtÃ©m uma obra especÃ­fica por ID"""
        try:
            print(f"ðŸŽ¯ [OBRA POR ID] Buscando obra {obra_id}")

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return None

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_data = json.loads(f.read())

            obras = backup_data.get("obras", [])

            for obra in obras:
                if str(obra.get("id")) == obra_id:
                    print(f"âœ… Obra {obra_id} encontrada")
                    return obra

            print(f"âŒ Obra {obra_id} nÃ£o encontrada")
            return None

        except Exception as e:
            print(f"âŒ ERRO em handle_get_obra_by_id: {str(e)}")
            return None

    def handle_post_obras(self, post_data):
        """Salva nova obra e adiciona Ã  sessÃ£o - COM VERIFICAÃ‡ÃƒO DE EMPRESA"""
        try:
            nova_obra = json.loads(post_data)

            # ðŸ†• VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE SALVAR OBRA
            print("ðŸ” [OBRA] Verificando se precisa criar empresa automaticamente...")
            nova_obra = self.empresa_handler.verificar_e_criar_empresa_automatica(
                nova_obra
            )

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(
                backup_file, {"obras": [], "projetos": []}
            )

            obra_id = nova_obra.get("id")

            if not obra_id or obra_id.isdigit():
                import random
                import string

                letters = "abcdefghjkmnpqrstwxyz"
                random_letter1 = random.choice(letters)
                random_letter2 = random.choice(letters)
                random_num = random.randint(10, 99)
                obra_id = f"obra_{random_letter1}{random_num}"

                print(f"ðŸ†• Backend gerou ID seguro: {obra_id}")

            nova_obra["id"] = obra_id

            print(f"ðŸ“ Tentando adicionar obra {obra_id} Ã  sessÃ£o...")
            success = self.sessions_manager.add_obra_to_session(obra_id)

            if not success:
                print(f"âŒ FALHA ao adicionar obra {obra_id} Ã  sessÃ£o")
                return None

            obras = backup_data.get("obras", [])
            obras.append(nova_obra)
            backup_data["obras"] = obras

            print(f"âž• ADICIONANDO nova obra ID: {obra_id}")

            if self.file_utils.save_json_file(backup_file, backup_data):
                print(f"âœ… Obra {obra_id} salva com sucesso")
                return nova_obra
            else:
                return None

        except Exception as e:
            print(f"âŒ Erro ao adicionar obra: {str(e)}")
            return None

    # NO routes_core.py, MODIFIQUE tambÃ©m o mÃ©todo handle_put_obra:

    def handle_put_obra(self, obra_id, put_data):
        """Atualiza obra existente - COM VERIFICAÃ‡ÃƒO DE EMPRESA"""
        try:
            obra_atualizada = json.loads(put_data)

            # ðŸ†• VERIFICAR E CRIAR EMPRESA AUTOMATICAMENTE ANTES DE ATUALIZAR OBRA
            print(
                "ðŸ” [OBRA UPDATE] Verificando se precisa criar empresa automaticamente..."
            )
            obra_atualizada = self.empresa_handler.verificar_e_criar_empresa_automatica(
                obra_atualizada
            )

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(backup_file)

            if not backup_data:
                return None

            obras = backup_data.get("obras", [])
            obra_encontrada = False

            for i, obra in enumerate(obras):
                if str(obra.get("id")) == obra_id:
                    obras[i] = obra_atualizada
                    obra_encontrada = True
                    print(f"âœï¸  ATUALIZANDO obra {obra_id}")
                    break

            if not obra_encontrada:
                return None

            backup_data["obras"] = obras

            if self.file_utils.save_json_file(backup_file, backup_data):
                return obra_atualizada
            else:
                return None

        except Exception as e:
            print(f"âŒ Erro ao atualizar obra: {str(e)}")
            return None

    def handle_delete_obra(self, obra_id):
        """Deleta uma obra do servidor"""
        try:
            print(f"ðŸ—‘ï¸  Deletando obra {obra_id} do servidor")

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": []})

            obras = backup_data.get("obras", [])
            obra_encontrada = False

            obras_atualizadas = []
            for obra in obras:
                if str(obra.get("id")) != obra_id:
                    obras_atualizadas.append(obra)
                else:
                    obra_encontrada = True
                    print(f"âœ… Obra {obra_id} encontrada para remoÃ§Ã£o")

            if not obra_encontrada:
                return False

            backup_data["obras"] = obras_atualizadas

            if self.file_utils.save_json_file(backup_file, backup_data):
                self.sessions_manager.remove_obra(obra_id)
                return True
            else:
                return False

        except Exception as e:
            print(f"âŒ Erro ao deletar obra: {str(e)}")
            return False

    # ========= Metodos para empresas ========
    def handle_get_empresas(self):
        """ObtÃ©m todas as empresas"""
        try:
            empresas = self.empresa_handler.obter_empresas()
            return {"success": True, "empresas": empresas}
        except Exception as e:
            print(f"âŒ Erro ao obter empresas: {e}")
            return {"success": False, "error": str(e)}

    def handle_post_empresas(self, post_data):
        """Adiciona nova empresa"""
        try:
            empresa_data = json.loads(post_data)
            sucesso, mensagem = self.empresa_handler.adicionar_empresa(empresa_data)

            return {"success": sucesso, "message": mensagem}
        except Exception as e:
            print(f"âŒ Erro ao adicionar empresa: {e}")
            return {"success": False, "error": str(e)}

    def handle_buscar_empresas(self, termo):
        """Busca empresas por termo"""
        try:
            from urllib.parse import unquote

            termo_decodificado = unquote(termo)
            resultados = self.empresa_handler.buscar_empresa_por_termo(
                termo_decodificado
            )

            return {"success": True, "resultados": resultados}
        except Exception as e:
            print(f"âŒ Erro ao buscar empresas: {e}")
            return {"success": False, "error": str(e), "resultados": []}

    def handle_get_proximo_numero(self, sigla):
        """ObtÃ©m prÃ³ximo nÃºmero para sigla"""
        try:
            from urllib.parse import unquote

            sigla_decodificada = unquote(sigla)
            numero = self.empresa_handler.obter_proximo_numero_cliente(
                sigla_decodificada
            )

            return {"success": True, "numero": numero}
        except Exception as e:
            print(f"âŒ Erro ao obter prÃ³ximo nÃºmero: {e}")
            return {"success": False, "error": str(e), "numero": 1}

    # ========== ROTAS DE SESSÃƒO ==========

    def handle_get_sessions_current(self):
        """Retorna a sessÃ£o atual"""
        try:
            data = self.sessions_manager._load_sessions_data()
            current_session_id = self.sessions_manager.get_current_session_id()

            if current_session_id not in data["sessions"]:
                return {"sessions": {}}

            current_session = {current_session_id: data["sessions"][current_session_id]}

            print(f"ðŸ“Š Retornando sessÃ£o {current_session_id}")
            return {"sessions": current_session}

        except Exception as e:
            print(f"âŒ Erro ao obter sessÃ£o atual: {str(e)}")
            return {"sessions": {}}

    def handle_post_sessions_add_obra(self, post_data):
        """Adiciona uma obra Ã  sessÃ£o atual"""
        try:
            data = json.loads(post_data)
            obra_id = data.get("obra_id")

            if not obra_id:
                return {"success": False, "error": "ID da obra nÃ£o fornecido"}

            print(f"âž• Adicionando obra {obra_id} Ã  sessÃ£o")
            success = self.sessions_manager.add_obra_to_session(obra_id)

            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} adicionada Ã  sessÃ£o",
                }
            else:
                return {"success": False, "error": "Erro ao adicionar obra Ã  sessÃ£o"}

        except Exception as e:
            print(f"âŒ Erro ao adicionar obra Ã  sessÃ£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_delete_sessions_remove_obra(self, obra_id):
        """Remove uma obra da sessÃ£o atual"""
        try:
            print(f"ðŸ—‘ï¸  Removendo obra {obra_id} da sessÃ£o")

            success = self.sessions_manager.remove_obra(obra_id)

            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} removida da sessÃ£o",
                }
            else:
                return {"success": False, "error": "Erro ao remover obra da sessÃ£o"}

        except Exception as e:
            print(f"âŒ Erro ao remover obra da sessÃ£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_get_session_obras(self):
        """Retorna apenas os IDs das obras da sessÃ£o atual"""
        try:
            session_obras = self.sessions_manager.get_session_obras()
            current_session_id = self.sessions_manager.get_current_session_id()

            print(
                f"ðŸ“‹ [SESSION-OBRAS] SessÃ£o {current_session_id} - Obras: {session_obras}"
            )

            return {"session_id": current_session_id, "obras": session_obras}

        except Exception as e:
            print(f"âŒ Erro em handle_get_session_obras: {str(e)}")
            return {"session_id": "error", "obras": []}

    def handle_post_sessions_shutdown(self):
        """Limpa COMPLETAMENTE TODAS as sessÃµes"""
        try:
            print(f"ðŸ”´ SHUTDOWN COMPLETO: Deletando TODAS as sessÃµes")

            data_before = self.sessions_manager._load_sessions_data()
            print(f"ðŸ“„ Estado ANTES do shutdown: {data_before}")

            success = self.sessions_manager.clear_session()

            data_after = self.sessions_manager._load_sessions_data()
            print(f"ðŸ“„ Estado DEPOIS do shutdown: {data_after}")

            is_empty = (
                not data_after.get("sessions")
                or data_after["sessions"] == {}
                or (
                    data_after.get("sessions", {})
                    .get("session_active", {})
                    .get("obras", [])
                    == []
                )
            )

            if success and is_empty:
                return {
                    "success": True,
                    "message": "SessÃµes DELETADAS completamente",
                    "final_state": data_after,
                }
            else:
                print("ðŸ”„ MÃ©todo normal falhou - forÃ§ando limpeza...")
                success = self.sessions_manager.force_clear_all_sessions()
                data_final = self.sessions_manager._load_sessions_data()

                final_is_empty = (
                    not data_final.get("sessions")
                    or data_final["sessions"] == {}
                    or (
                        data_final.get("sessions", {})
                        .get("session_active", {})
                        .get("obras", [])
                        == []
                    )
                )

                if success and final_is_empty:
                    return {
                        "success": True,
                        "message": "SessÃµes DELETADAS (forÃ§ado)",
                        "final_state": data_final,
                    }
                else:
                    print(
                        f"âš ï¸  SessÃ£o final nÃ£o estÃ¡ completamente vazia, mas considerando sucesso: {data_final}"
                    )
                    return {
                        "success": True,
                        "message": "SessÃµes limpas com aviso",
                        "final_state": data_final,
                        "warning": "SessÃ£o pode conter dados residuais",
                    }

        except Exception as e:
            print(f"âŒ Erro no shutdown: {str(e)}")
            return {
                "success": True,
                "message": "SessÃµes limpas (com erro ignorado)",
                "error_ignored": str(e),
            }

    def handle_post_sessions_ensure_single(self):
        """Garante que apenas uma sessÃ£o esteja ativa por vez"""
        try:
            print(f"ðŸ”’ Garantindo sessÃ£o Ãºnica")

            success = self.sessions_manager.ensure_single_session()
            current_session_id = self.sessions_manager.get_current_session_id()
            obra_ids = self.sessions_manager.get_session_obras()

            if success:
                return {
                    "success": True,
                    "message": "SessÃ£o Ãºnica configurada",
                    "session_id": current_session_id,
                    "obras_count": len(obra_ids),
                    "obras": obra_ids,
                }
            else:
                return {"success": False, "error": "Erro ao configurar sessÃ£o Ãºnica"}

        except Exception as e:
            print(f"âŒ Erro ao configurar sessÃ£o Ãºnica: {str(e)}")
            return {"success": False, "error": str(e)}

    # ========== ROTAS DE SISTEMA ==========

    def handle_shutdown(self):
        """Encerra o servidor com limpeza de cache"""
        try:
            print("ðŸ”´ SHUTDOWN SOLICITADO VIA BOTÃƒO - ENCERRANDO SERVIDOR")

            response = {
                "status": "shutting_down",
                "message": "Servidor encerrado com sucesso via botÃ£o",
                "action": "close_window",
                "close_delay": 3000,
            }

            print("âœ… Resposta enviada ao cliente - servidor serÃ¡ encerrado")

            def shutdown_sequence():
                print("ðŸ”„ Iniciando sequÃªncia de encerramento...")

                try:
                    print("ðŸ§¹ Executando limpeza de cache...")
                    self.cache_cleaner.clean_pycache_async()
                except Exception as cache_error:
                    print(f"âš ï¸  Erro na limpeza de cache: {cache_error}")

                time.sleep(2)
                print("ðŸ’¥ ForÃ§ando encerramento do processo Python...")

                import os

                os._exit(0)

            shutdown_thread = threading.Thread(target=shutdown_sequence)
            shutdown_thread.daemon = True
            shutdown_thread.start()

            return response

        except Exception as e:
            print(f"âŒ Erro no shutdown: {str(e)}")

            try:
                self.cache_cleaner.clean_pycache_async()
            except:
                pass

            import os

            os._exit(0)

    def handle_get_constants(self):
        """Constants do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            constants = dados_data.get("constants", {})
            print(f"âš™ï¸  Retornando constants")
            return constants

        except Exception as e:
            print(f"âŒ Erro ao carregar constants: {str(e)}")
            return {}

    def handle_get_machines(self):
        """Machines do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            machines = dados_data.get("machines", [])
            print(f"ðŸ–¥ï¸  Retornando {len(machines)} mÃ¡quinas")
            return machines

        except Exception as e:
            print(f"âŒ Erro ao carregar machines: {str(e)}")
            return []

    def handle_get_dados(self):
        """DADOS.json completo"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(
                dados_file, {
                    "constants": {}, 
                    "machines": [],
                    "materials": {},
                    "empresas": [],
                    "banco_equipamentos": {}  # ADICIONE AQUI
                }
            )

            print("ðŸ“ Retornando DADOS.json")
            return dados_data

        except Exception as e:
            print(f"âŒ Erro ao carregar dados: {str(e)}")
            return {"constants": {}, "machines": []}

    def handle_get_backup(self):
        """BACKUP.json completo"""
        try:
            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )
            backup_data = self.file_utils.load_json_file(
                backup_file, {"obras": [], "projetos": []}
            )

            print("ðŸ’¾ Retornando BACKUP.json")
            return backup_data

        except Exception as e:
            print(f"âŒ Erro ao carregar backup: {str(e)}")
            return {"obras": [], "projetos": []}

    def handle_get_backup_completo(self):
        """ObtÃ©m TODAS as obras do backup (sem filtro de sessÃ£o)"""
        try:
            print("ðŸŽ¯ [BACKUP COMPLETO] Obtendo TODAS as obras")

            backup_path = self.project_root / "json" / "backup.json"

            if not backup_path.exists():
                return {"obras": []}

            with open(backup_path, "r", encoding="utf-8") as f:
                backup_content = f.read()

            backup_data = json.loads(backup_content)
            obras = backup_data.get("obras", [])

            print(f"ðŸ“ Total de obras no backup: {len(obras)}")
            return {"obras": obras}

        except Exception as e:
            print(f"âŒ ERRO em handle_get_backup_completo: {str(e)}")
            return {"obras": []}

    def handle_post_dados(self, post_data):
        """Salva DADOS.json"""
        try:
            new_data = json.loads(post_data)

            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)

            if self.file_utils.save_json_file(dados_file, new_data):
                print("ðŸ’¾ DADOS.json salvo")
                return {"status": "success", "message": "Dados salvos"}
            else:
                return {"status": "error", "message": "Erro ao salvar dados"}

        except Exception as e:
            print(f"âŒ Erro ao salvar dados: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_backup(self, post_data):
        """Salva BACKUP.json"""
        try:
            new_data = json.loads(post_data)

            backup_file = self.file_utils.find_json_file(
                "backup.json", self.project_root
            )

            if self.file_utils.save_json_file(backup_file, new_data):
                print("ðŸ’¾ BACKUP.json salvo")
                return {"status": "success", "message": "Backup salvo"}
            else:
                return {"status": "error", "message": "Erro ao salvar backup"}

        except Exception as e:
            print(f"âŒ Erro ao salvar backup: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_reload_page(self, post_data):
        """ForÃ§a recarregamento da pÃ¡gina via Python"""
        try:
            data = json.loads(post_data)

            action = data.get("action", "unknown")
            obra_id = data.get("obraId")
            obra_name = data.get("obraName")

            print(
                f"ðŸ”„ [RECARREGAMENTO] AÃ§Ã£o: {action}, Obra: {obra_name} (ID: {obra_id})"
            )

            if action == "undo":
                print(
                    f"â†©ï¸ UsuÃ¡rio desfez exclusÃ£o da obra {obra_name} - mantendo na sessÃ£o"
                )
            elif action == "undo_no_data":
                print(
                    f"â†©ï¸ UsuÃ¡rio desfez exclusÃ£o (dados insuficientes) - recarregando pÃ¡gina"
                )
            elif action.startswith("timeout"):
                print(f"â° Timeout completo - obra {obra_name} removida da sessÃ£o")

            return {
                "reload_required": True,
                "action": action,
                "obra_id": obra_id,
                "obra_name": obra_name,
                "message": "PÃ¡gina serÃ¡ recarregada",
                "reload_delay": 500,
            }

            print(f"âœ… Comando de recarregamento enviado para o frontend")

        except Exception as e:
            print(f"âŒ Erro no recarregamento: {str(e)}")
            return {
                "reload_required": True,
                "error": str(e),
                "message": "Recarregamento forÃ§ado devido a erro",
            }

            # ========== ROTA UNIVERSAL DELETE ==========


    def handle_delete_universal(self, path_array):
        """Deleta qualquer item no backup.json seguindo um caminho especÃ­fico"""
        try:
            print(f"ðŸ” [DELETE UNIVERSAL] Path recebido: {path_array}")
            print(f"ðŸ” [DELETE UNIVERSAL] Tipos dos elementos: {[type(item) for item in path_array]}")
            
            # Carrega backup.json
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {})
            
            current = backup_data
            parent = None
            parent_key = None
            
            # Navega atÃ© o penÃºltimo nÃ­vel
            for i, key in enumerate(path_array[:-1]):
                print(f"ðŸ” Navegando: key='{key}' (tipo: {type(key)}), nÃ­vel={i}, tipo_atual={type(current)}")
                
                if isinstance(current, list):
                    # Buscar por ID em array (obras, projetos, salas)
                    item_found = False
                    for idx, item in enumerate(current):
                        if isinstance(item, dict) and str(item.get('id', '')) == str(key):
                            parent = current
                            parent_key = idx
                            current = item
                            item_found = True
                            print(f"âœ… Encontrado '{key}' no Ã­ndice {idx}")
                            break
                    
                    if not item_found:
                        return {
                            "success": False,
                            "error": f"Caminho invÃ¡lido: '{key}' nÃ£o encontrado",
                            "path": path_array
                        }
                        
                elif isinstance(current, dict):
                    # Acesso direto por chave de dicionÃ¡rio
                    if key not in current:
                        return {
                            "success": False,
                            "error": f"Caminho invÃ¡lido: '{key}' nÃ£o encontrado",
                            "path": path_array
                        }
                    parent = current
                    parent_key = key
                    current = current[key]
                else:
                    return {
                        "success": False,
                        "error": f"Tipo invÃ¡lido no caminho: {type(current)}",
                        "path": path_array
                    }
            
            # ðŸ”¥ CORREÃ‡ÃƒO CRÃTICA: ÃšLTIMO ELEMENTO - SEMPRE tenta como Ã­ndice primeiro
            last_item = path_array[-1]
            print(f"ðŸ” Ãšltimo item a deletar: '{last_item}' (tipo: {type(last_item)})")
            print(f"ðŸ” NÃ­vel final type: {type(current)}")
            
            if isinstance(current, list):
                print(f"ðŸ” Array final com {len(current)} itens")
                
                # ðŸ”¥ SEMPRE TENTA COMO ÃNDICE PRIMEIRO (para mÃ¡quinas)
                try:
                    # Converter para inteiro
                    item_index = int(last_item)
                    print(f"ðŸ” Interpretando '{last_item}' como Ã­ndice numÃ©rico: {item_index}")
                    
                    if 0 <= item_index < len(current):
                        print(f"âœ… Removendo pelo Ã­ndice {item_index}")
                        deleted_item = current.pop(item_index)
                        print(f"âœ… Item removido do Ã­ndice {item_index}. Array agora tem {len(current)} itens")
                    else:
                        return {
                            "success": False,
                            "error": f"Ãndice {item_index} fora do range (0-{len(current)-1})",
                            "path": path_array
                        }
                        
                except (ValueError, TypeError) as e:
                    # Se nÃ£o for nÃºmero, buscar por ID (para obras/projetos/salas)
                    print(f"ðŸ” '{last_item}' nÃ£o Ã© nÃºmero vÃ¡lido, buscando por ID...")
                    item_index = -1
                    for i, item in enumerate(current):
                        if isinstance(item, dict):
                            item_id = str(item.get('id', ''))
                            if item_id == str(last_item):
                                item_index = i
                                break
                    
                    if item_index == -1:
                        return {
                            "success": False,
                            "error": f"Item '{last_item}' nÃ£o encontrado",
                            "path": path_array
                        }
                    
                    deleted_item = current.pop(item_index)
                    print(f"âœ… Removido item com ID '{last_item}' no Ã­ndice {item_index}")
                    
            elif isinstance(current, dict):
                # Para dicionÃ¡rios, remover pela chave
                if str(last_item) not in current:
                    return {
                        "success": False,
                        "error": f"Item '{last_item}' nÃ£o encontrado no dicionÃ¡rio",
                        "path": path_array
                    }
                
                deleted_item = current.pop(str(last_item))
                print(f"âœ… Removido chave '{last_item}' do dicionÃ¡rio")
            else:
                return {
                    "success": False,
                    "error": f"Tipo invÃ¡lido: {type(current)}",
                    "path": path_array
                }
            
            # Salvar backup atualizado
            print(f"ðŸ’¾ Salvando backup atualizado...")
            if self.file_utils.save_json_file(backup_file, backup_data):
                # Se for uma obra, tambÃ©m remove da sessÃ£o atual
                if len(path_array) == 2 and path_array[0] == 'obras':
                    obra_id = path_array[1]
                    self.sessions_manager.remove_obra(obra_id)
                    print(f"ðŸ—‘ï¸ Obra {obra_id} tambÃ©m removida da sessÃ£o")
                
                return {
                    "success": True,
                    "message": "Item deletado com sucesso",
                    "path": path_array,
                    "deleted_item": str(last_item)
                }
            else:
                return {
                    "success": False,
                    "error": "Erro ao salvar backup.json",
                    "path": path_array
                }
            
        except Exception as e:
            print(f"âŒ Erro em handle_delete_universal: {e}")
            import traceback
            traceback.print_exc()
            
            return {
                "success": False,
                "error": f"Erro interno: {str(e)}",
                "path": path_array
            }

    def handle_delete_universal_from_handler(self, handler):
        """Wrapper para receber dados do handler HTTP"""
        try:
            content_length = int(handler.headers["Content-Length"])
            post_data = handler.rfile.read(content_length).decode("utf-8")
            data = json.loads(post_data)

            path = data.get("path")

            if not path or not isinstance(path, list):
                return {
                    "success": False,
                    "error": "Path invÃ¡lido. Deve ser um array (ex: ['obras', 'id_da_obra'])",
                }

            return self.handle_delete_universal(path)

        except json.JSONDecodeError:
            return {"success": False, "error": "JSON invÃ¡lido"}
        except Exception as e:
            print(f"âŒ Erro em handle_delete_universal_from_handler: {e}")
            return {"success": False, "error": f"Erro no handler: {str(e)}"}



    # ==========  FUNÃ‡Ã•ES PARA SISTEMA DE EDIÃ‡ÃƒO ==========

    def handle_get_system_data(self):
        """Retorna TODOS os dados do sistema para a interface de ediÃ§Ã£o"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(
                dados_file, 
                {
                    "constants": {}, 
                    "machines": [], 
                    "materials": {}, 
                    "empresas": [],
                    "banco_equipamentos": {},
                    "dutos": []  # ADICIONADO
                }
            )
            
            print("ðŸ“Š Retornando todos os dados do sistema")
            return dados_data
            
        except Exception as e:
            print(f"âŒ Erro ao carregar system data: {str(e)}")
            return {
                "constants": {}, 
                "machines": [], 
                "materials": {}, 
                "empresas": [],
                "banco_equipamentos": {},
                "dutos": []  # ADICIONADO
            }

    def handle_get_constants_json(self):
        """Retorna apenas as constantes formatadas"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            constants = dados_data.get("constants", {})
            return {"constants": constants}
            
        except Exception as e:
            print(f"âŒ Erro ao carregar constants: {str(e)}")
            return {"constants": {}}

    def handle_get_materials(self):
        """Retorna materiais"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            materials = dados_data.get("materials", {})
            return {"materials": materials}
            
        except Exception as e:
            print(f"âŒ Erro ao carregar materials: {str(e)}")
            return {"materials": {}}

    def handle_get_all_empresas(self):
        """Retorna todas empresas no formato correto"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            empresas = dados_data.get("empresas", [])
            return {"empresas": empresas}
            
        except Exception as e:
            print(f"âŒ Erro ao carregar empresas: {str(e)}")
            return {"empresas": []}

    def handle_get_machine_types(self):
        """Retorna lista de tipos de mÃ¡quinas"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            machine_types = [machine.get("type", "") for machine in machines if machine.get("type")]
            
            return {"machine_types": machine_types}
            
        except Exception as e:
            print(f"âŒ Erro ao carregar machine types: {str(e)}")
            return {"machine_types": []}

    def handle_get_machine_by_type(self, machine_type):
        """Retorna mÃ¡quina especÃ­fica pelo tipo"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            
            for machine in machines:
                if machine.get("type") == machine_type:
                    return {"machine": machine}
            
            return {"machine": None}
            
        except Exception as e:
            print(f"âŒ Erro ao carregar machine: {str(e)}")
            return {"machine": None}

    def handle_post_save_system_data(self, post_data):
        """Salva TODOS os dados do sistema"""
        try:
            new_data = json.loads(post_data)
            
            # Valida estrutura bÃ¡sica ATUALIZADA com dutos
            required_keys = ["constants", "machines", "materials", "empresas", "banco_equipamentos", "dutos"]
            if not all(key in new_data for key in required_keys):
                return {
                    "success": False, 
                    "error": "Estrutura de dados invÃ¡lida. Faltam campos obrigatÃ³rios."
                }
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            
            if self.file_utils.save_json_file(dados_file, new_data):
                print("ðŸ’¾ TODOS os dados do sistema salvos (incluindo dutos)")
                return {"success": True, "message": "Dados salvos com sucesso"}
            else:
                return {"success": False, "error": "Erro ao salvar dados"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar system data: {str(e)}")
            return {"success": False, "error": str(e)}


    def handle_post_save_constants(self, post_data):
        """Salva apenas as constantes"""
        try:
            new_constants = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["constants"] = new_constants.get("constants", {})
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("ðŸ’¾ Constantes salvas")
                return {"success": True, "message": "Constantes salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar constantes"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar constants: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_materials(self, post_data):
        """Salva materiais"""
        try:
            new_materials = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["materials"] = new_materials.get("materials", {})
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("ðŸ’¾ Materiais salvos")
                return {"success": True, "message": "Materiais salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar materiais"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar materials: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_empresas(self, post_data):
        """Salva empresas"""
        try:
            new_empresas = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["empresas"] = new_empresas.get("empresas", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("ðŸ’¾ Empresas salvas")
                return {"success": True, "message": "Empresas salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar empresas"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar empresas: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_save_machines(self, post_data):
        """Salva todas as mÃ¡quinas"""
        try:
            new_machines = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["machines"] = new_machines.get("machines", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("ðŸ’¾ MÃ¡quinas salvas")
                return {"success": True, "message": "MÃ¡quinas salvas"}
            else:
                return {"success": False, "error": "Erro ao salvar mÃ¡quinas"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar machines: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_add_machine(self, post_data):
        """Adiciona nova mÃ¡quina"""
        try:
            new_machine = json.loads(post_data)
            
            if not new_machine.get("type"):
                return {"success": False, "error": "Tipo de mÃ¡quina nÃ£o especificado"}
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            machines.append(new_machine)
            dados_data["machines"] = machines
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print(f"ðŸ’¾ Nova mÃ¡quina '{new_machine.get('type')}' adicionada")
                return {"success": True, "message": "MÃ¡quina adicionada", "machine": new_machine}
            else:
                return {"success": False, "error": "Erro ao adicionar mÃ¡quina"}
                
        except Exception as e:
            print(f"âŒ Erro ao adicionar machine: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_update_machine(self, post_data):
        """Atualiza mÃ¡quina existente"""
        try:
            update_data = json.loads(post_data)
            
            machine_type = update_data.get("type")
            if not machine_type:
                return {"success": False, "error": "Tipo de mÃ¡quina nÃ£o especificado"}
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get("machines", [])
            updated = False
            
            for i, machine in enumerate(machines):
                if machine.get("type") == machine_type:
                    machines[i] = update_data
                    updated = True
                    break
            
            if not updated:
                return {"success": False, "error": f"MÃ¡quina '{machine_type}' nÃ£o encontrada"}
            
            dados_data["machines"] = machines
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print(f"ðŸ’¾ MÃ¡quina '{machine_type}' atualizada")
                return {"success": True, "message": "MÃ¡quina atualizada", "machine": update_data}
            else:
                return {"success": False, "error": "Erro ao atualizar mÃ¡quina"}
                
        except Exception as e:
            print(f"âŒ Erro ao atualizar machine: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_post_empresas_auto(self, post_data):
        """Cria empresa automaticamente"""
        try:
            # Esta funÃ§Ã£o pode delegar para o EmpresaHandler
            return {
                "success": True, 
                "message": "Empresa auto criada"
            }
        except Exception as e:
            print(f"âŒ Erro em handle_post_empresas_auto: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_health_check(self):
        """Health check rÃ¡pido"""
        return {"status": "online", "timestamp": time.time()}

    def handle_get_server_uptime(self):
        """Retorna uptime do servidor"""
        try:
            import time
            from servidor_modules.core.sessions_core import sessions_manager
            
            # Calcular tempo desde o inÃ­cio
            start_time = sessions_manager.start_time
            uptime_seconds = time.time() - start_time
            
            # Converter para formato legÃ­vel
            hours = int(uptime_seconds // 3600)
            minutes = int((uptime_seconds % 3600) // 60)
            seconds = int(uptime_seconds % 60)
            
            return {
                "uptime_seconds": uptime_seconds,
                "uptime_human": f"{hours}h {minutes}m {seconds}s",
                "start_time": start_time
            }
        except Exception as e:
            print(f"âŒ Erro ao obter uptime: {str(e)}")
            return {"error": str(e)}

    def handle_get_projetos(self):
        """ObtÃ©m projetos (legacy)"""
        try:
            # ImplementaÃ§Ã£o simples para compatibilidade
            return []
        except Exception as e:
            print(f"âŒ Erro ao obter projetos: {str(e)}")
            return []
        
    
    def handle_delete_empresa_by_index(self, index):
        """Deleta uma empresa pelo Ã­ndice"""
        try:
            index_int = int(index)
            print(f"ðŸ—‘ï¸  [DELETE EMPRESA] Excluindo empresa no Ã­ndice: {index_int}")

            # Carrega dados.json
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            empresas = dados_data.get("empresas", [])
            if not isinstance(empresas, list):
                return {"success": False, "error": "Estrutura 'empresas' invÃ¡lida"}

            # Verifica Ã­ndice
            if 0 <= index_int < len(empresas):
                empresa_removida = empresas.pop(index_int)
                sigla_removida = list(empresa_removida.keys())[0] if empresa_removida else "?"
                print(f"âœ… Empresa '{sigla_removida}' (Ã­ndice {index_int}) removida.")

                # Salva
                dados_data["empresas"] = empresas
                if self.file_utils.save_json_file(dados_file, dados_data):
                    return {"success": True, "message": f"Empresa {sigla_removida} excluÃ­da"}
                else:
                    return {"success": False, "error": "Falha ao salvar arquivo"}
            else:
                return {"success": False, "error": f"Ãndice {index_int} invÃ¡lido"}

        except ValueError:
            return {"success": False, "error": f"Ãndice invÃ¡lido: '{index}'"}
        except Exception as e:
            print(f"âŒ Erro em handle_delete_empresa_by_index: {e}")
            return {"success": False, "error": str(e)}
        
        
    def handle_delete_empresa(self, index):
        """Deleta uma empresa pelo Ã­ndice"""
        try:
            index_int = int(index)
            print(f"ðŸ—‘ï¸  [DELETE EMPRESA] Excluindo empresa no Ã­ndice: {index_int}")

            # Carrega dados.json
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})

            empresas = dados_data.get("empresas", [])
            if not isinstance(empresas, list):
                return {"success": False, "error": "Estrutura 'empresas' invÃ¡lida"}

            # Verifica Ã­ndice
            if 0 <= index_int < len(empresas):
                empresa_removida = empresas.pop(index_int)
                sigla_removida = list(empresa_removida.keys())[0] if empresa_removida else "?"
                print(f"âœ… Empresa '{sigla_removida}' (Ã­ndice {index_int}) removida.")

                # Salva
                dados_data["empresas"] = empresas
                if self.file_utils.save_json_file(dados_file, dados_data):
                    return {"success": True, "message": f"Empresa {sigla_removida} excluÃ­da"}
                else:
                    return {"success": False, "error": "Falha ao salvar arquivo"}
            else:
                return {"success": False, "error": f"Ãndice {index_int} invÃ¡lido"}

        except ValueError:
            return {"success": False, "error": f"Ãndice invÃ¡lido: '{index}'"}
        except Exception as e:
            print(f"âŒ Erro em handle_delete_empresa: {e}")
            return {"success": False, "error": str(e)}
        
        
        
        # Adicionar na classe RoutesCore:


        
        
    def handle_get_equipamentos(self):
        """Retorna todos os equipamentos do banco_equipamentos"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            equipamentos = dados_data.get("banco_equipamentos", {})
            return {
                "success": True,
                "equipamentos": equipamentos,
                "count": len(equipamentos)
            }
            
        except Exception as e:
            print(f"âŒ Erro ao carregar equipamentos: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "equipamentos": {},
                "count": 0
            }
            
            
    def handle_get_dutos(self):
        """Retorna todos os dutos"""
        try:
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dutos = dados_data.get("dutos", [])
            return {
                "success": True,
                "dutos": dutos,
                "count": len(dutos)
            }
            
        except Exception as e:
            print(f"âŒ Erro ao carregar dutos: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "dutos": [],
                "count": 0
            }
            
    def handle_post_save_dutos(self, post_data):
        """Salva apenas os dutos"""
        try:
            new_dutos = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file("dados.json", self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            dados_data["dutos"] = new_dutos.get("dutos", [])
            
            if self.file_utils.save_json_file(dados_file, dados_data):
                print("ðŸ’¾ Dutos salvos")
                return {"success": True, "message": "Dutos salvos"}
            else:
                return {"success": False, "error": "Erro ao salvar dutos"}
                
        except Exception as e:
            print(f"âŒ Erro ao salvar dutos: {str(e)}")
            return {"success": False, "error": str(e)}
/* ==== FIM: core/routes_core.py ==== */
