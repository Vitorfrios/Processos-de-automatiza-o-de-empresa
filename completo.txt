
/* ==== IN√çCIO: features/calculations/calculations-core.js ==== */
/**
 * features/calculations/calculations-core.js
 * N√∫cleo de c√°lculos unificado - FUS√ÉO OTIMIZADA: calculos-manager.js + helpers.js
 * Sistema centralizado para c√°lculos de climatiza√ß√£o
 */


import { 
    safeNumber as coreSafeNumber, 
    updateElementText as coreUpdateElementText,
    waitForElement as coreWaitForElement,
    debounce as coreDebounce
} from '../../data/utils/core-utils.js';

import {
    collectClimatizationInputs as dataCollectClimatizationInputs,
    findClimatizationSection as dataFindClimatizationSection
} from '../../data/utils/data-utils.js';

// ‚úÖ RE-EXPORTAR fun√ß√µes de data-utils para compatibilidade
export const collectClimatizationInputs = dataCollectClimatizationInputs;
export const findClimatizationSection = dataFindClimatizationSection;

// ‚úÖ RE-EXPORTAR fun√ß√µes de core-utils para compatibilidade  
export const safeNumber = coreSafeNumber;
export const updateElementText = coreUpdateElementText;


// =============================================================================
// SISTEMA DE DEBOUNCE E PERFORMANCE
// =============================================================================

const calculationTimeouts = new Map();

/**
 * Sistema de debounce para otimizar c√°lculos
 * @param {string} roomId - ID da sala
 * @param {Function} calculationFunction - Fun√ß√£o a executar
 * @param {number} delay - Delay em ms (padr√£o: 300ms)
 */
function debouncedCalculation(roomId, calculationFunction, delay = 300) {
    if (calculationTimeouts.has(roomId)) {
        clearTimeout(calculationTimeouts.get(roomId));
    }
    
    const timeoutId = setTimeout(() => {
        calculationFunction(roomId);
        calculationTimeouts.delete(roomId);
    }, delay);
    
    calculationTimeouts.set(roomId, timeoutId);
}

/**
 * Limpa todos os timeouts de c√°lculo
 */
function clearAllCalculationTimeouts() {
    calculationTimeouts.forEach((timeoutId, roomId) => {
        clearTimeout(timeoutId);
        calculationTimeouts.delete(roomId);
    });
}

// =============================================================================
// SISTEMA DE CONSTANTES
// =============================================================================

/**
 * Aguarda carregamento das constantes do sistema
 */
async function waitForSystemConstants() {
    let attempts = 0;
    const maxAttempts = 100;
    
    while ((!window.systemConstants || !window.systemConstants.VARIAVEL_PD) && attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 200));
        attempts++;
    }
    
    if (attempts >= maxAttempts) {
        throw new Error("Constantes do sistema n√£o carregadas");
    }
    
    return true;
}

/**
 * Valida integridade das constantes necess√°rias
 */
function validateSystemConstants() {
    if (!window.systemConstants) {
        console.error("systemConstants n√£o dispon√≠vel");
        return false;
    }
    
    const required = [
        'VARIAVEL_PD', 'VARIAVEL_PS', 'AUX_U_Value_Piso', 'AUX_Fator_Iluminacao',
        'AUX_Fs_Iluminacao', 'AUX_Fator_Conver_Painel', 'AUX_Fs_Paineis',
        'AUX_OCp_Csp', 'AUX_OCp_Clp', 'Densi_ar', 'AUX_c_ArExterno',
        'AUX_deltaT_ArExterno', 'AUX_f_ArExterno', 'AUX_deltaUa_ArExterno',
        'deltaT_piso', 'deltaT_teto', 'deltaT_parede_Oes', 'deltaT_parede_Les',
        'deltaT_parede_Nor', 'deltaT_parede_Sul', 'deltaT_divi_N_clim1',
        'deltaT_divi_N_clim2', 'deltaT_divi_clim1', 'deltaT_divi_clim2'
    ];
    
    const missing = required.filter(constant => 
        window.systemConstants[constant] === undefined || window.systemConstants[constant] === null
    );
    
    if (missing.length > 0) {
        console.error("Constantes faltando:", missing);
        return false;
    }
    
    return true;
}

// =============================================================================
// COLETA E PROCESSAMENTO DE DADOS
// =============================================================================






// =============================================================================
// SISTEMA DE C√ÅLCULOS COORDENADOS
// =============================================================================

/**
 * Executa c√°lculo coordenado de vaz√£o e ganhos t√©rmicos com debounce
 */
async function calculateVazaoArAndThermalGainsDebounced(roomId) {
    debouncedCalculation(roomId, async (id) => {
        try {
            // Importa√ß√£o din√¢mica para evitar depend√™ncia circular
            const { calculateVazaoAr } = await import('./air-flow.js');
            const { calculateThermalGains } = await import('./thermal-gains.js');
            
            const flowRate = await calculateVazaoAr(id, false);
            await calculateThermalGains(id, flowRate);
            
        } catch (error) {
            console.error(`Erro em c√°lculo para ${id}:`, error);
        }
    }, 300);
}

/**
 * Executa c√°lculo imediato (sem debounce)
 */
async function calculateVazaoArAndThermalGainsImmediate(roomId) {
    try {
        const { calculateVazaoAr } = await import('./air-flow.js');
        const { calculateThermalGains } = await import('./thermal-gains.js');
        
        const flowRate = await calculateVazaoAr(roomId, false);
        await calculateThermalGains(roomId, flowRate);
        
    } catch (error) {
        console.error(`Erro em c√°lculo imediato para ${roomId}:`, error);
    }
}

// =============================================================================
// FUN√á√ïES DE COMPATIBILIDADE
// =============================================================================




// =============================================================================
// UTILIT√ÅRIOS DE VALIDA√á√ÉO
// =============================================================================

/**
 * Valida se os dados coletados s√£o suficientes para c√°lculos
 */
function validateCalculationData(inputData) {
    const requiredFields = ['area', 'altura', 'qtdPessoas', 'qtdEquipamentos'];
    const missingFields = requiredFields.filter(field => 
        !inputData[field] || inputData[field] === ''
    );
    
    if (missingFields.length > 0) {
        console.warn(`Campos obrigat√≥rios faltando: ${missingFields.join(', ')}`);
        return false;
    }
    
    return true;
}

/**
 * Prepara dados para c√°lculo (convers√µes e formata√ß√µes)
 */
function prepareCalculationData(rawData) {
    const prepared = { ...rawData };
    
    // Converter n√∫meros
    const numericFields = ['area', 'altura', 'qtdPessoas', 'qtdEquipamentos', 'potenciaIluminacao'];
    numericFields.forEach(field => {
        if (prepared[field]) {
            prepared[field] = coreSafeNumber(prepared[field]);
        }
    });
    
    // Aplicar fatores de seguran√ßa
    if (prepared.fatorSeguranca) {
        const factor = coreSafeNumber(prepared.fatorSeguranca);
        if (factor > 1) {
            prepared.area = prepared.area * factor;
        }
    }
    
    return prepared;
}

// =============================================================================
// EXPORTA√á√ïES
// =============================================================================

export {
    // Sistema de Performance
    debouncedCalculation,
    clearAllCalculationTimeouts,
    
    // Sistema de Constantes
    waitForSystemConstants,
    validateSystemConstants,

    
    // Sistema de C√°lculos
    calculateVazaoArAndThermalGainsDebounced,
    calculateVazaoArAndThermalGainsImmediate,
    
    // Valida√ß√£o e Prepara√ß√£o
    validateCalculationData,
    prepareCalculationData,
    


};

// =============================================================================
// INICIALIZA√á√ÉO E CONFIGURA√á√ÉO
// =============================================================================

// Configura√ß√£o padr√£o do sistema de c√°lculos
const CALCULATION_CONFIG = {
    debounceDelay: 300,
    maxRetryAttempts: 3,
    validationStrict: false,
    enableLogging: window.location.hostname === 'localhost'
};


// Disponibiliza√ß√£o global para compatibilidade
if (typeof window !== 'undefined') {
    window.calculationCore = {
        debouncedCalculation,
        waitForSystemConstants,
        collectClimatizationInputs,

        calculateVazaoArAndThermalGainsDebounced
    };
}

// Limpeza de timeouts ao descarregar a p√°gina
if (typeof window !== 'undefined') {
    window.addEventListener('beforeunload', clearAllCalculationTimeouts);
}
/* ==== FIM: features/calculations/calculations-core.js ==== */

/* ==== IN√çCIO: data/modules/machines/capacity-calculator.js ==== */
// capacityCalculator.js

import { updateElementText } from '../../utils/core-utils.js';


/**
 * Encontra o ID da sala a partir de um elemento dentro dela
 * @param {HTMLElement} element - Elemento dentro da sala
 * @returns {string|null} ID da sala ou null se n√£o encontrado
 */
function findRoomId(element) {
    if (!element) return null;
    
    // Buscar o elemento room-block mais pr√≥ximo
    const roomBlock = element.closest('.room-block');
    if (roomBlock) {
        return roomBlock.dataset.roomId || null;
    }
    
    // Tentar extrair do ID do elemento de conte√∫do
    const roomContent = element.closest('[id^="room-content-"]');
    if (roomContent) {
        const match = roomContent.id.match(/room-content-(.+)/);
        if (match) return match[1];
    }
    
    // Tentar extrair de elementos com data-room-id
    const roomElement = element.closest('[data-room-id]');
    if (roomElement) {
        return roomElement.dataset.roomId;
    }
    
    console.warn('‚ùå N√£o foi poss√≠vel encontrar o ID da sala para o elemento:', element);
    return null;
}

// Configura√ß√µes para inicializa√ß√£o do sistema de capacidade
const capacityConfig = {
  maxInitAttempts: 3,
  initDelay: 500
}

// Estado global para controle de inicializa√ß√£o por sala
const capacityState = new Map()

/**
 * Constr√≥i a tabela de c√°lculo de capacidade de refrigera√ß√£o para uma sala
 * @param {string} roomId - ID da sala
 * @returns {string} HTML da tabela de capacidade
 */
function buildCapacityCalculationTable(roomId) {
  scheduleCapacityInit(roomId)
  const backupValue = getBackupFromClimaInputs(roomId)

  return `
    <div class="capacity-calculation-table">
      <h5 class="table-title">C√°lculo de Capacidade de Refrigera√ß√£o</h5>
      <div class="table-container">
        <table class="thermal-capacity-table">
          <thead>
            <tr>
              <th>Carga Estimada (TR)</th>
              <th>Fator de Seg.</th>
              <th>Cap. Unit. (TR)</th>
              <th>Solu√ß√£o</th>
              <th>Com back-up</th>
              <th>TOTAL (TR)</th>
              <th>FOLGA (%)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td id="carga-estimada-${roomId}">0</td> 
              <td>
                <input type="number" id="fator-seguranca-${roomId}" step="1" 
                      class="capacity-input" 
                      onchange="calculateCapacitySolution('${roomId}')"
                      oninput="calculateCapacitySolution('${roomId}')">
              </td>
              <td>
                <select id="capacidade-unitaria-${roomId}" class="capacity-select" 
                        onchange="calculateCapacitySolution('${roomId}')">
                  ${[1, 2, 3, 4, 5, 7.5, 10, 12.5, 15, 20, 25, 30]
                    .map((tr) => `<option value="${tr}">${tr} TR</option>`)
                    .join("")}
                </select>
              </td>
              <td id="solucao-${roomId}">0</td>
              <td class="backup-cell">
                <div class="backup-selection">
                  <select class="backup-select" onchange="updateBackupConfiguration(this)">
                    ${["n", "n+1", "n+2"]
                      .map((opt) => `<option value="${opt}" ${backupValue === opt ? "selected" : ""}>${opt}</option>`)
                      .join("")}
                  </select>
                </div>
                <div class="backup-solution">
                  <span id="solucao-backup-${roomId}">0</span>
                </div>
              </td>
              <td id="total-capacidade-${roomId}">0</td>
              <td id="folga-${roomId}">0%</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  `
}

/**
 * Inicializa a tabela de capacidade est√°tica (para casos espec√≠ficos)
 * @returns {void}
 */
function initializeStaticCapacityTable() {
  const staticTable = document.querySelector(".capacity-calculation-table")
  if (staticTable) {
    scheduleCapacityInit("Projeto1-Sala1")
  }
}

/**
 * Agenda a inicializa√ß√£o do sistema de capacidade para uma sala
 * @param {string} roomId - ID da sala
 * @returns {void}
 */
function scheduleCapacityInit(roomId) {
  if (capacityState.has(roomId)) return

  capacityState.set(roomId, { initialized: false, attempts: 0 })
  setTimeout(() => initializeCapacitySystem(roomId), capacityConfig.initDelay)
}

/**
 * Inicializa o sistema de capacidade com tentativas controladas
 * @param {string} roomId - ID da sala
 * @returns {void}
 */
function initializeCapacitySystem(roomId) {
  const state = capacityState.get(roomId)
  if (!state || state.initialized) return

  state.attempts++

  const systemConstantsReady = window.systemConstants?.FATOR_SEGURANCA_CAPACIDADE !== undefined

  if (systemConstantsReady || state.attempts >= capacityConfig.maxInitAttempts) {
    const fatorSeguranca = systemConstantsReady
      ? window.systemConstants.FATOR_SEGURANCA_CAPACIDADE
      : 10 // Valor padr√£o sem fallback complexo

    applyFatorSeguranca(roomId, fatorSeguranca)
    state.initialized = true
  }
}

/**
 * Aplica o fator de seguran√ßa ao input correspondente
 * @param {string} roomId - ID da sala
 * @param {number} fatorSeguranca - Valor do fator de seguran√ßa
 * @returns {void}
 */
function applyFatorSeguranca(roomId, fatorSeguranca) {
  const inputFator = document.getElementById(`fator-seguranca-${roomId}`)
  if (!inputFator) return

  inputFator.value = fatorSeguranca
  calculateCapacitySolution(roomId)
}

/**
 * Obt√©m a carga t√©rmica em TR (Tons de Refrigera√ß√£o) para uma sala
 * @param {string} roomId - ID da sala
 * @returns {number} Carga t√©rmica em TR
 */
function getThermalLoadTR(roomId) {
  try {

    const totalTRExatoElement = document.getElementById(`total-tr-exato-${roomId}`)
    if (totalTRExatoElement?.textContent) {
      return Number.parseFloat(totalTRExatoElement.textContent) || 0
    }

    const totalTRElement = document.getElementById(`total-tr-aprox-${roomId}`)
    if (totalTRElement?.textContent) {
      return Number.parseFloat(totalTRElement.textContent) || 0
    }

    const totalGanhosWElement = document.getElementById(`total-ganhos-w-${roomId}`)
    if (totalGanhosWElement?.textContent) {
      const totalW = Number.parseFloat(totalGanhosWElement.textContent) || 0
      return totalW / 3517
    }

    return 0
  } catch (error) {
    console.error(`Erro ao obter carga t√©rmica para sala ${roomId}:`, error)
    return 0
  }
}

/**
 * Calcula a solu√ß√£o de capacidade de refrigera√ß√£o baseada nos par√¢metros
 * @param {string} roomId - ID da sala
 * @returns {void}
 */
function calculateCapacitySolution(roomId) {
  try {
    const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`)
    const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`)
    const cargaEstimadaInput = document.querySelector(`carga-estimada-${roomId} input`)

    if (!fatorSegurancaInput || !capacidadeUnitariaSelect) return

    // Usa o valor do input se existir, sen√£o usa o c√°lculo autom√°tico
    const cargaEstimada = cargaEstimadaInput ? 
      (Number.parseInt(cargaEstimadaInput.value) || 0) : 
      getThermalLoadTR(roomId)

    const fatorSeguranca = Number.parseFloat(fatorSegurancaInput.value) / 100
    const capacidadeUnitaria = Number.parseFloat(capacidadeUnitariaSelect.value)
    const backupType = getBackupFromClimatization(roomId)

    const capacidadeNecessaria = cargaEstimada * (1 + fatorSeguranca)
    const unidadesOperacionais = Math.ceil(capacidadeNecessaria / capacidadeUnitaria)
    const unidadesTotais = applyBackupConfiguration(unidadesOperacionais, backupType)

    const total = unidadesOperacionais * capacidadeUnitaria
    const folga = cargaEstimada > 0 ? (total / cargaEstimada - 1) * 100 : 0

    updateCapacityDisplay(roomId, cargaEstimada, unidadesOperacionais, unidadesTotais, total, folga, backupType)
    
    // ‚úÖ CORRE√á√ÉO: Salvar usando roomId em vez de projectName/roomName
    saveCapacityData(roomId)
  } catch (error) {
    console.error(`Erro ao calcular capacidade para sala ${roomId}:`, error)
  }
}

/**
 * Obt√©m os dados atuais de capacidade de uma sala
 * @param {string} roomId - ID da sala
 * @returns {Object|null} Dados de capacidade ou null se n√£o encontrado
 */
function getCapacityData(roomId) {
  const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`)
  const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`)
  const backupSelect = document.querySelector(`#room-content-${roomId} .backup-select`)

  if (!fatorSegurancaInput || !capacidadeUnitariaSelect || !backupSelect) return null

  return {
    fatorSeguranca: Number.parseFloat(fatorSegurancaInput.value) || 10,
    capacidadeUnitaria: Number.parseFloat(capacidadeUnitariaSelect.value) || 1,
    backup: backupSelect.value || "n",
    cargaEstimada: getThermalLoadTR(roomId),
    solucao: document.getElementById(`solucao-${roomId}`)?.textContent || "0",
    solucaoBackup: document.getElementById(`solucao-backup-${roomId}`)?.textContent || "0",
    totalCapacidade: document.getElementById(`total-capacidade-${roomId}`)?.textContent || "0",
    folga: document.getElementById(`folga-${roomId}`)?.textContent || "0%"
  }
}

/**
 * ‚úÖ CORRE√á√ÉO COMPLETA: Salva os dados de capacidade no servidor usando roomId
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function saveCapacityData(roomId) {
  try {
    const capacityData = getCapacityData(roomId)
    
    if (!capacityData) {
      console.warn(`[CAPACITY] Nenhum dado de capacidade para sala ${roomId}`)
      return
    }

    console.log(`[CAPACITY] Salvando dados para sala: ${roomId}`)

    // ‚úÖ CORRE√á√ÉO: Verificar primeiro se a sala existe localmente (rec√©m-criada)
    const roomElement = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomElement) {
      console.log(`[CAPACITY] Sala ${roomId} n√£o encontrada localmente - ignorando save`)
      return;
    }

    // Buscar todas as obras
    fetch(`/obras`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }
        return response.json()
      })
      .then(obras => {
        console.log(`[CAPACITY] Obras carregadas:`, obras.map(o => ({ id: o.id, nome: o.nome })))
        
        let obraUpdated = false
        let obraParaAtualizar = null
        
        // Buscar pela sala usando roomId
        for (const obra of obras) {
          for (const projeto of obra.projetos || []) {
            for (const sala of projeto.salas || []) {
              if (sala.id === roomId) {
                // Encontrou a sala pelo ID √∫nico
                if (!sala.capacidade) {
                  sala.capacidade = {}
                }
                
                sala.capacidade = capacityData
                obraUpdated = true
                obraParaAtualizar = obra
                console.log(`[CAPACITY] Dados atualizados na obra ${obra.nome}, projeto ${projeto.nome}, sala ${sala.nome}`)
                break
              }
            }
            if (obraUpdated) break
          }
          if (obraUpdated) break
        }

        if (!obraUpdated) {
          console.log(`[CAPACITY] Sala ${roomId} ainda n√£o salva no servidor - dados mantidos localmente`)
          return
        }

        // Atualizar apenas a obra espec√≠fica
        return fetch(`/obras/${obraParaAtualizar.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(obraParaAtualizar)
        })
      })
      .then(response => {
        if (response && response.ok) {
          console.log(`[CAPACITY] Dados de capacidade salvos para sala ${roomId}`)
        } else if (response) {
          console.log(`[CAPACITY] Erro HTTP ${response.status} ao salvar`)
        }
      })
      .catch(error => {
        console.log(`[CAPACITY] Erro ao buscar obras: ${error.message}`)
      })
      
  } catch (error) {
    console.log(`[CAPACITY] Erro inesperado: ${error.message}`)
  }
}

/**
 * ‚úÖ CORRE√á√ÉO COMPLETA: Carrega os dados de capacidade do servidor para uma sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {boolean} True se os dados foram carregados com sucesso
 */
function loadCapacityData(roomId) {
  try {
    console.log(`[CAPACITY] Tentando carregar dados para sala ${roomId}`)
    
    // Buscar obras
    fetch(`/obras`)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }
        return response.json()
      })
      .then(obras => {
        console.log(`[CAPACITY] Obras carregadas:`, obras.map(o => o.nome))
        
        // ‚úÖ CORRE√á√ÉO: Buscar pela sala usando roomId
        for (const obra of obras) {
          for (const projeto of obra.projetos || []) {
            for (const sala of projeto.salas || []) {
              if (sala.id === roomId && sala.capacidade) {
                console.log(`[CAPACITY] Dados encontrados na obra ${obra.nome}, projeto ${projeto.nome}`)
                applyCapacityData(roomId, sala.capacidade)
                return true
              }
            }
          }
        }

        console.log(`[CAPACITY] Nenhum dado de capacidade encontrado para sala ${roomId}`)
        return false
      })
      .catch(error => {
        console.error('[CAPACITY] Erro ao carregar obras:', error)
        return false
      })
      
  } catch (error) {
    console.error('[CAPACITY] Erro geral:', error)
    return false
  }
}

/**
 * Aplica os dados de capacidade carregados aos elementos da interface
 * @param {string} roomId - ID da sala
 * @param {Object} capacityData - Dados de capacidade a serem aplicados
 * @returns {void}
 */
function applyCapacityData(roomId, capacityData) {
  const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`)
  const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`)
  const backupSelect = document.querySelector(`#room-content-${roomId} .backup-select`)

  if (fatorSegurancaInput && capacityData.fatorSeguranca) {
    fatorSegurancaInput.value = capacityData.fatorSeguranca
  }

  if (capacidadeUnitariaSelect && capacityData.capacidadeUnitaria) {
    capacidadeUnitariaSelect.value = capacityData.capacidadeUnitaria
  }

  if (backupSelect && capacityData.backup) {
    backupSelect.value = capacityData.backup
  }

  // Recalcular ap√≥s carregar os dados
  setTimeout(() => {
    calculateCapacitySolution(roomId)
  }, 100)
}

/**
 * Aplica a configura√ß√£o de backup ao n√∫mero de unidades
 * @param {number} unidadesOperacionais - N√∫mero de unidades operacionais
 * @param {string} backupType - Tipo de backup ("n", "n+1", "n+2")
 * @returns {number} N√∫mero total de unidades considerando backup
 */
function applyBackupConfiguration(unidadesOperacionais, backupType) {
  switch (backupType) {
    case "n+1":
      return unidadesOperacionais + 1
    case "n+2":
      return unidadesOperacionais + 2
    default:
      return unidadesOperacionais
  }
}

/**
 * Obt√©m o tipo de backup configurado para climatiza√ß√£o da sala
 * @param {string} roomId - ID da sala
 * @returns {string} Tipo de backup ("n", "n+1", "n+2")
 */
function getBackupFromClimatization(roomId) {
  const capacityTable = document.querySelector(`#room-content-${roomId} .capacity-calculation-table`)
  if (capacityTable) {
    const backupSelect = capacityTable.querySelector(".backup-select")
    if (backupSelect) return backupSelect.value
  }

  return getBackupFromClimaInputs(roomId)
}

/**
 * Obt√©m o backup dos inputs de clima da sala
 * @param {string} roomId - ID da sala
 * @returns {string} Tipo de backup ("n", "n+1", "n+2")
 */
function getBackupFromClimaInputs(roomId) {
  const roomContent = document.getElementById(`room-content-${roomId}`)
  if (roomContent) {
    const backupInput = roomContent.querySelector(`.clima-input[data-field="backup"]`)
    if (backupInput?.value) return backupInput.value
  }
  return "n"
}

/**
 * Atualiza a exibi√ß√£o dos resultados de capacidade na tabela
 * @param {string} roomId - ID da sala
 * @param {number} cargaEstimada - Carga t√©rmica estimada em TR
 * @param {number} solucao - N√∫mero de unidades da solu√ß√£o
 * @param {number} solucaoComBackup - N√∫mero de unidades com backup
 * @param {number} total - Capacidade total em TR
 * @param {number} folga - Percentual de folga
 * @param {string} backupType - Tipo de backup
 * @returns {void}
 */
function updateCapacityDisplay(roomId, cargaEstimada, solucao, solucaoComBackup, total, folga, backupType) {
  
  // Atualizar o campo de carga estimada com input edit√°vel (valor inteiro)
  updateCargaEstimadaInput(roomId, Math.round(cargaEstimada))
  updateElementText(`solucao-${roomId}`, solucao)
  updateElementText(`solucao-backup-${roomId}`, solucaoComBackup)
  updateElementText(`total-capacidade-${roomId}`, total.toFixed(1))
  updateElementText(`folga-${roomId}`, folga.toFixed(1) + "%")

  const backupSelect = document.querySelector(`#room-content-${roomId} .backup-select`)
  if (backupSelect) {
    backupSelect.value = backupType
    backupSelect.disabled = false
  }
}

/**
 * Atualiza ou cria o input para carga estimada (apenas inteiros)
 * @param {string} roomId - ID da sala
 * @param {number} value - Valor a ser definido (inteiro)
 * @returns {void}
 */
function updateCargaEstimadaInput(roomId, value) {
  const cargaEstimadaElement = document.getElementById(`carga-estimada-${roomId}`)
  
  if (!cargaEstimadaElement) return

  // Verificar se j√° existe um input
  let input = cargaEstimadaElement.querySelector('input')
  
  if (!input) {
    // Criar input se n√£o existir
    input = document.createElement('input')
    input.type = 'number'
    input.className = 'capacity-input'
    input.min = '0'
    input.step = '1' // For√ßa n√∫meros inteiros
    input.value = value
    
    // Adicionar evento apenas para salvar, n√£o para recalcular
    input.addEventListener('change', () => {
      // ‚úÖ CORRE√á√ÉO: Salvar usando roomId
      saveCapacityData(roomId)
    })
    
    // Limpar conte√∫do anterior e adicionar o input
    cargaEstimadaElement.innerHTML = ''
    cargaEstimadaElement.appendChild(input)
  } else {
    // Atualiza com o valor calculado quando a fun√ß√£o √© chamada
    input.value = Math.round(value)
  }
}

/**
 * Atualiza a configura√ß√£o de backup quando alterada pelo usu√°rio
 * @param {HTMLSelectElement} selectElement - Elemento select do backup
 * @returns {void}
 */
function updateBackupConfiguration(selectElement) {
  const roomId = findRoomId(selectElement.closest(".capacity-calculation-table"))
  if (roomId) {
    const newBackupValue = selectElement.value
    syncBackupWithClimaInputs(roomId, newBackupValue)
    calculateCapacitySolution(roomId)
    
    // ‚úÖ CORRE√á√ÉO: Salvar usando roomId
    saveCapacityData(roomId)
  }
}

/**
 * Manipula mudan√ßas no backup provenientes dos inputs de clima
 * @param {string} roomId - ID da sala
 * @param {string} newBackupValue - Novo valor de backup
 * @returns {void}
 */
function handleClimaInputBackupChange(roomId, newBackupValue) {
  const capacityTable = document.querySelector(`#room-content-${roomId} .capacity-calculation-table`)

  if (capacityTable) {
    const backupSelect = capacityTable.querySelector(".backup-select")
    if (backupSelect && backupSelect.value !== newBackupValue) {
      backupSelect.value = newBackupValue
      calculateCapacitySolution(roomId)
      
      // ‚úÖ CORRE√á√ÉO: Salvar usando roomId
      saveCapacityData(roomId)
    }
  }
}

/**
 * Sincroniza o backup com os inputs de clima da sala
 * @param {string} roomId - ID da sala
 * @param {string} backupValue - Valor de backup a ser sincronizado
 * @returns {void}
 */
function syncBackupWithClimaInputs(roomId, backupValue) {
    const roomContent = document.getElementById(`room-content-${roomId}`)
    if (roomContent) {
        const backupInputs = roomContent.querySelectorAll(`.clima-input[data-field="backup"]`)

        backupInputs.forEach((input) => {
            if (input.value !== backupValue) {
                // üîÑ MUDAN√áA CR√çTICA: Remove temporariamente o onchange para evitar loop
                const originalOnChange = input.onchange;
                input.onchange = null;
                
                input.value = backupValue;
                
                // Restaura o onchange ap√≥s um breve delay
                setTimeout(() => {
                    input.onchange = originalOnChange;
                }, 100);
            }
        })
    }
}

/**
 * Sincroniza o backup da tabela de capacidade com os valores atuais
 * @param {string} roomId - ID da sala
 * @returns {void}
 */
function syncCapacityTableBackup(roomId) {
  setTimeout(() => {
    const backupFromInputs = getBackupFromClimaInputs(roomId)
    const capacityTable = document.querySelector(`#room-content-${roomId} .capacity-calculation-table`)

    if (capacityTable) {
      const backupSelect = capacityTable.querySelector(".backup-select")
      if (backupSelect && backupSelect.value !== backupFromInputs) {
        backupSelect.value = backupFromInputs
        calculateCapacitySolution(roomId)
      }
    }
  }, 500)
}


/**
 * üîÑ Fun√ß√£o global para ser chamada diretamente do HTML - EVITA LOOP
 * @param {string} roomId - ID da sala
 * @param {string} newValue - Novo valor do backup
 * @returns {void}
 */
function handleClimaBackupChange(roomId, newValue) {
    console.log(`üîÑ Backup alterado no form: ${newValue} (sala: ${roomId})`);
    
    // Atualiza o backup-select SEM disparar eventos de volta
    const capacityTable = document.querySelector(`#room-content-${roomId} .capacity-calculation-table`);
    if (capacityTable) {
        const backupSelect = capacityTable.querySelector(".backup-select");
        if (backupSelect && backupSelect.value !== newValue) {
            // üîÑ MUDAN√áA CR√çTICA: Atualiza silenciosamente sem disparar onchange
            backupSelect.value = newValue;
            
            // Recalcular capacidade
            calculateCapacitySolution(roomId);
            
            // Salvar dados
            saveCapacityData(roomId);
        }
    }
    
    // Mant√©m o c√°lculo t√©rmico original
    calculateVazaoArAndThermalGains(roomId);
}

/**
 * üîÑ WRAPPER: Para ser chamada diretamente do onchange do HTML
 * @param {HTMLSelectElement} selectElement - Elemento select do form
 * @returns {void}
 */
function handleClimaInputBackupChangeFromEvent(selectElement) {
    const roomId = findRoomId(selectElement);
    if (!roomId) {
        console.warn('‚ùå N√£o foi poss√≠vel encontrar roomId para handleClimaInputBackupChangeFromEvent');
        return;
    }
    
    const newBackupValue = selectElement.value;
    console.log(`üîÑ Backup alterado no form: ${newBackupValue} (sala: ${roomId})`);
    
    // Usa a fun√ß√£o existente que j√° faz todo o trabalho
    handleClimaInputBackupChange(roomId, newBackupValue);
    
    // Tamb√©m dispara o c√°lculo t√©rmico (mant√©m funcionalidade original)
    calculateVazaoArAndThermalGains(roomId);
}
// üîÑ Torna a fun√ß√£o global para ser acess√≠vel do HTML
if (typeof window !== 'undefined') {
    window.handleClimaBackupChange = handleClimaBackupChange;
}
// Exporta√ß√£o das fun√ß√µes do m√≥dulo
export {
  buildCapacityCalculationTable,
  calculateCapacitySolution,
  getCapacityData,
  saveCapacityData,
  loadCapacityData,
  applyCapacityData,
  updateBackupConfiguration,
  handleClimaInputBackupChange,
  syncCapacityTableBackup,
  initializeStaticCapacityTable,
  handleClimaInputBackupChangeFromEvent
}
/* ==== FIM: data/modules/machines/capacity-calculator.js ==== */

/* ==== IN√çCIO: data/builders/ui-folder/data-fillers.js ==== */
// data/modules/climatizacao/data-fill.js 

import { calculateVazaoArAndThermalGains } from '../../../features/calculations/air-flow.js';
import { triggerCalculation } from '../../../core/shared-utils.js';

// ‚úÖ ADICIONAR: Fun√ß√µes de sincroniza√ß√£o locais
function setupRoomTitleChangeListener(roomId) {
    console.log(`üéØ Configurando listener de t√≠tulo para sala: ${roomId}`);
    
    const roomTitle = document.querySelector(`[data-room-id="${roomId}"] .room-title`);
    const ambienteInput = document.querySelector(`input[data-field="ambiente"][data-room-id="${roomId}"]`);
    
    if (roomTitle && ambienteInput) {
        // Sincroniza√ß√£o Ambiente ‚Üí T√≠tulo
        ambienteInput.addEventListener('input', function() {
            if (this.value && this.value.trim() !== '' && this.value !== roomTitle.textContent) {
                if (typeof window.syncAmbienteToTitle === 'function') {
                    window.syncAmbienteToTitle(roomId, this.value);
                } else {
                    // Fallback direto
                    roomTitle.textContent = this.value;
                    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
                    if (roomBlock) {
                        roomBlock.dataset.roomName = this.value;
                    }
                    console.log(`üîÑ Ambiente ‚Üí T√≠tulo: "${this.value}"`);
                }
                triggerCalculation(roomId);
            }
        });
        
        console.log(`‚úÖ Listener t√≠tulo‚Üîambiente configurado para ${roomId}`);
    }
}

// ‚úÖ ADICIONAR: Tornar fun√ß√µes globais para compatibilidade
if (typeof window !== 'undefined') {
    window.setupRoomTitleChangeListener = setupRoomTitleChangeListener;
}

/**
 * Preenche os campos de climatiza√ß√£o de uma sala com dados do JSON
 */
function fillClimatizationInputs(roomElement, inputsData) {
    if (!roomElement || !inputsData) {
        console.error('‚ùå Elemento da sala ou dados inv√°lidos para preenchimento');
        return;
    }

    console.log(`üîÑ Preenchendo inputs de climatiza√ß√£o:`, inputsData);

    const roomId = roomElement.dataset.roomId;
    const roomName = roomElement.dataset.roomName;
    
    // ‚úÖ CORRE√á√ÉO: Preencher campo ambiente com nome da sala se estiver vazio
    const ambienteInput = roomElement.querySelector(`input[data-field="ambiente"]`);
    if (ambienteInput && (!inputsData.ambiente || inputsData.ambiente === '') && roomName) {
        inputsData.ambiente = roomName;
        console.log(`‚úÖ Campo ambiente preenchido automaticamente com nome da sala: "${roomName}"`);
    }
    
    // PRIMEIRO: Processar pressuriza√ß√£o (radio buttons) - CR√çTICO
    if (inputsData.pressurizacao !== undefined) {
        console.log(`üéØ Processando pressuriza√ß√£o para sala ${roomId}:`, inputsData.pressurizacao);
        
        // ‚úÖ CORRE√á√ÉO: Garantir que pressurizacao seja boolean
        const isPressurizacaoAtiva = typeof inputsData.pressurizacao === 'boolean' 
            ? inputsData.pressurizacao 
            : inputsData.pressurizacao === 'true' || inputsData.pressurizacao === true || inputsData.pressurizacao === 1;
        
        const pressurizacaoValue = isPressurizacaoAtiva ? 'sim' : 'nao';
        
        console.log(`üîç Buscando radio buttons para sala ${roomId}, valor: ${pressurizacaoValue}`);
        
        // Buscar todos os radios de pressuriza√ß√£o na sala
        const pressurizacaoRadios = roomElement.querySelectorAll(`input[type="radio"][name*="pressurizacao"]`);
        
        console.log(`üìª Encontrados ${pressurizacaoRadios.length} radios de pressuriza√ß√£o`);
        
        let radioToCheck = null;
        pressurizacaoRadios.forEach(radio => {
            console.log(`üîò Radio: value="${radio.value}", checked=${radio.checked}`);
            if (radio.value === pressurizacaoValue) {
                radioToCheck = radio;
            }
        });

        if (radioToCheck) {
            // Desselecionar todos primeiro
            pressurizacaoRadios.forEach(radio => {
                radio.checked = false;
            });
            
            // Selecionar o correto
            radioToCheck.checked = true;
            console.log(`‚úÖ Pressuriza√ß√£o definida: ${pressurizacaoValue} para sala ${roomId}`);
            
            // Disparar evento change para atualizar campos dependentes
            setTimeout(() => {
                console.log(`üé¨ Disparando evento change para pressuriza√ß√£o`);
                const event = new Event('change', { bubbles: true });
                radioToCheck.dispatchEvent(event);
            }, 100);
        } else {
            console.error(`‚ùå Radio button de pressuriza√ß√£o n√£o encontrado para valor: ${pressurizacaoValue}`);
        }
    }

    // SEGUNDO: Preencher inputs espec√≠ficos da pressuriza√ß√£o primeiro
    setTimeout(() => {
        console.log(`üîß Preenchendo campos espec√≠ficos de pressuriza√ß√£o para ${roomId}`);
        
        // ‚úÖ CORRE√á√ÉO: Preencher pressurizacaoSetpoint como n√∫mero
        if (inputsData.pressurizacaoSetpoint !== undefined) {
            const pressurizacaoInput = roomElement.querySelector(`.clima-input[data-field="pressurizacaoSetpoint"]`);
            if (pressurizacaoInput) {
                // Converter para n√∫mero garantido
                const numericValue = parseFloat(inputsData.pressurizacaoSetpoint) || 25;
                pressurizacaoInput.value = numericValue;
                console.log(`‚úÖ Campo pressurizacaoSetpoint definido: ${numericValue}`);
                
                setTimeout(() => {
                    const event = new Event('change', { bubbles: true });
                    pressurizacaoInput.dispatchEvent(event);
                }, 50);
            } else {
                console.warn(`‚ö†Ô∏è Campo pressurizacaoSetpoint n√£o encontrado na sala ${roomId}`);
            }
        }

        // ‚úÖ CORRE√á√ÉO: Preencher numPortasDuplas como n√∫mero
        if (inputsData.numPortasDuplas !== undefined) {
            const portasDuplasInput = roomElement.querySelector(`.clima-input[data-field="numPortasDuplas"]`);
            if (portasDuplasInput) {
                const numericValue = parseFloat(inputsData.numPortasDuplas) || 0;
                portasDuplasInput.value = numericValue;
                console.log(`‚úÖ Campo numPortasDuplas definido: ${numericValue}`);
            }
        }

        // ‚úÖ CORRE√á√ÉO: Preencher numPortasSimples como n√∫mero
        if (inputsData.numPortasSimples !== undefined) {
            const portasSimplesInput = roomElement.querySelector(`.clima-input[data-field="numPortasSimples"]`);
            if (portasSimplesInput) {
                const numericValue = parseFloat(inputsData.numPortasSimples) || 0;
                portasSimplesInput.value = numericValue;
                console.log(`‚úÖ Campo numPortasSimples definido: ${numericValue}`);
            }
        }

    }, 200);

    // TERCEIRO: Preencher outros inputs gerais
    setTimeout(() => {
        const textInputs = roomElement.querySelectorAll('.clima-input[type="text"], .clima-input[type="number"], .clima-input[data-field]');
        console.log(`üìã Encontrados ${textInputs.length} inputs para processar`);
        
        textInputs.forEach(input => {
            const field = input.getAttribute('data-field');
            if (!field || inputsData[field] === undefined) {
                console.log(`‚è≠Ô∏è  Campo ${field} n√£o encontrado nos dados, pulando`);
                return;
            }

            // Pular campos j√° preenchidos espec√≠ficos da pressuriza√ß√£o
            if (field === 'pressurizacaoSetpoint' || field === 'numPortasDuplas' || field === 'numPortasSimples') {
                console.log(`‚è≠Ô∏è  Campo ${field} j√° preenchido, pulando`);
                return;
            }
            
            let value = inputsData[field];
            
            // ‚úÖ CORRE√á√ÉO: Converter boolean e valores inv√°lidos para n√∫mero
            if (input.type === 'number') {
                if (value === false || value === 'false' || value === null || value === '') {
                    value = 0;
                }
                if (value === true || value === 'true') {
                    value = 1;
                }
                
                // Garantir que √© um n√∫mero v√°lido
                const numericValue = parseFloat(value);
                value = isNaN(numericValue) ? 0 : numericValue;
            }
            
            input.value = value;
            console.log(`‚úÖ Campo ${field} preenchido: ${value}`);

            setTimeout(() => {
                const event = new Event('change', { bubbles: true });
                input.dispatchEvent(event);
            }, 50);
        });

        // QUARTO: Preencher selects
        const selectInputs = roomElement.querySelectorAll('select.clima-input[data-field]');
        selectInputs.forEach(select => {
            const field = select.getAttribute('data-field');
            if (!field || inputsData[field] === undefined) return;

            const value = inputsData[field];
            select.value = value;
            console.log(`‚úÖ Select ${field} preenchido: ${value}`);

            setTimeout(() => {
                const event = new Event('change', { bubbles: true });
                select.dispatchEvent(event);
            }, 50);
        });

        // QUINTO: Verifica√ß√£o final do estado
        setTimeout(() => {
            console.log(`üîç Verifica√ß√£o final do estado para sala ${roomId}`);
            
            // Verificar estado dos campos de pressuriza√ß√£o
            const pressurizacaoInput = roomElement.querySelector('.clima-input[data-field="pressurizacaoSetpoint"]');
            const portasDuplasInput = roomElement.querySelector('.clima-input[data-field="numPortasDuplas"]');
            const portasSimplesInput = roomElement.querySelector('.clima-input[data-field="numPortasSimples"]');
            
            console.log(`üìä Estado final dos campos:`);
            console.log(`- Pressuriza√ß√£o Setpoint:`, pressurizacaoInput?.value);
            console.log(`- Portas Duplas:`, portasDuplasInput?.value);
            console.log(`- Portas Simples:`, portasSimplesInput?.value);
            console.log(`- Pressuriza√ß√£o ativa:`, inputsData.pressurizacao);
            
            // Se pressuriza√ß√£o for false, garantir que campos relacionados estejam zerados
            if (inputsData.pressurizacao === false) {
                console.log(`üîí Pressuriza√ß√£o desativada - verificando campos`);
                if (pressurizacaoInput && (!inputsData.pressurizacaoSetpoint || inputsData.pressurizacaoSetpoint === "0" || inputsData.pressurizacaoSetpoint === 0)) {
                    pressurizacaoInput.value = "0";
                    console.log(`‚úÖ Pressuriza√ß√£o desativada - setpoint zerado`);
                }
                if (portasDuplasInput && (!inputsData.numPortasDuplas || inputsData.numPortasDuplas === "0" || inputsData.numPortasDuplas === 0)) {
                    portasDuplasInput.value = "0";
                    console.log(`‚úÖ Pressuriza√ß√£o desativada - portas duplas zeradas`);
                }
                if (portasSimplesInput && (!inputsData.numPortasSimples || inputsData.numPortasSimples === "0" || inputsData.numPortasSimples === 0)) {
                    portasSimplesInput.value = "0";
                    console.log(`‚úÖ Pressuriza√ß√£o desativada - portas simples zeradas`);
                }
            }
            
            // ‚úÖ CORRE√á√ÉO MELHORADA: Configurar TODAS as sincroniza√ß√µes ap√≥s preenchimento
            setTimeout(() => {
                console.log(`üéØ CONFIGURANDO TODAS AS SINCRONIZA√á√ïES PARA: ${roomId}`);
                
                // 1. Sincroniza√ß√£o T√≠tulo ‚Üî Ambiente
                setupRoomTitleChangeListener(roomId);
                
                // 2. Sincroniza√ß√£o das Paredes usando a l√≥gica escolhida
                if (typeof window.setupCompleteRoomSync === 'function') {
                    window.setupCompleteRoomSync(roomId);
                }
                
                console.log(`‚úÖ Todas as sincroniza√ß√µes configuradas para: ${roomId}`);
            }, 500);

            console.log(`‚úÖ Processo de preenchimento iniciado para sala ${roomId}`);
            
            // Disparar c√°lculo final ap√≥s todos os campos estarem preenchidos
            if (roomId && typeof calculateVazaoArAndThermalGains === 'function') {
                setTimeout(() => {
                    console.log(`üßÆ Disparando c√°lculo final para sala ${roomId}`);
                    calculateVazaoArAndThermalGains(roomId);
                }, 300);
            }

        }, 150);

    }, 400); // Delay maior para garantir que a pressuriza√ß√£o foi processada primeiro

    console.log(`‚úÖ Processo de preenchimento iniciado para sala ${roomId}`);
}

/**
 * Preenche os dados de ganhos t√©rmicos nos elementos da sala
 */
function fillThermalGainsData(roomElement, thermalGainsData) {
    if (!roomElement || !thermalGainsData) {
        console.error('‚ùå Elemento da sala ou dados de ganhos t√©rmicos inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo ganhos t√©rmicos para sala ${roomId}:`, thermalGainsData);

    // ‚úÖ CORRE√á√ÉO: Atualizar os seletores para os novos IDs
    const gainSelectors = {
        'total-ganhos-w': `#total-ganhos-w-${roomId}`,
        'total-tr-aprox': `#total-tr-aprox-${roomId}`, // ‚úÖ NOVO: valor aproximado
        'total-tr-exato': `#total-tr-exato-${roomId}`, // ‚úÖ NOVO: valor exato
        'total-externo': `#total-externo-${roomId}`,
        'total-divisoes': `#total-divisoes-${roomId}`,
        'total-piso': `#total-piso-${roomId}`,
        'total-iluminacao': `#total-iluminacao-${roomId}`,
        'total-dissi': `#total-dissi-${roomId}`,
        'total-pessoas': `#total-pessoas-${roomId}`,
        'total-ar-sensivel': `#total-ar-sensivel-${roomId}`,
        'total-ar-latente': `#total-ar-latente-${roomId}`
    };

    Object.entries(gainSelectors).forEach(([key, selector]) => {
        const element = document.querySelector(selector);
        if (element && thermalGainsData[key] !== undefined) {
            // ‚úÖ CORRE√á√ÉO: Para valor TR exato, manter 3 casas decimais
            if (key === 'total-tr-exato' && typeof thermalGainsData[key] === 'number') {
                element.textContent = thermalGainsData[key].toFixed(3);
            } else {
                element.textContent = thermalGainsData[key];
            }
            console.log(`‚úÖ ${key} preenchido: ${thermalGainsData[key]}`);
        }
    });

    console.log(`‚úÖ Ganhos t√©rmicos preenchidos para sala ${roomId}`);
}

/**
 * Preenche os dados de capacidade de refrigera√ß√£o da sala
 */
function fillCapacityData(roomElement, capacityData) {
    if (!roomElement || !capacityData) {
        console.error('‚ùå Elemento da sala ou dados de capacidade inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo dados de capacidade para sala ${roomId}:`, capacityData);

    const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`);
    if (fatorSegurancaInput && capacityData.fatorSeguranca !== undefined) {
        fatorSegurancaInput.value = capacityData.fatorSeguranca;
        console.log(`‚úÖ Fator seguran√ßa preenchido: ${capacityData.fatorSeguranca}`);
    }

    const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`);
    if (capacidadeUnitariaSelect && capacityData.capacidadeUnitaria !== undefined) {
        capacidadeUnitariaSelect.value = capacityData.capacidadeUnitaria;
        console.log(`‚úÖ Capacidade unit√°ria preenchida: ${capacityData.capacidadeUnitaria}`);
    }

    const backupSelect = roomElement.querySelector('.backup-select');
    if (backupSelect && capacityData.backup !== undefined) {
        backupSelect.value = capacityData.backup;
        console.log(`‚úÖ Backup preenchido: ${capacityData.backup}`);
    }

    console.log(`‚úÖ Dados de capacidade preenchidos para sala ${roomId}`);
}

/**
 * Preenche as configura√ß√µes de instala√ß√£o da sala
 */
function fillConfigurationData(roomElement, configData) {
    if (!roomElement || !configData) {
        console.error('‚ùå Elemento da sala ou dados de configura√ß√£o inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo configura√ß√µes para sala ${roomId}:`, configData);

    if (configData.opcoesInstalacao && Array.isArray(configData.opcoesInstalacao)) {
        configData.opcoesInstalacao.forEach(optionValue => {
            const checkbox = roomElement.querySelector(`input[name^="opcoesInstalacao-"][value="${optionValue}"]`);
            if (checkbox) {
                checkbox.checked = true;
                console.log(`‚úÖ Checkbox marcado: ${optionValue}`);
            }
        });
    }

    console.log(`‚úÖ Configura√ß√µes preenchidas para sala ${roomId}`);
}

/**
 * Garante que todas as se√ß√µes da sala est√£o criadas e inicializadas
 */
async function ensureAllRoomSections(roomElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala inv√°lido');
        return false;
    }

    const obraId = roomElement.dataset.obraId;
    const projectId = roomElement.dataset.projectId; 
    const roomName = roomElement.dataset.roomName;
    const roomId = roomElement.dataset.roomId;

    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido: "${roomId}" para sala ${roomName}`);
        return false;
    }

    console.log(`üî® Verificando se√ß√µes da sala ${roomName} (ID: ${roomId})`);

    // ‚úÖ CORRE√á√ÉO: Usar as novas fun√ß√µes para verificar se√ß√µes
    const climatizationSection = findSectionByTitle(roomElement, 'Climatiza√ß√£o');
    const machinesSection = findMachinesSection(roomElement);
    const configurationSection = findSectionByTitle(roomElement, 'Configura√ß√£o');

    if (climatizationSection && machinesSection && configurationSection) {
        console.log(`‚úÖ Todas as se√ß√µes j√° existem para sala ${roomName}`);
        return true;
    }

    console.log(`üîÑ Criando se√ß√µes faltantes para sala ${roomName}`);

    try {
        const roomContent = roomElement.querySelector('.room-content');
        if (!roomContent) {
            console.error(`‚ùå Container de conte√∫do da sala n√£o encontrado`);
            return false;
        }

        if (!climatizationSection) {
            console.log(`üèóÔ∏è Criando todas as se√ß√µes para sala ${roomName}`);

            if (typeof window.buildClimatizationSection !== 'function' || 
                typeof buildMachinesSection !== 'function' ||
                typeof window.buildConfigurationSection !== 'function') {
                console.error('‚ùå Fun√ß√µes de constru√ß√£o de se√ß√µes n√£o dispon√≠veis');
                return false;
            }

            // Criar se√ß√£o de climatiza√ß√£o
            const climatizationHTML = await window.buildClimatizationSection(obraId, projectId, roomName, roomId);
            if (climatizationHTML) {
                roomContent.insertAdjacentHTML('beforeend', climatizationHTML);
                console.log(`‚úÖ Se√ß√£o de climatiza√ß√£o criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Criar se√ß√£o de m√°quinas
            const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
            if (machinesHTML) {
                roomContent.insertAdjacentHTML('beforeend', machinesHTML);
                console.log(`‚úÖ Se√ß√£o de m√°quinas criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Criar se√ß√£o de configura√ß√£o
            const configurationHTML = await window.buildConfigurationSection(obraId, projectId, roomName, roomId);
            if (configurationHTML) {
                roomContent.insertAdjacentHTML('beforeend', configurationHTML);
                console.log(`‚úÖ Se√ß√£o de configura√ß√£o criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 500));

            console.log(`‚úÖ Todas as se√ß√µes criadas para sala ${roomName}`);
            return true;
        }

        // Criar apenas se√ß√µes faltantes
        if (climatizationSection && !machinesSection) {
            console.log(`üî® Criando apenas se√ß√£o de m√°quinas para sala ${roomName}`);

            const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
            if (machinesHTML) {
                climatizationSection.insertAdjacentHTML('afterend', machinesHTML);
                console.log(`‚úÖ Se√ß√£o de m√°quinas criada`);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                return true;
            }
        }
        setTimeout(() => {
            console.log(`üîß CONFIGURANDO SINCRONIZA√á√ïES AP√ìS CRIAR SE√á√ïES: ${roomId}`);
            
            if (typeof window.setupCompleteRoomSync === 'function') {
                window.setupCompleteRoomSync(roomId);
            }
            
            console.log(`‚úÖ Sincroniza√ß√µes configuradas ap√≥s cria√ß√£o de se√ß√µes: ${roomId}`);
        }, 1000);
        console.log(`‚ùå N√£o foi poss√≠vel criar todas as se√ß√µes para sala ${roomName}`);
        return false;

    } catch (error) {
        console.error(`‚ùå Erro ao criar se√ß√µes da sala ${roomName}:`, error);
        return false;
    }
}

// EXPORTS NO FINAL
export {
    fillClimatizationInputs,
    fillThermalGainsData,
    fillCapacityData,
    fillConfigurationData,
    ensureAllRoomSections,
    setupRoomTitleChangeListener
};
/* ==== FIM: data/builders/ui-folder/data-fillers.js ==== */

/* ==== IN√çCIO: data/builders/ui-folder/machine-renderer.js ==== */
import { buildMachinesSection, addMachine } from '../../modules/machines/machines-core.js';

/**
 * Encontra se√ß√£o de m√°quinas pelo t√≠tulo
 */
function findMachinesSection(roomElement) {
    if (!roomElement) return null;
    
    // Buscar todas as se√ß√µes .section-block
    const allSections = roomElement.querySelectorAll('.section-block');
    
    // Encontrar a que tem "M√°quinas" no t√≠tulo
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes('M√°quinas')) {
            return section;
        }
    }
    
    return null;
}

/**
 * ‚úÖ FUN√á√ÉO AUXILIAR: Encontrar se√ß√£o por t√≠tulo
 */
function findSectionByTitle(roomElement, titleText) {
    if (!roomElement) return null;
    
    const allSections = roomElement.querySelectorAll('.section-block');
    
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes(titleText)) {
            return section;
        }
    }
    
    return null;
}

/**
 * Garante que a se√ß√£o de m√°quinas existe e est√° inicializada - VERS√ÉO CORRIGIDA
 */
async function ensureMachinesSection(roomElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala inv√°lido');
        return null;
    }

    const obraId = roomElement.dataset.obraId;
    const projectId = roomElement.dataset.projectId;
    const roomName = roomElement.dataset.roomName;
    const roomId = roomElement.dataset.roomId;

    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido: "${roomId}" para sala ${roomName}`);
        return null;
    }

    console.log(`üî® Garantindo se√ß√£o de m√°quinas para sala ${roomName} (ID: ${roomId})`);

    // Primeiro garantir que todas as se√ß√µes existem
    const sectionsReady = await ensureAllRoomSections(roomElement);
    if (!sectionsReady) {
        console.error(`‚ùå N√£o foi poss√≠vel garantir todas as se√ß√µes para sala ${roomName}`);
        return null;
    }

    // ‚úÖ CORRE√á√ÉO: Buscar por .section-block que contenha "M√°quinas" no t√≠tulo
    let machinesSection = findMachinesSection(roomElement);
    
    if (machinesSection) {
        console.log(`‚úÖ Se√ß√£o de m√°quinas encontrada para sala ${roomName}`);
        return machinesSection;
    }

    // Se ainda n√£o existe, tentar criar apenas a se√ß√£o de m√°quinas
    console.log(`üîÑ Tentando criar apenas se√ß√£o de m√°quinas para sala ${roomName}`);

    // Encontrar a √∫ltima se√ß√£o para inserir ap√≥s ela
    const lastSection = roomElement.querySelector('.section-block:last-child') || 
                       roomElement.querySelector('.room-content > :last-child');

    if (!lastSection) {
        console.error(`‚ùå Nenhuma se√ß√£o encontrada para inserir m√°quinas`);
        return null;
    }

    if (typeof buildMachinesSection !== 'function') {
        console.error('‚ùå Fun√ß√£o buildMachinesSection n√£o dispon√≠vel');
        return null;
    }

    try {
        const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
        if (!machinesHTML) {
            console.error('‚ùå HTML da se√ß√£o de m√°quinas n√£o gerado');
            return null;
        }

        lastSection.insertAdjacentHTML('afterend', machinesHTML);
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // ‚úÖ CORRE√á√ÉO: Usar a nova fun√ß√£o para encontrar a se√ß√£o
        machinesSection = findMachinesSection(roomElement);
        if (machinesSection) {
            console.log(`‚úÖ Se√ß√£o de m√°quinas criada com sucesso para sala ${roomName}`);
            return machinesSection;
        } else {
            console.error(`‚ùå Se√ß√£o de m√°quinas n√£o encontrada ap√≥s cria√ß√£o`);
            return null;
        }

    } catch (error) {
        console.error(`‚ùå Erro ao criar se√ß√£o de m√°quinas:`, error);
        return null;
    }
}

/**
 * Preenche os dados das m√°quinas de uma sala - VERS√ÉO CORRIGIDA
 */
async function fillMachinesData(roomElement, machinesData) {
    if (!roomElement || !machinesData || !Array.isArray(machinesData)) {
        console.error('‚ùå Elemento da sala ou dados de m√°quinas inv√°lidos');
        return false;
    }

    const roomId = roomElement.dataset.roomId;
    const roomName = roomElement.dataset.roomName;
    
    console.log(`üîÑ Preenchendo ${machinesData.length} m√°quina(s) para sala ${roomName} (ID: ${roomId})`);

    // ‚úÖ CORRE√á√ÉO: Verificar se h√° m√°quinas para preencher
    if (machinesData.length === 0) {
        console.log(`‚ÑπÔ∏è Nenhuma m√°quina para preencher na sala ${roomName}`);
        return true; // Retorna true porque n√£o h√° erro, s√≥ n√£o h√° m√°quinas
    }

    try {
        const machinesSection = await ensureMachinesSection(roomElement);
        if (!machinesSection) {
            console.error(`‚ùå N√£o foi poss√≠vel criar/obter se√ß√£o de m√°quinas para sala ${roomName}`);
            return false;
        }

        const machinesContainer = machinesSection.querySelector('.machines-container');
        if (!machinesContainer) {
            console.error(`‚ùå Container de m√°quinas n√£o encontrado para sala ${roomName}`);
            return false;
        }

        console.log(`‚úÖ Container de m√°quinas encontrado`);

        // Limpar m√°quinas existentes
        const existingMachines = machinesContainer.querySelectorAll('.climatization-machine, .machine-block');
        if (existingMachines.length > 0) {
            console.log(`üóëÔ∏è Removendo ${existingMachines.length} m√°quina(s) existente(s)`);
            existingMachines.forEach(machine => machine.remove());
        }

        let successCount = 0;

        // Adicionar cada m√°quina
        for (let i = 0; i < machinesData.length; i++) {
            const machineData = machinesData[i];
            
            if (!machineData || !machineData.tipo) {
                console.warn(`‚ö†Ô∏è Dados da m√°quina ${i} inv√°lidos:`, machineData);
                continue;
            }

            console.log(`ü§ñ [${i + 1}/${machinesData.length}] Adicionando m√°quina: ${machineData.tipo}`);

            try {
                // ‚úÖ CORRE√á√ÉO: Usar addMachine com retry
                let machineAdded = false;
                let retryCount = 0;
                
                while (!machineAdded && retryCount < 3) {
                    machineAdded = await addMachine(roomId, machineData.tipo);
                    
                    if (!machineAdded) {
                        retryCount++;
                        console.log(`üîÑ Tentativa ${retryCount}/3 para adicionar m√°quina ${machineData.tipo}`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                if (!machineAdded) {
                    console.error(`‚ùå Falha ao adicionar m√°quina ${machineData.tipo} ap√≥s ${retryCount} tentativas`);
                    continue;
                }

                console.log(`‚úÖ M√°quina ${machineData.tipo} adicionada, aguardando renderiza√ß√£o...`);

                // Aguardar renderiza√ß√£o completa
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Encontrar a m√°quina mais recente
                const machineElements = machinesContainer.querySelectorAll('.climatization-machine');
                const lastMachine = machineElements[machineElements.length - 1];
                
                if (!lastMachine) {
                    console.error(`‚ùå Elemento da m√°quina n√£o encontrado ap√≥s adi√ß√£o`);
                    continue;
                }

                console.log(`‚úÖ Elemento da m√°quina encontrado, preenchendo dados...`);

                // Preencher dados da m√°quina
                const populated = await populateMachineData(lastMachine, machineData);
                if (populated) {
                    successCount++;
                    console.log(`üéâ M√°quina ${machineData.tipo} preenchida com sucesso`);
                } else {
                    console.error(`‚ùå Falha ao preencher dados da m√°quina ${machineData.tipo}`);
                }

            } catch (error) {
                console.error(`‚ùå Erro ao processar m√°quina ${machineData.tipo}:`, error);
            }

            // Pequena pausa entre m√°quinas
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        console.log(`‚úÖ ${successCount}/${machinesData.length} m√°quina(s) preenchida(s) com sucesso para sala ${roomName}`);
        
        // ‚úÖ CORRE√á√ÉO: Retorna true se pelo menos uma m√°quina foi preenchida, ou se n√£o havia m√°quinas
        return successCount > 0 || machinesData.length === 0;

    } catch (error) {
        console.error(`‚ùå Erro cr√≠tico ao preencher m√°quinas para sala ${roomName}:`, error);
        return false;
    }
}

/**
 * Preenche os dados individuais de uma m√°quina
 */
async function populateMachineData(machineElement, machineData) {
    if (!machineElement || !machineData) {
        console.error('‚ùå Elemento da m√°quina ou dados inv√°lidos');
        return false;
    }

    console.log(`üîß Preenchendo dados da m√°quina:`, machineData);

    try {
        const machineId = machineElement.dataset.machineId;

        // 1. DEFINIR TIPO (se dispon√≠vel)
        const typeSelect = machineElement.querySelector('.machine-type-select');
        if (typeSelect && machineData.tipo) {
            typeSelect.value = machineData.tipo;
            const typeEvent = new Event('change', { bubbles: true });
            typeSelect.dispatchEvent(typeEvent);
            console.log(`‚úÖ Tipo definido: ${machineData.tipo}`);
            
            // Aguardar processamento do tipo
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // 2. DEFINIR CAPACIDADE (se dispon√≠vel e habilitado)
        const powerSelect = machineElement.querySelector('.machine-power-select');
        if (powerSelect && machineData.potencia) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (powerSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da capacidade... (${attempts}/6)`);
            }
            
            if (!powerSelect.disabled) {
                const powerOption = Array.from(powerSelect.options).find(opt => 
                    opt.text.includes(machineData.potencia) || 
                    opt.value.includes(machineData.potencia) ||
                    opt.text.toLowerCase().includes(machineData.potencia.toLowerCase())
                );
                
                if (powerOption) {
                    powerSelect.value = powerOption.value;
                    const powerEvent = new Event('change', { bubbles: true });
                    powerSelect.dispatchEvent(powerEvent);
                    console.log(`‚úÖ Capacidade definida: ${powerOption.value}`);
                    
                    // Aguardar processamento da capacidade
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    console.log(`‚ö†Ô∏è Capacidade "${machineData.potencia}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de capacidade permanece desabilitado`);
            }
        }

        // 3. DEFINIR TENS√ÉO (se dispon√≠vel e habilitado)
        const voltageSelect = machineElement.querySelector('.machine-voltage-select');
        if (voltageSelect && machineData.tensao) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (voltageSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da tens√£o... (${attempts}/6)`);
            }
            
            if (!voltageSelect.disabled) {
                const voltageOption = Array.from(voltageSelect.options).find(opt => 
                    opt.text.includes(machineData.tensao) || 
                    opt.value.includes(machineData.tensao) ||
                    opt.text.toLowerCase().includes(machineData.tensao.toLowerCase())
                );
                
                if (voltageOption) {
                    voltageSelect.value = voltageOption.value;
                    const voltageEvent = new Event('change', { bubbles: true });
                    voltageSelect.dispatchEvent(voltageEvent);
                    console.log(`‚úÖ Tens√£o definida: ${voltageOption.value}`);
                } else {
                    console.log(`‚ö†Ô∏è Tens√£o "${machineData.tensao}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de tens√£o permanece desabilitado`);
            }
        }

        // 4. DEFINIR OP√á√ïES SELECIONADAS (se dispon√≠veis)
        if (machineData.opcoesSelecionadas && Array.isArray(machineData.opcoesSelecionadas)) {
            // Aguardar carregamento das op√ß√µes
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const optionsContainer = machineElement.querySelector('.options-grid');
            
            if (optionsContainer) {
                const allCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                console.log(`üîç Encontrados ${allCheckboxes.length} checkboxes de op√ß√µes`);

                let optionsMarked = 0;
                machineData.opcoesSelecionadas.forEach(optionObj => {
                    // ‚úÖ CORRE√á√ÉO: Suporta tanto array de strings quanto array de objetos
                    let optionName;
                    if (typeof optionObj === 'string') {
                        optionName = optionObj;
                    } else if (typeof optionObj === 'object') {
                        optionName = optionObj.name || optionObj.originalName;
                    }
                    
                    if (!optionName) {
                        console.log(`‚ö†Ô∏è Op√ß√£o inv√°lida:`, optionObj);
                        return;
                    }

                    console.log(`Procurando op√ß√£o: "${optionName}"`);
                    
                    // Buscar pelo data-option-name (mais confi√°vel)
                    const checkbox = Array.from(allCheckboxes).find(cb => {
                        const dataName = cb.getAttribute('data-option-name');
                        return dataName === optionName;
                    });
                    
                    if (checkbox) {
                        checkbox.checked = true;
                        const checkboxEvent = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(checkboxEvent);
                        optionsMarked++;
                        console.log(`‚úÖ Op√ß√£o marcada: ${optionName}`);
                    } else {
                        console.log(`‚ùå Op√ß√£o n√£o encontrada: "${optionName}"`);
                        
                        // Debug: tentar encontrar por texto do label
                        const allOptions = optionsContainer.querySelectorAll('.option-item');
                        const foundByText = Array.from(allOptions).find(optionItem => {
                            const nameElement = optionItem.querySelector('.option-name');
                            return nameElement && nameElement.textContent.includes(optionName);
                        });
                        
                        if (foundByText) {
                            const checkboxInItem = foundByText.querySelector('input[type="checkbox"]');
                            if (checkboxInItem) {
                                checkboxInItem.checked = true;
                                const checkboxEvent = new Event('change', { bubbles: true });
                                checkboxInItem.dispatchEvent(checkboxEvent);
                                optionsMarked++;
                                console.log(`‚úÖ Op√ß√£o marcada (por texto): ${optionName}`);
                            }
                        }
                    }
                });
                
                console.log(`üìä Op√ß√µes marcadas: ${optionsMarked}/${machineData.opcoesSelecionadas.length}`);
            } else {
                console.log(`‚ö†Ô∏è Container de op√ß√µes n√£o encontrado`);
            }
        }

        // 5. DEFINIR PRE√áOS (se dispon√≠veis)
        if (machineData.precoBase !== undefined) {
            const basePriceElement = document.getElementById(`base-price-${machineId}`);
            if (basePriceElement) {
                basePriceElement.textContent = `R$ ${machineData.precoBase.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo base definido: R$ ${machineData.precoBase}`);
            }
        }

        if (machineData.precoTotal !== undefined) {
            const totalPriceElement = document.getElementById(`total-price-${machineId}`);
            if (totalPriceElement) {
                totalPriceElement.textContent = `R$ ${machineData.precoTotal.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo total definido: R$ ${machineData.precoTotal}`);
            }
        }

        // 6. DEFINIR NOME (se dispon√≠vel)
        if (machineData.nome) {
            const nameInput = machineElement.querySelector('.machine-title-editable');
            if (nameInput) {
                nameInput.value = machineData.nome;
                console.log(`‚úÖ Nome definido: ${machineData.nome}`);
            }
        }

        // 7. DISPARAR C√ÅLCULO FINAL
        setTimeout(() => {
            if (typeof calculateMachinePrice === 'function') {
                calculateMachinePrice(machineId);
                console.log('‚úÖ C√°lculo de pre√ßo finalizado');
            }
        }, 500);

        console.log(`‚úÖ Dados da m√°quina preenchidos com sucesso`);
        return true;

    } catch (error) {
        console.error(`‚ùå Erro ao preencher dados da m√°quina:`, error);
        return false;
    }
}

// EXPORTS NO FINAL
export {
    findMachinesSection,
    findSectionByTitle,
    ensureMachinesSection,
    fillMachinesData,
    populateMachineData
};
/* ==== FIM: data/builders/ui-folder/machine-renderer.js ==== */

/* ==== IN√çCIO: data/modules/machines/machines-core.js ==== */
/**
 * data/modules/machines/machines-core.js
 * Sistema unificado de m√°quinas - FUS√ÉO OTIMIZADA: machineManagement.js + machinesBuilder.js
 * Vers√£o reduzida de ~1100 para ~400 linhas
 */

import { buildCapacityCalculationTable } from './capacity-calculator.js';
import { updateElementText, safeNumber } from '../../utils/core-utils.js';
import { generateMachineId } from '../../utils/id-generator.js';

// =============================================================================
// CACHE E ESTADO GLOBAL
// =============================================================================

if (typeof window !== 'undefined' && !window.machinesDataCache) {
    window.machinesDataCache = null;
}

// =============================================================================
// FUN√á√ïES CORE UNIFICADAS
// =============================================================================


/**
 * Carrega dados das m√°quinas com cache
 */
async function loadMachinesData() {
    if (window.machinesDataCache?.machines?.length) {
        return window.machinesDataCache;
    }

    try {
        const response = await fetch('/machines');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        const machinesData = { machines: Array.isArray(data) ? data : data.machines };

        window.machinesDataCache = machinesData;
        window.machinesData = machinesData.machines;
        return machinesData;

    } catch (error) {
        console.error("‚ùå Erro ao carregar m√°quinas:", error);
        return window.machinesDataCache || { machines: [] };
    }
}

// =============================================================================
// CONSTRU√á√ÉO DE UI UNIFICADA
// =============================================================================

/**
 * Constr√≥i se√ß√£o completa de m√°quinas
 */
function buildMachinesSection(obraId, projectId, roomName, finalRoomId) {
    if (!finalRoomId) return '';

    return `
    <div class="section-block">
      <div class="section-header-machine">
        <button class="minimizer" onclick="toggleSection('${finalRoomId}-maquinas')">+</button>
        <h4 class="section-title">M√°quinas</h4>
        
      </div>
      <div class="section-content collapsed" id="section-content-${finalRoomId}-maquinas">
        ${buildCapacityCalculationTable(finalRoomId)}
        <div class="machines-container" id="machines-${finalRoomId}">
          <p class="empty-message">Nenhuma m√°quina adicionada ainda.</p>
        </div>
        <div class="add-machine">
            <button class="btn btn-add-secondary" onclick="addMachine('${finalRoomId}')">+ Adicionar M√°quina</button> 
        </div>
        <div class="all-machines-total-price">
          <strong>Total de Maquinas: <span id="total-all-machines-price-${finalRoomId}">R$ 0,00</span></strong>
        </div>
      </div>
    </div>`;
}

/**
 * Constr√≥i HTML de m√°quina individual
 */
function buildMachineHTML(machineId, displayNumber, machines, roomId) {
    const machineTypes = machines.map(m => m.type);

    return `
    <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${roomId}">
      <div class="machine-header">
        <button class="minimizer" onclick="toggleMachineSection(this)">‚àí</button>
        <input type="text" class="machine-title-editable" value="Maquina${displayNumber}" 
               onchange="updateMachineTitle(this, '${machineId}')" onclick="this.select()">
        <button class="btn btn-delete-small" onclick="deleteMachine('${machineId}')">Remover</button>
      </div>
      <div class="machine-content" id="machine-content-${machineId}">
        <div class="climatization-form-grid">
          ${buildFormGroup("Tipo:", buildSelect(machineTypes, machineId, "machine-type-select", "updateMachineOptions(this)"))}
          ${buildFormGroup("Capacidade:", buildSelect([], machineId, "machine-power-select", `handlePowerChange('${machineId}')`, true))}
          ${buildFormGroup("Tens√£o:", buildSelect([], machineId, "machine-voltage-select", `calculateMachinePrice('${machineId}')`, true))}
          ${buildFormGroup("Pre√ßo Base:", `<div class="price-display" id="base-price-${machineId}">R$ 0,00</div>`)}
          ${buildFormGroup("Pre√ßo Total:", `<div class="price-display" id="total-price-${machineId}">R$ 0,00</div>`)}
        </div>
        <div class="machine-options-section">
          <h6>Op√ß√µes Adicionais:</h6>
          <div class="options-grid" id="options-container-${machineId}">
            <p class="empty-options-message">Selecione tipo e capacidade</p>
          </div>
        </div>
        <div class="machine-config-section">
          <h6>Configura√ß√µes de Maquina</h6>
          <div class="config-grid" id="config-container-${machineId}">
            <p class="empty-config-message">Selecione tipo e capacidade</p>
          </div>
        </div>
      </div>
    </div>`;
}

/**
 * Constr√≥i m√°quina a partir de dados salvos
 */
function buildMachineFromSavedData(machineId, savedMachine, allMachines) {
    const machineType = allMachines.find(m => m.type === savedMachine.tipo);
    if (!machineType) return '';

    const potencies = Object.keys(machineType.baseValues || {});
    const voltages = (machineType.voltages || []).map(v => v.name);

    return `
    <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${savedMachine.roomId || ''}">
      <div class="machine-header">
        <button class="minimizer" onclick="toggleMachineSection(this)">‚àí</button>
        <input type="text" class="machine-title-editable" value="${savedMachine.nome || 'Maquina'}"
               onchange="updateMachineTitle(this, '${machineId}')" onclick="this.select()">
        <button class="btn btn-delete-small" onclick="deleteMachine('${machineId}')">Remover</button>
      </div>
      <div class="machine-content" id="machine-content-${machineId}">
        <div class="climatization-form-grid">
          ${buildFormGroup("Tipo:", buildSelect(allMachines.map(m => m.type), machineId, "machine-type-select", "updateMachineOptions(this)", false, savedMachine.tipo))}
          ${buildFormGroup("Capacidade:", buildSelect(potencies, machineId, "machine-power-select", `handlePowerChange('${machineId}')`, false, savedMachine.potencia))}
          ${buildFormGroup("Tens√£o:", buildSelect(voltages, machineId, "machine-voltage-select", `calculateMachinePrice('${machineId}')`, false, savedMachine.tensao))}
          ${buildFormGroup("Pre√ßo Base:", `<div class="price-display" id="base-price-${machineId}">R$ 0,00</div>`)}
          ${buildFormGroup("Pre√ßo Total:", `<div class="price-display" id="total-price-${machineId}">R$ ${savedMachine.precoTotal.toLocaleString("pt-BR")}</div>`)}
        </div>
        <div class="machine-options-section">
          <h6>Op√ß√µes Adicionais:</h6>
          <div class="options-grid" id="options-container-${machineId}">
            ${buildOptionsHTML(machineType.options, machineId, savedMachine.opcoesSelecionadas, savedMachine.potencia)}
          </div>
        </div>
        <div class="machine-config-section">
          <h6>Configura√ß√µes de Maquina</h6>
          <div class="config-grid" id="config-container-${machineId}">
            ${buildConfigHTML(machineType.options, machineId, savedMachine.opcoesSelecionadas, savedMachine.potencia)}
          </div>
        </div>
      </div>
    </div>`;
}

// =============================================================================
// COMPONENTES UI REUTILIZ√ÅVEIS
// =============================================================================

/**
 * Constr√≥i grupo de formul√°rio
 */
function buildFormGroup(label, content) {
    return `<div class="form-group"><label>${label}</label>${content}</div>`;
}

/**
 * Constr√≥i elemento select
 */
function buildSelect(options, machineId, className, onchangeHandler, disabled = false, selectedValue = '') {
    const disabledAttr = disabled ? 'disabled' : '';
    const optionsHTML = options.map(opt =>
        `<option value="${opt}" ${opt === selectedValue ? 'selected' : ''}>${opt}</option>`
    ).join('');

    return `
    <select class="form-input ${className}" data-machine-id="${machineId}" 
            onchange="${onchangeHandler}" ${disabledAttr}>
      <option value="">Selecionar</option>${optionsHTML}
    </select>`;
}

/**
 * Constr√≥i op√ß√µes da m√°quina
 */
function buildOptionsHTML(options, machineId, selectedOptions = [], selectedPower = null) {
    if (!options?.length) return '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel</p>';

    return options.map(option => {
        const isChecked = selectedOptions.some(selected => selected.id === option.id);
        const optionValue = selectedPower && option.values?.[selectedPower] || 0;
        const displayValue = `+R$ ${optionValue.toLocaleString("pt-BR")}`;

        return `
        <div class="option-item ${isChecked ? 'option-selected' : ''}" onclick="toggleOption('${machineId}', ${option.id})">
          <div class="option-checkbox">
            <input type="checkbox" value="${optionValue}" data-option-id="${option.id}" 
                   data-option-name="${option.name}" id="option-${machineId}-${option.id}"
                   onchange="updateOptionSelection('${machineId}', ${option.id}); calculateMachinePrice('${machineId}')"
                   ${isChecked ? 'checked' : ''}>
            <div class="option-content">
              <div class="option-name">${option.name}</div>
              <div class="option-price">${displayValue}</div>
            </div>
          </div>
        </div>`;
    }).join('');
}

// =============================================================================
// GERENCIAMENTO DE M√ÅQUINAS
// =============================================================================

/**
 * Adiciona nova m√°quina
 */
async function addMachine(roomId) {
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return;

    const machineCount = container.querySelectorAll(".climatization-machine").length;
    const machineId = generateMachineId(roomId);

    try {
        const machinesData = await loadMachinesData();
        if (!machinesData.machines.length) throw new Error("Nenhum dado dispon√≠vel");

        const machineHTML = buildMachineHTML(machineId, machineCount + 1, machinesData.machines, roomId);
        container.insertAdjacentHTML("beforeend", machineHTML);

        // Remove mensagem de vazio
        const emptyMsg = container.querySelector('.empty-message');
        if (emptyMsg) emptyMsg.remove();

        updateAllMachinesTotal(roomId);
        console.log(`‚úÖ M√°quina ${machineCount+1} adicionada √† sala ${roomId}`);
        return true; 
    } catch (error) {
        console.error("‚ùå Erro ao adicionar m√°quina:", error);
        showEmptyMessage(container, "Erro ao carregar dados");
    }
}

/**
 * Carrega m√°quinas salvas
 */
async function loadSavedMachines(roomId, savedMachines) {
    if (!savedMachines?.length || !roomId) return;

    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return;

    try {
        const machinesData = await loadMachinesData();

        savedMachines.forEach((savedMachine, index) => {
            const machineId = generateMachineId(roomId);
            const machineHTML = buildMachineFromSavedData(machineId, savedMachine, machinesData.machines);
            container.insertAdjacentHTML("beforeend", machineHTML);
        });

        // Atualiza valores ap√≥s carregamento
        setTimeout(() => {
            container.querySelectorAll('.climatization-machine').forEach((element, index) => {
                const machineId = element.dataset.machineId;
                const savedMachine = savedMachines[index];
                if (savedMachine?.potencia) {
                    updateOptionValues(machineId);
                    calculateMachinePrice(machineId);
                }
            });
            updateAllMachinesTotal(roomId);
        }, 200);

    } catch (error) {
        console.error("‚ùå Erro ao carregar m√°quinas salvas:", error);
    }
}

// =============================================================================
// ATUALIZA√á√ÉO DE UI
// =============================================================================

/**
 * Atualiza op√ß√µes da m√°quina
 */
async function updateMachineOptions(selectElement) {
    const machineId = selectElement.dataset.machineId;
    const selectedType = selectElement.value;

    if (!selectedType) {
        resetMachineFields(machineId);
        return;
    }

    try {
        const machinesData = await loadMachinesData();
        const machine = machinesData.machines.find(m => m.type === selectedType);

        if (machine) {
            updateMachineUI(machineId, machine);
        } else {
            resetMachineFields(machineId);
        }
    } catch (error) {
        console.error("‚ùå Erro ao atualizar op√ß√µes:", error);
        resetMachineFields(machineId);
    }
}

/**
 * Atualiza UI completa da m√°quina
 */
function updateMachineUI(machineId, machine) {
    const potencies = Object.keys(machine.baseValues || {});
    const voltages = (machine.voltages || []).map(v => v.name);

    updateSelectUI(`.machine-power-select[data-machine-id="${machineId}"]`, potencies, false);
    updateSelectUI(`.machine-voltage-select[data-machine-id="${machineId}"]`, voltages, false);

    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.innerHTML = machine.options?.length
            ? buildOptionsHTML(machine.options, machineId)
            : '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel</p>';
    }

    updateElementText(`base-price-${machineId}`, 'R$ 0,00');
    updateElementText(`total-price-${machineId}`, 'R$ 0,00');
}

/**
 * Atualiza select na UI
 */
function updateSelectUI(selector, options, disabled = false) {
    const select = document.querySelector(selector);
    if (select) {
        select.innerHTML = `<option value="">Selecionar</option>${options.map(opt => `<option value="${opt}">${opt}</option>`).join('')
            }`;
        select.disabled = disabled;
    }
}

/**
 * Reseta campos da m√°quina
 */
function resetMachineFields(machineId) {
    updateSelectUI(`.machine-power-select[data-machine-id="${machineId}"]`, [], true);
    updateSelectUI(`.machine-voltage-select[data-machine-id="${machineId}"]`, [], true);

    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.innerHTML = '<p class="empty-options-message">Selecione um tipo de m√°quina</p>';
    }

    updateElementText(`base-price-${machineId}`, 'R$ 0,00');
    updateElementText(`total-price-${machineId}`, 'R$ 0,00');
}

// =============================================================================
// C√ÅLCULOS DE PRE√áO
// =============================================================================

/**
 * Calcula pre√ßo da m√°quina
 */
function calculateMachinePrice(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');
    const voltageSelect = machineElement.querySelector('.machine-voltage-select');

    const selectedType = typeSelect?.value;
    const selectedPower = powerSelect?.value;
    const selectedVoltage = voltageSelect?.value;

    let basePrice = 0, voltageValue = 0;

    // Pre√ßo base
    if (selectedType && selectedPower && window.machinesData) {
        const machine = window.machinesData.find(m => m.type === selectedType);
        basePrice = machine?.baseValues?.[selectedPower] || 0;
    }

    // Valor da tens√£o
    if (selectedType && selectedVoltage && window.machinesData) {
        const machine = window.machinesData.find(m => m.type === selectedType);
        const voltageObj = machine?.voltages?.find(v => v.name === selectedVoltage);
        voltageValue = voltageObj?.value || 0;
    }

    // Total das op√ß√µes
    let optionsTotal = 0;
    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.querySelectorAll('input[type="checkbox"]:checked').forEach(option => {
            optionsTotal += safeNumber(option.value);
        });
    }

    const totalPrice = basePrice + optionsTotal + voltageValue;

    updateElementText(`base-price-${machineId}`, `R$ ${basePrice.toLocaleString("pt-BR")}`);
    updateElementText(`total-price-${machineId}`, `R$ ${totalPrice.toLocaleString("pt-BR")}`);

    // Atualiza total geral
    const roomId = machineElement.dataset.roomId;
    if (roomId) updateAllMachinesTotal(roomId);
}

/**
 * Atualiza valores das op√ß√µes
 */
function updateOptionValues(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');

    const selectedType = typeSelect?.value;
    const selectedPower = powerSelect?.value;

    if (!selectedType || !selectedPower || !window.machinesData) return;

    const machine = window.machinesData.find(m => m.type === selectedType);
    if (!machine?.options) return;

    machine.options.forEach(option => {
        const checkbox = document.getElementById(`option-${machineId}-${option.id}`);
        if (checkbox) {
            const optionValue = selectedPower && option.values?.[selectedPower] || 0;
            checkbox.value = optionValue;

            const priceDisplay = checkbox.closest('.option-item')?.querySelector('.option-price');
            if (priceDisplay) {
                priceDisplay.textContent = `+R$ ${optionValue.toLocaleString("pt-BR")}`;
            }
        }
    });

    calculateMachinePrice(machineId);
}

// =============================================================================
// GERENCIAMENTO DE TOTAL GERAL
// =============================================================================

/**
 * Calcula total de todas as m√°quinas
 */
function calculateAllMachinesTotal(roomId) {
    const container = document.getElementById(`machines-${roomId}`);
    if (!container) return 0;

    let total = 0;
    container.querySelectorAll('.climatization-machine').forEach(machineElement => {
        const machineId = machineElement.dataset.machineId;
        const priceElement = document.getElementById(`total-price-${machineId}`);
        if (priceElement) {
            const priceText = priceElement.textContent;
            const cleanText = priceText.replace('R$', '').replace(/\./g, '').replace(',', '.').trim();
            total += safeNumber(cleanText);
        }
    });

    return total;
}

/**
 * Atualiza display do total geral
 */
function updateAllMachinesTotal(roomId) {
    const total = calculateAllMachinesTotal(roomId);
    const display = document.getElementById(`total-all-machines-price-${roomId}`);
    if (display) {
        display.textContent = `R$ ${total.toLocaleString('pt-BR')}`;
    }
    saveTotalToRoom(roomId, total);
}

/**
 * Salva total no servidor
 */
function saveTotalToRoom(roomId, total) {
    fetch('/obras')
        .then(response => response.ok ? response.json() : [])
        .then(obras => {
            for (const obra of obras) {
                for (const projeto of obra.projetos || []) {
                    for (const sala of projeto.salas || []) {
                        if (sala.id === roomId) {
                            sala.somavaloresmaquinatotal = total;
                            return fetch(`/obras/${obra.id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(obra)
                            });
                        }
                    }
                }
            }
        })
        .catch(error => console.error('‚ùå Erro ao salvar total:', error));
}

// =============================================================================
// FUN√á√ïES DE INTERA√á√ÉO DO USU√ÅRIO
// =============================================================================

function toggleMachineSection(button) {
    const content = button.closest(".climatization-machine").querySelector(".machine-content");
    const isCollapsed = content.classList.toggle("collapsed");
    button.textContent = isCollapsed ? "+" : "‚àí";
}

function updateMachineTitle(input, machineId) {
    if (!input.value.trim()) input.value = `Maquina${machineId}`;
}

function toggleOption(machineId, optionId) {
    const checkbox = document.getElementById(`option-${machineId}-${optionId}`);
    if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
    }
}

function updateOptionSelection(machineId, optionId) {
    const checkbox = document.getElementById(`option-${machineId}-${optionId}`);
    const item = checkbox?.closest('.option-item');
    if (item) {
        item.classList.toggle('option-selected', checkbox.checked);
    }
}

function handlePowerChange(machineId) {
    calculateMachinePrice(machineId);
    updateOptionValues(machineId);
}

function deleteMachine(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) return;

    const roomId = machineElement.dataset.roomId;
    const container = machineElement.closest(".machines-container");

    machineElement.remove();

    if (roomId) updateAllMachinesTotal(roomId);

    // Mostra mensagem se n√£o houver m√°quinas
    if (container && container.querySelectorAll('.climatization-machine').length === 0) {
        showEmptyMessage(container, "Nenhuma m√°quina adicionada ainda.");
    }
}

// =============================================================================
// FUN√á√ïES AUXILIARES
// =============================================================================

function showEmptyMessage(container, message) {
    const existing = container.querySelector('.empty-message');
    if (existing) existing.remove();
    container.insertAdjacentHTML('beforeend', `<p class="empty-message">${message}</p>`);
}

function removeEmptyMessage(container) {
    const emptyMsg = container.querySelector('.empty-message');
    if (emptyMsg) emptyMsg.remove();
}

// =============================================================================
// EXPORTA√á√ïES E GLOBAIS
// =============================================================================

export {
    buildMachinesSection,
    loadMachinesData,
    loadSavedMachines,
    addMachine,
    buildMachineHTML,
    toggleMachineSection,
    updateMachineTitle,
    updateMachineOptions,
    calculateMachinePrice,
    deleteMachine,
    toggleOption,
    updateOptionSelection,
    updateOptionValues,
    handlePowerChange,
    calculateAllMachinesTotal,
    updateAllMachinesTotal,
    generateMachineId
};

// Disponibiliza√ß√£o global
if (typeof window !== 'undefined') {
    const functions = {
        addMachine, toggleMachineSection, updateMachineTitle, updateMachineOptions,
        calculateMachinePrice, deleteMachine, deleteClimatizationMachine: deleteMachine,
        handleOptionClick: toggleOption, updateOptionSelection, updateOptionValues,
        handlePowerChange, calculateTotalAllMachinesPrice: calculateAllMachinesTotal,
        updateAllMachinesTotalDisplay: updateAllMachinesTotal, loadSavedMachines,
        generateMachineId
    };

    Object.assign(window, functions);
}
/* ==== FIM: data/modules/machines/machines-core.js ==== */

/* ==== IN√çCIO: data/builders/data-builders-folder/machines-data-extractors.js ==== */
import { getMachineName, parseMachinePrice } from '../../utils/data-utils.js';

/**
 * Extrai dados das m√°quinas de climatiza√ß√£o de uma sala
 */
function extractMachinesData(roomElement) {
    const machines = [];
    
    if (!roomElement?.dataset.roomId) {
        console.error('‚ùå Elemento da sala inv√°lido para extra√ß√£o de m√°quinas');
        return machines;
    }
    
    const machineElements = roomElement.querySelectorAll('.climatization-machine');
    
    machineElements.forEach(machineElement => {
        const machineData = extractClimatizationMachineData(machineElement);
        if (machineData) {
            machines.push(machineData);
        }
    });
    
    console.log(`ü§ñ ${machines.length} m√°quina(s) extra√≠da(s) da sala ${roomElement.dataset.roomId}`);
    return machines;
}

/**
 * Extrai dados de uma m√°quina de climatiza√ß√£o individual
 */
function extractClimatizationMachineData(machineElement) {
    if (!machineElement) {
        console.error('‚ùå Elemento da m√°quina √© nulo');
        return null;
    }

    const machineId = machineElement.getAttribute('data-machine-id') || `machine-${Date.now()}`;
    const roomId = machineElement.getAttribute('data-room-id');

    console.log(`üîß Extraindo dados da m√°quina ${machineId} na sala ${roomId}`);

    const machineData = {
        nome: getMachineName(machineElement, machineId),
        tipo: machineElement.querySelector('.machine-type-select')?.value || '',
        potencia: machineElement.querySelector('.machine-power-select')?.value || '',
        tensao: machineElement.querySelector('.machine-voltage-select')?.value || '',
        precoBase: 0,
        opcoesSelecionadas: [],
        precoTotal: 0,
        potenciaSelecionada: machineElement.querySelector('.machine-power-select')?.value || '',
        tipoSelecionado: machineElement.querySelector('.machine-type-select')?.value || ''
    };

    try {
        // Pre√ßo base
        const basePriceElement = document.getElementById(`base-price-${machineId}`);
        if (basePriceElement) {
            machineData.precoBase = parseMachinePrice(basePriceElement.textContent);
        }

        // Op√ß√µes selecionadas
        const selectedOptions = [];
        const optionCheckboxes = machineElement.querySelectorAll('input[type="checkbox"]:checked');
        
        optionCheckboxes.forEach((checkbox, index) => {
            const optionId = checkbox.getAttribute('data-option-id') || (index + 1).toString();
            const optionValue = parseFloat(checkbox.value) || 0;
            const optionName = checkbox.getAttribute('data-option-name') || `Op√ß√£o ${optionId}`;
            
            selectedOptions.push({
                id: parseInt(optionId) || (index + 1),
                name: optionName.replace(/\s*R\$\s*[\d.,]+/, '').trim(),
                value: optionValue,
                originalName: optionName,
                potenciaAplicada: machineData.potencia
            });
        });

        machineData.opcoesSelecionadas = selectedOptions;

        // Pre√ßo total
        const totalPriceElement = document.getElementById(`total-price-${machineId}`);
        if (totalPriceElement) {
            machineData.precoTotal = parseMachinePrice(totalPriceElement.textContent);
        } else {
            machineData.precoTotal = machineData.precoBase + 
                selectedOptions.reduce((sum, option) => sum + option.value, 0);
        }

        console.log(`‚úÖ M√°quina ${machineId} extra√≠da:`, {
            nome: machineData.nome,
            tipo: machineData.tipo,
            potencia: machineData.potencia,
            precoBase: machineData.precoBase,
            opcoes: machineData.opcoesSelecionadas.length,
            precoTotal: machineData.precoTotal
        });

        return machineData;

    } catch (error) {
        console.error(`‚ùå Erro ao extrair dados da m√°quina ${machineId}:`, error);
        return machineData;
    }
}

// EXPORTS NO FINAL
export {
    extractMachinesData,
    extractClimatizationMachineData
};
/* ==== FIM: data/builders/data-builders-folder/machines-data-extractors.js ==== */

/* ==== IN√çCIO: data/modules/rooms.js ==== */
/**
 * data/modules/rooms.js
 * üéØ FUS√ÉO COMPLETA: room-operations.js + salas.js
 * ‚ö° REDU√á√ÉO: 2 arquivos ‚Üí 1 arquivo (~350 ‚Üí ~250 linhas)
 */

import { buildClimatizationSection } from './climatizacao.js';
import { buildMachinesSection } from './machines/machines-core.js';
import { buildConfigurationSection } from './configuracao.js';
import { generateRoomId } from '../utils/id-generator.js';
import { removeEmptyProjectMessage, showEmptyProjectMessageIfNeeded } from '../../ui/helpers.js';
import { triggerCalculation, syncTitleToAmbienteDirect } from '../../core/shared-utils.js';

// Cache para m√≥dulo de m√°quinas
let machinesPreloadModule = null;

/**
 * üèóÔ∏è FUN√á√ïES DE CONSTRU√á√ÉO DE HTML (salas.js)
 */

/**
 * Constr√≥i o HTML completo de uma sala com todas as se√ß√µes
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML completo da sala
 */
function buildRoomHTML(obraId, projectId, roomName, roomId) {
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Obra ID inv√°lido: ${obraId}]`);
        return '';
    }
    
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Project ID inv√°lido: ${projectId}]`);
        return '';
    }
    
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Room ID inv√°lido: ${roomId}]`);
        return '';
    }
    
    console.log(`[BUILD ROOM] Par√¢metros:`, { obraId, projectId, roomName, roomId });
    console.log(`[BUILD ROOM] ID √öNICO: ${roomId}`);
    
    return `
      <div class="room-block" data-room-id="${roomId}" data-room-name="${roomName}" data-project-id="${projectId}" data-obra-id="${obraId}">
        <div class="room-header">
          <button class="minimizer" onclick="toggleRoom('${roomId}', event)">+</button>
          <h4 class="room-title editable-title" data-editable="true" onclick="makeEditable(this, 'room')">${roomName}</h4>
          <div class="room-actions">
            <button class="btn btn-delete" onclick="deleteRoom('${obraId}', '${projectId}', '${roomId}')">Remover</button>
          </div>
        </div>
        <div class="room-content collapsed" id="room-content-${roomId}">
          ${buildClimatizationSection(obraId, projectId, roomName, roomId)}
          ${buildMachinesSection(obraId, projectId, roomName, roomId)}
          ${buildConfigurationSection(obraId, projectId, roomName, roomId)}
        </div>
      </div>
    `;
}

/**
 * Constr√≥i apenas o cabe√ßalho da sala com t√≠tulo e a√ß√µes
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML do cabe√ßalho da sala
 */
function buildRoomHeader(obraId, projectId, roomName, roomId) {
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHeader) [Room ID inv√°lido: ${roomId}]`);
        return '';
    }
    
    return `
    <div class="room-header">
      <button class="minimizer" onclick="toggleRoom('${roomId}', event)">+</button>
      <h3 class="room-title editable-title" data-editable="true" onclick="makeEditable(this, 'room')">${roomName}</h3>
      <button class="btn btn-delete-small" onclick="deleteRoom('${obraId}', '${projectId}', '${roomId}')">Remover</button>
    </div>
  `;
}

/**
 * Constr√≥i a se√ß√£o de a√ß√µes da sala (reservado para futuras implementa√ß√µes)
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML vazio
 */
function buildRoomActions(roomId) {
    return "";
}

/**
 * üîß FUN√á√ïES DE OPERA√á√ïES (room-operations.js)
 */

/**
 * Carrega o m√≥dulo de m√°quinas para pr√©-carregamento ass√≠ncrono
 * @returns {Promise<Object|null>} M√≥dulo de m√°quinas carregado
 */
async function loadMachinesPreloadModule() {
    if (!machinesPreloadModule) {
        try {
            machinesPreloadModule = await import('./machines/machines-core.js');
            console.log("‚úÖ M√≥dulo de m√°quinas carregado para pr√©-carregamento");
        } catch (error) {
            console.error("‚ùå Erro ao carregar m√≥dulo de m√°quinas:", error);
        }
    }
    return machinesPreloadModule;
}

/**
 * Cria uma nova sala vazia no projeto especificado
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto  
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala (opcional)
 * @returns {Promise<boolean>} True se a sala foi criada com sucesso
 */
async function createEmptyRoom(obraId, projectId, roomName, roomId) {
    console.log(`üîÑ Criando sala: ${roomName} na obra "${obraId}", projeto "${projectId}"`);
    
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (createEmptyRoom) [Obra ID inv√°lido: ${obraId}]`);
        return false;
    }
    
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (createEmptyRoom) [Project ID inv√°lido: ${projectId}]`);
        return false;
    }
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        
        console.log('üîç Projetos dispon√≠veis no DOM:');
        document.querySelectorAll('.project-block').forEach(proj => {
            console.log(`  - Projeto: ${proj.dataset.projectName}, 
                         ProjectID: ${proj.dataset.projectId}, 
                         ObraID: ${proj.dataset.obraId}, 
                         ObraName: ${proj.dataset.obraName}`);
        });
        return false;
    }
    
    console.log(`‚úÖ Projeto encontrado:`, projectElement.dataset);

    let finalRoomId;
    
    if (roomId && roomId !== 'undefined' && roomId !== 'null' && !roomId.includes('undefined')) {
        finalRoomId = roomId;
    } else {
        const roomCount = getRoomCountInProject(obraId, projectId);
        finalRoomId = generateRoomId(projectElement, roomCount + 1);
    }
    
    finalRoomId = finalRoomId.toString()
        .replace(/-undefined/g, '')
        .replace(/-null/g, '')
        .trim();
    
    console.log(`üìù ID SEGURO DEFINITIVO DA SALA: "${finalRoomId}"`);
    
    try {
        const machinesModule = await loadMachinesPreloadModule();
        if (machinesModule && machinesModule.preloadMachinesDataForRoom) {
            await machinesModule.preloadMachinesDataForRoom(finalRoomId);
        }
    } catch (error) {
        console.error("‚ö†Ô∏è Aviso: N√£o foi poss√≠vel pr√©-carregar dados das m√°quinas:", error);
    }

    const roomHTML = buildRoomHTML(obraId, projectId, roomName, finalRoomId);
    
    const projectContent = projectElement.querySelector('.project-content');
    
    if (!projectContent) {
        console.error(`‚ùå Conte√∫do do projeto n√£o encontrado em ${projectId}`);
        return false;
    }

    removeEmptyProjectMessage(projectContent);
    
    const addRoomSection = projectContent.querySelector('.add-room-section');
    if (addRoomSection) {
        addRoomSection.insertAdjacentHTML('beforebegin', roomHTML);
    } else {
        projectContent.insertAdjacentHTML('beforeend', roomHTML);
    }

    console.log(`‚úÖ Sala ${roomName} criada (ID: ${finalRoomId}) na obra "${obraId}", projeto "${projectId}"`);
    
    initializeRoomComponents(obraId, projectId, roomName, finalRoomId);
    
    return true;
}

/**
 * Conta quantas salas j√° existem no projeto espec√≠fico
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {number} Quantidade de salas no projeto
 */
function getRoomCountInProject(obraId, projectId) {
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    if (!projectElement) return 0;
    
    const rooms = projectElement.querySelectorAll('.room-block');
    return rooms.length;
}

/**
 * Inicializa todos os componentes da sala ap√≥s cria√ß√£o
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */

function initializeRoomComponents(obraId, projectId, roomName, roomId) {
    console.log(`üîß INICIALIZA√á√ÉO COMPLETA DA SALA: ${roomName} (ID: ${roomId})`);
    
    // ‚úÖ CONFIGURA√á√ÉO COM TIMING CORRETO
    setTimeout(() => {
        console.log(`üéØ CONFIGURANDO TODAS AS SINCRONIZA√á√ïES PARA: ${roomId}`);
        
        // 1. SINCRONIZA√á√ÉO T√çTULO ‚Üî AMBIENTE (BIDIRECIONAL)
        setupBidirectionalTitleAmbienteSync(roomId, roomName);
        
        // 2. SINCRONIZA√á√ÉO PAREDES (APENAS PRIMEIRA INTERA√á√ÉO)
        setupFirstInteractionWallSync(roomId);
        
        // 3. SINCRONIZA√á√ÉO INICIAL DOS VALORES
        initializeDefaultValues(roomId, roomName);
        
        console.log(`‚úÖ TODAS AS SINCRONIZA√á√ïES CONFIGURADAS PARA: ${roomId}`);
        
    }, 1000);
    
    // Outras inicializa√ß√µes...
    setTimeout(async () => {
        try {
            const machinesModule = await import('./machines/machines-core.js');
            if (machinesModule.preloadMachinesDataForRoom) {
                await machinesModule.preloadMachinesDataForRoom(roomId);
                console.log(`‚úÖ Dados das m√°quinas pr√©-carregados para ${roomId}`);
            }
        } catch (error) {
            console.log(`‚ÑπÔ∏è N√£o foi poss√≠vel pr√©-carregar dados das m√°quinas para ${roomId}`);
        }
    }, 800);
    
    // ‚úÖ INICIALIZA√á√ÉO DE FATOR DE SEGURAN√áA
    setTimeout(() => {
        safeInitializeFatorSeguranca(roomId);
    }, 1200);
    
    // ‚úÖ VERIFICA√á√ÉO FINAL
    setTimeout(() => {
        console.log(`üîç VERIFICA√á√ÉO FINAL DA SALA: ${roomName} (ID: ${roomId})`);
        verifyRoomSetupComplete(roomId);
    }, 2000);
}

// ‚úÖ FUN√á√ÉO PARA SINCRONIZA√á√ÉO BIDIRECIONAL T√çTULO ‚Üî AMBIENTE
function setupBidirectionalTitleAmbienteSync(roomId, roomName) {
    console.log(`üîß CONFIGURANDO SINCRONIZA√á√ÉO BIDIRECIONAL T√çTULO‚ÜîAMBIENTE: ${roomId}`);
    
    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomBlock) {
        console.error(`‚ùå Room block n√£o encontrado: ${roomId}`);
        return;
    }
    
    const roomTitle = roomBlock.querySelector('.room-title');
    const ambienteInput = findAmbienteInput(roomId);
    
    if (roomTitle && ambienteInput) {
        console.log(`‚úÖ Elementos encontrados para sincroniza√ß√£o bidirecional`);
        
        // ‚úÖ SINCRONIZA√á√ÉO INICIAL: T√≠tulo ‚Üí Ambiente
        if (!ambienteInput.value || ambienteInput.value.trim() === '' || ambienteInput.value === 'Sala1') {
            ambienteInput.value = roomTitle.textContent || roomName;
            console.log(`‚úÖ Sincroniza√ß√£o inicial: T√≠tulo ‚Üí Ambiente: "${ambienteInput.value}"`);
        }
        
        // ‚úÖ SINCRONIZA√á√ÉO CONT√çNUA: Ambiente ‚Üí T√≠tulo
        ambienteInput.addEventListener('input', function() {
            if (this.value && this.value.trim() !== '' && this.value !== roomTitle.textContent) {
                roomTitle.textContent = this.value;
                roomBlock.dataset.roomName = this.value;
                console.log(`üîÑ Ambiente ‚Üí T√≠tulo: "${this.value}"`);
                triggerCalculation(roomId);
            }
        });
        
        // ‚úÖ SINCRONIZA√á√ÉO CONT√çNUA: T√≠tulo ‚Üí Ambiente (via Observer para edi√ß√£o inline)
        setupTitleChangeObserver(roomTitle, roomId);
        
        console.log(`‚úÖ Sincroniza√ß√£o bidirecional T√≠tulo‚ÜîAmbiente configurada`);
        
    } else {
        console.error(`‚ùå Elementos n√£o encontrados para sincroniza√ß√£o:`, {
            roomTitle: !!roomTitle,
            ambienteInput: !!ambienteInput
        });
    }
}

// ‚úÖ FUN√á√ÉO PARA OBSERVAR MUDAN√áAS NO T√çTULO (edi√ß√£o inline)
function setupTitleChangeObserver(roomTitle, roomId) {
    let isEditing = false;
    
    // Observar quando entra em modo de edi√ß√£o
    roomTitle.addEventListener('click', function() {
        isEditing = true;
        console.log(`‚úèÔ∏è T√≠tulo em modo de edi√ß√£o: ${roomId}`);
    });
    
    // Observar mudan√ßas no conte√∫do do t√≠tulo
    const observer = new MutationObserver((mutations) => {
        if (!isEditing) return;
        
        mutations.forEach((mutation) => {
            if (mutation.type === 'characterData' || mutation.type === 'childList') {
                const newTitle = roomTitle.textContent.trim();
                if (newTitle && newTitle !== mutation.oldValue) {
                    console.log(`üéØ T√≠tulo alterado via edi√ß√£o inline: "${mutation.oldValue}" ‚Üí "${newTitle}"`);
                    syncTitleToAmbienteDirect(roomId, newTitle);
                }
            }
        });
    });
    
    // Observar quando sai do modo de edi√ß√£o (blur)
    roomTitle.addEventListener('blur', function() {
        isEditing = false;
        const newTitle = roomTitle.textContent.trim();
        if (newTitle) {
            console.log(`üíæ Edi√ß√£o conclu√≠da: "${newTitle}"`);
            syncTitleToAmbienteDirect(roomId, newTitle);
        }
    });
    
    observer.observe(roomTitle, {
        characterData: true,
        childList: true,
        subtree: true,
        characterDataOldValue: true
    });
    
    console.log(`‚úÖ Observer configurado para t√≠tulo da sala ${roomId}`);
}

// ‚úÖ FUN√á√ÉO PARA SINCRONIZA√á√ÉO DE PAREDES (APENAS PRIMEIRA INTERA√á√ÉO)
function setupFirstInteractionWallSync(roomId) {
    console.log(`üß± CONFIGURANDO SINCRONIZA√á√ÉO PAREDES (PRIMEIRA INTERA√á√ÉO): ${roomId}`);
    
    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomBlock) {
        console.error(`‚ùå Room block n√£o encontrado: ${roomId}`);
        return;
    }
    
    // Buscar inputs de parede
    const paredeOeste = roomBlock.querySelector('input[data-field="paredeOeste"]');
    const paredeLeste = roomBlock.querySelector('input[data-field="paredeLeste"]');
    const paredeNorte = roomBlock.querySelector('input[data-field="paredeNorte"]');
    const paredeSul = roomBlock.querySelector('input[data-field="paredeSul"]');
    
    console.log(`üìä Elementos de parede encontrados:`, {
        paredeOeste: !!paredeOeste,
        paredeLeste: !!paredeLeste,
        paredeNorte: !!paredeNorte,
        paredeSul: !!paredeSul
    });
    
    // ‚úÖ SINCRONIZA√á√ÉO LESTE/OESTE (apenas primeira intera√ß√£o)
    if (paredeOeste && paredeLeste) {
        setupFirstInteractionWallPair(paredeOeste, paredeLeste, roomId, 'Oeste', 'Leste');
    } else {
        console.warn(`‚ö†Ô∏è Par Leste/Oeste incompleto para ${roomId}`);
    }
    
    // ‚úÖ SINCRONIZA√á√ÉO NORTE/SUL (apenas primeira intera√ß√£o)
    if (paredeNorte && paredeSul) {
        setupFirstInteractionWallPair(paredeNorte, paredeSul, roomId, 'Norte', 'Sul');
    } else {
        console.warn(`‚ö†Ô∏è Par Norte/Sul incompleto para ${roomId}`);
    }
}

// ‚úÖ FUN√á√ÉO PARA SINCRONIZA√á√ÉO DE PAR DE PAREDES (APENAS PRIMEIRA INTERA√á√ÉO)
function setupFirstInteractionWallPair(input1, input2, roomId, name1, name2) {
    console.log(`üîß Configurando par ${name1}/${name2} (primeira intera√ß√£o) para ${roomId}`);
    
    let firstInteraction1 = true;
    let firstInteraction2 = true;
    
    const placeholderValues = ['Ex: 5.5', 'Ex: 8.0', ''];
    
    // Input 1 ‚Üí Input 2 (apenas primeira intera√ß√£o)
    input1.addEventListener('input', function() {
        if (firstInteraction1 && this.value && !placeholderValues.includes(this.value)) {
            const shouldSync = !input2.value || placeholderValues.includes(input2.value);
            if (shouldSync && input2.value !== this.value) {
                input2.value = this.value;
                console.log(`üîÑ Primeira intera√ß√£o: ${name1} ‚Üí ${name2}: ${this.value}`);
                triggerCalculation(roomId);
            }
            firstInteraction1 = false;
        }
    });
    
    // Input 2 ‚Üí Input 1 (apenas primeira intera√ß√£o)
    input2.addEventListener('input', function() {
        if (firstInteraction2 && this.value && !placeholderValues.includes(this.value)) {
            const shouldSync = !input1.value || placeholderValues.includes(input1.value);
            if (shouldSync && input1.value !== this.value) {
                input1.value = this.value;
                console.log(`üîÑ Primeira intera√ß√£o: ${name2} ‚Üí ${name1}: ${this.value}`);
                triggerCalculation(roomId);
            }
            firstInteraction2 = false;
        }
    });
    
    console.log(`‚úÖ Sincroniza√ß√£o ${name1}/${name2} (primeira intera√ß√£o) configurada`);
}

// ‚úÖ FUN√á√ÉO PARA INICIALIZA√á√ÉO DOS VALORES PADR√ÉO
function initializeDefaultValues(roomId, roomName) {
    console.log(`‚ö° INICIALIZANDO VALORES PADR√ÉO PARA: ${roomId}`);
    
    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomBlock) return;
    
    // Verificar e sincronizar valores iniciais das paredes
    const walls = [
        { field: 'paredeOeste', selector: 'input[data-field="paredeOeste"]' },
        { field: 'paredeLeste', selector: 'input[data-field="paredeLeste"]' },
        { field: 'paredeNorte', selector: 'input[data-field="paredeNorte"]' },
        { field: 'paredeSul', selector: 'input[data-field="paredeSul"]' }
    ];
    
    walls.forEach(wall => {
        const input = roomBlock.querySelector(wall.selector);
        if (input && input.value && input.value !== 'Ex: 5.5' && input.value !== 'Ex: 8.0') {
            syncOppositeWallInitial(roomId, wall.field, input.value);
        }
    });
}

// ‚úÖ FUN√á√ÉO AUXILIAR PARA SINCRONIZA√á√ÉO INICIAL DAS PAREDES
function syncOppositeWallInitial(roomId, field, value) {
    const oppositeMap = {
        'paredeOeste': 'paredeLeste',
        'paredeLeste': 'paredeOeste', 
        'paredeNorte': 'paredeSul',
        'paredeSul': 'paredeNorte'
    };
    
    const oppositeField = oppositeMap[field];
    if (oppositeField) {
        const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
        if (roomBlock) {
            const oppositeInput = roomBlock.querySelector(`input[data-field="${oppositeField}"]`);
            if (oppositeInput && (!oppositeInput.value || oppositeInput.value === 'Ex: 5.5' || oppositeInput.value === 'Ex: 8.0')) {
                oppositeInput.value = value;
                console.log(`‚úÖ Sincroniza√ß√£o inicial ${field} ‚Üí ${oppositeField}: ${value}`);
            }
        }
    }
}

// ‚úÖ FUN√á√ÉO AUXILIAR PARA BUSCAR INPUT AMBIENTE
function findAmbienteInput(roomId) {
    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomBlock) return null;
    
    // Estrat√©gias de busca em ordem de prioridade
    return roomBlock.querySelector('input[data-field="ambiente"]') ||
           roomBlock.querySelector('input[placeholder*="ambiente" i]') ||
           roomBlock.querySelector('input[placeholder*="sala" i]');
}





// ‚úÖ FUN√á√ÉO PARA VERIFICA√á√ÉO COMPLETA DO SETUP
function verifyRoomSetupComplete(roomId) {
    console.log(`üîç VERIFICA√á√ÉO COMPLETA DA SALA: ${roomId}`);
    
    const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
    if (!roomBlock) {
        console.error(`‚ùå Room block n√£o encontrado: ${roomId}`);
        return false;
    }
    
    const elements = {
        'T√≠tulo': roomBlock.querySelector('.room-title'),
        'Ambiente': findAmbienteInput(roomId),
        'Parede Oeste': roomBlock.querySelector('input[data-field="paredeOeste"]'),
        'Parede Leste': roomBlock.querySelector('input[data-field="paredeLeste"]'),
        'Parede Norte': roomBlock.querySelector('input[data-field="paredeNorte"]'),
        'Parede Sul': roomBlock.querySelector('input[data-field="paredeSul"]')
    };
    
    let allFound = true;
    let foundCount = 0;
    
    Object.entries(elements).forEach(([name, element]) => {
        const found = !!element;
        if (!found) allFound = false;
        if (found) foundCount++;
        console.log(`üìä ${name}: ${found ? '‚úÖ Encontrado' : '‚ùå N√£o encontrado'}`);
    });
    
    if (allFound) {
        console.log(`üéâ TODOS OS ${foundCount} ELEMENTOS ENCONTRADOS PARA: ${roomId}`);
    } else {
        console.warn(`‚ö†Ô∏è ${foundCount}/6 ELEMENTOS ENCONTRADOS PARA: ${roomId}`);
    }
    
    return allFound;
}

// ‚úÖ ADICIONAR FUN√á√ÉO GLOBAL PARA DEBUG
if (typeof window !== 'undefined') {
    window.debugRoomSync = function(roomId) {
        console.log(`üêõ DEBUG COMPLETO DA SALA: ${roomId}`);
        const roomBlock = document.querySelector(`[data-room-id="${roomId}"]`);
        if (roomBlock) {
            console.log('üìã Elementos encontrados:');
            console.log('- T√≠tulo:', roomBlock.querySelector('.room-title')?.textContent);
            console.log('- Ambiente:', findAmbienteInput(roomId)?.value);
            console.log('- Parede Oeste:', roomBlock.querySelector('input[data-field="paredeOeste"]')?.value);
            console.log('- Parede Leste:', roomBlock.querySelector('input[data-field="paredeLeste"]')?.value);
            console.log('- Parede Norte:', roomBlock.querySelector('input[data-field="paredeNorte"]')?.value);
            console.log('- Parede Sul:', roomBlock.querySelector('input[data-field="paredeSul"]')?.value);
            
            // Testar sincroniza√ß√£o manual
            const roomTitle = roomBlock.querySelector('.room-title');
            if (roomTitle) {
                console.log('üîÑ Testando sincroniza√ß√£o t√≠tulo ‚Üí ambiente...');
                syncTitleToAmbienteDirect(roomId, roomTitle.textContent);
            }
        }
    };
}



/**
 * Fun√ß√£o auxiliar para inicializar fator de seguran√ßa de forma segura
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function safeInitializeFatorSeguranca(roomId) {
    if (typeof window.initializeFatorSeguranca === 'function') {
        try {
            window.initializeFatorSeguranca(roomId);
            console.log(`‚úÖ Fator de seguran√ßa inicializado para ${roomId}`);
        } catch (error) {
            console.log(`‚ÑπÔ∏è Erro ao inicializar fator de seguran√ßa para ${roomId}:`, error.message);
        }
    } else {
        console.log(`‚ÑπÔ∏è initializeFatorSeguranca n√£o dispon√≠vel - aguardando carregamento`);
    }
}

/**
 * Insere o HTML de uma sala no conte√∫do do projeto
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomHTML - HTML da sala a ser inserida
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function insertRoomIntoProject(obraId, projectId, roomHTML, roomId) {
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }

    const projectContent = projectElement.querySelector('.project-content');
    if (!projectContent) {
        console.error(`‚ùå Conte√∫do do projeto ${projectId} n√£o encontrado`);
        return;
    }

    const addRoomSection = projectContent.querySelector(".add-room-section");
    if (addRoomSection) {
        addRoomSection.insertAdjacentHTML("beforebegin", roomHTML);
    } else {
        projectContent.insertAdjacentHTML("beforeend", roomHTML);
    }

    removeEmptyProjectMessage(projectContent);
    console.log(`‚úÖ Sala inserida no projeto ${projectId} (ID √∫nico: ${roomId})`);
}

/**
 * Adiciona uma nova sala ao projeto
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {Promise<void>}
 */
async function addNewRoom(obraId, projectId) {
    console.log(`‚ûï Adicionando nova sala √† obra "${obraId}", projeto "${projectId}"`);
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }
    
    const roomCount = getRoomCountInProject(obraId, projectId);
    const roomName = `Sala${roomCount + 1}`;

    await createEmptyRoom(obraId, projectId, roomName, null);
    console.log(`‚úÖ ${roomName} adicionada √† obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Adiciona uma nova sala ao projeto (alias para compatibilidade)
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {Promise<void>}
 */
async function addNewRoomToProject(obraId, projectId) {
    console.log(`‚ûï Adicionando nova sala √† obra "${obraId}", projeto "${projectId}"`);
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }
    
    const roomCount = getRoomCountInProject(obraId, projectId);
    const roomName = `Sala${roomCount + 1}`;

    await createEmptyRoom(obraId, projectId, roomName, null);
    console.log(`‚úÖ ${roomName} adicionada √† obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Fun√ß√£o de compatibilidade para c√≥digo existente que usa apenas projectName
 * @param {string} projectName - Nome do projeto
 * @returns {Promise<void>}
 */
async function addNewRoomLegacy(projectName) {
    const projectBlock = document.querySelector(`[data-project-name="${projectName}"]`);
    const obraId = projectBlock?.dataset.obraId;
    const projectId = projectBlock?.dataset.projectId;
    
    if (obraId && projectId) {
        return addNewRoomToProject(obraId, projectId);
    } else {
        console.error('‚ùå N√£o foi poss√≠vel determinar a obra do projeto:', projectName);
    }
}

/**
 * Remove uma sala do projeto ap√≥s confirma√ß√£o do usu√°rio
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomId - ID √∫nico da sala a ser removida
 * @returns {void}
 */
function deleteRoom(obraId, projectId, roomId) {
    const roomBlock = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"][data-room-id="${roomId}"]`);
    
    if (!roomBlock) {
        console.error(`‚ùå Sala com ID ${roomId} n√£o encontrada no projeto ${projectId}, obra ${obraId}`);
        return;
    }

    const roomName = roomBlock.dataset.roomName;
    const projectContent = roomBlock.closest(".project-content");

    roomBlock.remove();
    
    if (projectContent && typeof window.showEmptyProjectMessageIfNeeded === 'function') {
        window.showEmptyProjectMessageIfNeeded(projectContent);
    }

    console.log(`üóëÔ∏è Sala ${roomName} (ID: ${roomId}) removida da obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Fun√ß√£o de compatibilidade para c√≥digo existente que usa apenas projectName e roomName
 * @param {string} projectName - Nome do projeto
 * @param {string} roomName - Nome da sala
 * @returns {void}
 */
function deleteRoomLegacy(projectName, roomName) {
    const projectBlock = document.querySelector(`[data-project-name="${projectName}"]`);
    const obraId = projectBlock?.dataset.obraId;
    const projectId = projectBlock?.dataset.projectId;
    
    if (obraId && projectId) {
        const roomBlock = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"][data-room-name="${roomName}"]`);
        const roomId = roomBlock?.dataset.roomId;
        
        if (roomId) {
            return deleteRoom(obraId, projectId, roomId);
        } else {
            console.error(`‚ùå ID da sala ${roomName} n√£o encontrado`);
        }
    } else {
        console.error('‚ùå N√£o foi poss√≠vel determinar a obra do projeto:', projectName);
    }
}

/**
 * Corrige inputs de fator de seguran√ßa que estejam vazios
 * Aplica valores padr√£o baseados nas constantes do sistema
 * @returns {void}
 */
function fixExistingCapacityInputs() {
    console.log('üîÑ Verificando inputs de capacidade existentes...');
    
    const roomBlocks = document.querySelectorAll('.room-block');
    
    roomBlocks.forEach(roomBlock => {
        const roomId = roomBlock.dataset.roomId;
        const roomName = roomBlock.dataset.roomName;
        const projectBlock = roomBlock.closest('.project-block');
        const projectId = projectBlock?.dataset.projectId;
        const obraId = projectBlock?.dataset.obraId;
        
        if (roomId) {
            const input = document.getElementById(`fator-seguranca-${roomId}`);
            
            if (input && input.value === '') {
                const valor = window.systemConstants?.FATOR_SEGURANCA_CAPACIDADE || 10;
                input.value = valor;
                console.log(`‚úÖ Input ${roomId} : ${valor}% (Obra: ${obraId}, Projeto: ${projectId})`);
            }
        }
    });
}

// Executar quando o projeto for carregado
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(fixExistingCapacityInputs, 2000);
});

/**
 * üåê EXPORTA√á√ïES E COMPATIBILIDADE GLOBAL
 */

// Exporta√ß√µes para m√≥dulos ES6
export {
    // Constru√ß√£o
    buildRoomHTML,
    buildRoomHeader,
    buildRoomActions,
    
    // Opera√ß√µes
    createEmptyRoom,
    insertRoomIntoProject,
    addNewRoom,
    deleteRoom,
    deleteRoomLegacy,
    safeInitializeFatorSeguranca,
    addNewRoomToProject,
    
    // Utilit√°rios
    getRoomCountInProject,
    initializeRoomComponents,
    fixExistingCapacityInputs,
    loadMachinesPreloadModule,


    triggerCalculation,
};

// Compatibilidade global para scripts legados
if (typeof window !== 'undefined') {
    window.addNewRoom = addNewRoom;
    window.deleteRoom = deleteRoom;
    window.addNewRoomToProject = addNewRoomToProject;
    window.createEmptyRoom = createEmptyRoom;
    window.safeInitializeFatorSeguranca = safeInitializeFatorSeguranca;
    window.buildRoomHTML = buildRoomHTML;
}
/* ==== FIM: data/modules/rooms.js ==== */
