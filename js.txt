
/* ==== IN√çCIO: app.js ==== */
/**
 * core/app.js
 * Ponto √∫nico de entrada do sistema - FUS√ÉO: bootstrap.js + event-bus.js + state.js
 * Sistema de inicializa√ß√£o, eventos e estado global unificados
 */

// =============================================================================
// SISTEMA DE EVENTOS (PUB/SUB) - De event-bus.js
// =============================================================================

class EventBus {
    constructor() {
        this.listeners = {};
    }
    
    /**
     * Registra um listener para um evento
     * @param {string} event - Nome do evento
     * @param {Function} callback - Fun√ß√£o a ser executada
     */
    on(event, callback) {
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        this.listeners[event].push(callback);
    }
    
    /**
     * Remove um listener de um evento
     * @param {string} event - Nome do evento
     * @param {Function} callback - Fun√ß√£o a ser removida
     */
    off(event, callback) {
        if (this.listeners[event]) {
            this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
        }
    }
    
    /**
     * Dispara um evento para todos os listeners
     * @param {string} event - Nome do evento
     * @param {any} data - Dados a serem passados
     */
    emit(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`‚ùå Erro no listener do evento ${event}:`, error);
                }
            });
        }
    }
    
    /**
     * Remove todos os listeners de um evento
     * @param {string} event - Nome do evento
     */
    clear(event) {
        if (event) {
            delete this.listeners[event];
        } else {
            this.listeners = {};
        }
    }
}

// Inst√¢ncia global do EventBus
export const eventBus = new EventBus();

// =============================================================================
// SISTEMA DE ESTADO GLOBAL - De state.js
// =============================================================================

class ApplicationState {
    constructor() {
        this.obras = [];
        this.projetos = [];
        this.salas = [];
        this.currentObra = null;
        this.currentProject = null;
        this.currentRoom = null;
        this.sessionActive = false;
        this.systemConstants = null;
    }
    
    /**
     * Define a lista de obras
     * @param {Array} obras - Lista de obras
     */
    setObras(obras) {
        this.obras = obras;
        eventBus.emit('state:obras-changed', obras);
    }
    
    /**
     * Define a lista de projetos
     * @param {Array} projetos - Lista de projetos
     */
    setProjetos(projetos) {
        this.projetos = projetos;
        eventBus.emit('state:projetos-changed', projetos);
    }
    
    /**
     * Define a lista de salas
     * @param {Array} salas - Lista de salas
     */
    setSalas(salas) {
        this.salas = salas;
        eventBus.emit('state:salas-changed', salas);
    }
    
    /**
     * Define a obra atual
     * @param {Object} obra - Obra atual
     */
    setCurrentObra(obra) {
        this.currentObra = obra;
        eventBus.emit('state:current-obra-changed', obra);
    }
    
    /**
     * Define o projeto atual
     * @param {Object} project - Projeto atual
     */
    setCurrentProject(project) {
        this.currentProject = project;
        eventBus.emit('state:current-project-changed', project);
    }
    
    /**
     * Define a sala atual
     * @param {Object} room - Sala atual
     */
    setCurrentRoom(room) {
        this.currentRoom = room;
        eventBus.emit('state:current-room-changed', room);
    }
    
    /**
     * Define o estado da sess√£o
     * @param {boolean} active - Sess√£o ativa
     */
    setSessionActive(active) {
        this.sessionActive = active;
        eventBus.emit('state:session-changed', active);
    }
    
    /**
     * Define as constantes do sistema
     * @param {Object} constants - Constantes do sistema
     */
    setSystemConstants(constants) {
        this.systemConstants = constants;
        eventBus.emit('state:constants-loaded', constants);
    }
    
    /**
     * Obt√©m uma constante do sistema
     * @param {string} key - Chave da constante
     * @returns {any} Valor da constante
     */
    getConstant(key) {
        return this.systemConstants?.[key];
    }
    
    /**
     * Limpa todo o estado
     */
    clear() {
        this.obras = [];
        this.projetos = [];
        this.salas = [];
        this.currentObra = null;
        this.currentProject = null;
        this.currentRoom = null;
        this.sessionActive = false;
        eventBus.emit('state:cleared');
    }
}

// Inst√¢ncia global do Estado
export const appState = new ApplicationState();

// =============================================================================
// SISTEMA DE INICIALIZA√á√ÉO - De bootstrap.js
// =============================================================================

/**
 * Inicializa o sistema de eventos
 */
function initializeEventBus() {
    window.eventBus = eventBus;
    console.log('‚úÖ Event Bus inicializado');
}

/**
 * Inicializa o sistema de estado
 */
function initializeState() {
    window.appState = appState;
    console.log('‚úÖ State inicializado');
}

/**
 * Inicializa a interface do usu√°rio
 */
function initializeInterface() {
    // Importa√ß√£o din√¢mica para evitar circular dependencies
    import('../ui/interface.js')
        .then(module => {
            if (module.initializeInterface) {
                module.initializeInterface();
            } else {
                console.warn('‚ö†Ô∏è initializeInterface n√£o encontrado em interface.js');
            }
        })
        .catch(error => {
            console.error('‚ùå Erro ao inicializar interface:', error);
        });
}

/**
 * Inicializa sistemas core da aplica√ß√£o
 */
function initializeCoreSystems() {
    console.log('üöÄ Inicializando sistemas core...');
    
    try {
        // 1. Inicializa Event Bus
        initializeEventBus();
        
        // 2. Inicializa State
        initializeState();
        
        // 3. Inicializa Interface (ass√≠ncrona)
        initializeInterface();
        
        console.log('‚úÖ Sistemas core inicializados com sucesso');
        
        // Dispara evento de inicializa√ß√£o completa
        eventBus.emit('app:core-ready');
        
    } catch (error) {
        console.error('‚ùå Erro na inicializa√ß√£o dos sistemas core:', error);
        eventBus.emit('app:core-error', error);
    }
}

/**
 * Bootstrap principal da aplica√ß√£o
 * Ponto √∫nico de entrada - substitui main.js
 */
export function bootstrapApplication() {
    console.log('üéØ Bootstrap da aplica√ß√£o iniciado...');
    
    // Verifica se j√° est√° inicializado
    if (window.appInitialized) {
        console.log('‚ö†Ô∏è Aplica√ß√£o j√° inicializada');
        return;
    }
    
    // Inicializa sistemas core
    initializeCoreSystems();
    
    // Marca como inicializado
    window.appInitialized = true;
    
    console.log('‚úÖ Aplica√ß√£o bootstrap completa');
}

/**
 * Reinicializa a aplica√ß√£o
 */
export function reinitializeApplication() {
    console.log('üîÑ Reinicializando aplica√ß√£o...');
    
    // Limpa estado
    appState.clear();
    eventBus.clear();
    
    // Remove flag
    window.appInitialized = false;
    
    // Reinicializa
    bootstrapApplication();
}

/**
 * Verifica o status da aplica√ß√£o
 */
export function getAppStatus() {
    return {
        initialized: !!window.appInitialized,
        eventBus: Object.keys(eventBus.listeners).length,
        state: {
            obras: appState.obras.length,
            projetos: appState.projetos.length,
            salas: appState.salas.length,
            sessionActive: appState.sessionActive
        }
    };
}

// =============================================================================
// INICIALIZA√á√ÉO AUTOM√ÅTICA
// =============================================================================

// Inicializa quando o DOM estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrapApplication);
} else {
    // DOM j√° est√° pronto, inicializa imediatamente
    setTimeout(bootstrapApplication, 0);
}

// =============================================================================
// EXPORTA√á√ïES
// =============================================================================

export {
    // Event Bus
    EventBus,
    
    // Application State
    ApplicationState,
    
    // Initialization functions
    initializeEventBus,
    initializeState,
    initializeCoreSystems,
    reinitializeApplication,
    getAppStatus
};

// Disponibiliza√ß√£o global para compatibilidade
if (typeof window !== 'undefined') {
    window.bootstrapApplication = bootstrapApplication;
    window.reinitializeApplication = reinitializeApplication;
    window.getAppStatus = getAppStatus;
}
/* ==== FIM: app.js ==== */

/* ==== IN√çCIO: obra-manager.js ==== */
/**
 * features/managers/obra-manager.js
 * üéØ FUS√ÉO COMPLETA: projects.js + obra-manager.js
 * ‚ö° REDU√á√ÉO: 2 arquivos ‚Üí 1 arquivo (~700 ‚Üí ~450 linhas)
 */
import{getNextObraNumber} from '../../data/utils/data-utils.js'
import { ensureStringId, generateObraId } from '../../data/utils/id-generator.js';
import { buildObraData } from '../../data/builders/data-builders.js';
import { showSystemStatus } from '../../ui/components/status.js';
import { showConfirmationModal } from '../../ui/components/modal/modal.js';
import { addNewProjectToObra } from './project-manager.js';
import { isSessionActive, startSessionOnFirstSave } from '../../data/adapters/session-adapter.js';
import { calculateRoomCompletionStats } from '../../ui/helpers.js';

/**
 * üèóÔ∏è FUN√á√ïES DE CONSTRU√á√ÉO DE INTERFACE (obra-manager.js)
 */

function buildObraHTML(obraName, obraId, hasId = false) {
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (buildObraHTML) [ID de obra inv√°lido: ${obraId}]`);
        obraId = generateObraId();
    }
    
    console.log(`üîç Build Obra HTML: ${obraName}, ID: ${obraId}`);

    return `
    <div class="obra-block" data-obra-id="${obraId}" data-obra-name="${obraName}">
        <div class="obra-header">
            <button class="minimizer" onclick="toggleObra('${obraId}', event)">+</button>
            <h2 class="obra-title compact-title editable-title" data-editable="true" onclick="makeEditable(this, 'obra')">${obraName}</h2>
            <div class="obra-header-spacer"><span>Adicionar campos de cadastro de empresas</span></div>
            <div class="obra-actions">
                <button class="btn btn-delete" onclick="window.deleteObra('${obraName}', '${obraId}')">Remover Obra</button>
            </div>
        </div>

        <div class="obra-content collapsed" id="obra-content-${obraId}">
            <div class="projetc-header-record very-dark">
                <span>Adicionar campos de cadastro de empresas</span>
            </div>
            <div class="projects-container" id="projects-${obraId}"></div>
            <div class="add-project-section">
                <button class="btn btn-add-secondary" onclick="addNewProjectToObra('${obraId}')">+ Adicionar Projeto</button>
            </div>
            ${buildObraActionsFooter(obraId, obraName, hasId)} 
        </div>
    </div>
    `;
}

function buildObraActionsFooter(obraId, obraName, hasId = false) {
    const buttonText = hasId ? "Atualizar Obra" : "Salvar Obra";
    const buttonClass = hasId ? "btn-update" : "btn-save";

    console.log(`üîß Build Obra Footer: ${obraName}, ID: ${obraId}, HasId: ${hasId}, Button: ${buttonText}`);

    return `
    <div class="obra-actions-footer">
        <button class="btn btn-verify" onclick="verifyObraData('${obraId}')">Verificar Dados</button>
        <button class="btn ${buttonClass}" onclick="event.preventDefault(); saveOrUpdateObra('${obraId}')">${buttonText}</button>      
        <button class="btn btn-download" onclick="downloadPDF('${obraId}')">Baixar PDF</button>
        <button class="btn btn-download" onclick="downloadWord('${obraId}')">Baixar Word</button>
    </div>
    `;
}

async function insertObraIntoDOM(obraHTML, obraId) {
    console.log(`üì§ Inserindo obra no DOM: ${obraId}`);
    
    const projectsContainer = document.getElementById("projects-container");
    
    if (!projectsContainer) {
        console.error('‚ùå Container de projetos n√£o encontrado');
        
        const mainContent = document.querySelector('main, body');
        if (mainContent) {
            const newContainer = document.createElement('div');
            newContainer.id = 'projects-container';
            newContainer.innerHTML = '<!-- Hierarquia: Obra ‚Üí Projeto ‚Üí Sala -->';
            mainContent.appendChild(newContainer);
            console.log('‚úÖ projects-container criado');
            return insertObraIntoDOM(obraHTML, obraId);
        }
        
        return false;
    }
    
    console.log(`‚úÖ Container encontrado, inserindo obra ${obraId}...`);
    console.log(`üì¶ Container antes:`, projectsContainer.children.length, 'elementos');
    
    try {
        projectsContainer.insertAdjacentHTML("beforeend", obraHTML);
        
        setTimeout(() => {
            const obraInserida = document.querySelector(`[data-obra-id="${obraId}"]`);
            if (obraInserida) {
                console.log(`‚úÖ Obra ${obraId} INSERIDA COM SUCESSO no container`);
                console.log(`üì¶ Container depois:`, projectsContainer.children.length, 'elementos');
            } else {
                console.error(`‚ùå FALHA: Obra ${obraId} N√ÉO FOI INSERIDA no container`);
            }
        }, 50);
        
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao inserir obra no DOM:', error);
        return false;
    }
}

async function createEmptyObra(obraName, obraId) {
    const finalObraId = obraId || generateObraId();
    const obraHTML = buildObraHTML(obraName, finalObraId);
    
    console.log(`üèóÔ∏è Criando obra: ${obraName} com ID: ${finalObraId}`);
    console.log(`üìù HTML gerado:`, obraHTML.substring(0, 200) + '...');
    
    const inserted = await insertObraIntoDOM(obraHTML, finalObraId);
    
    if (inserted) {
        console.log(`‚úÖ Obra ${obraName} criada e INSERIDA NO DOM - ID: ${finalObraId}`);
        
        setTimeout(() => {
            const obraNoDOM = document.querySelector(`[data-obra-id="${finalObraId}"]`);
            if (obraNoDOM) {
                console.log(`‚úÖ CONFIRMADO: Obra ${finalObraId} encontrada no DOM`);
            } else {
                console.error(`‚ùå FALHA CR√çTICA: Obra ${finalObraId} N√ÉO est√° no DOM ap√≥s cria√ß√£o`);
            }
        }, 100);
    } else {
        console.error(`‚ùå FALHA: Obra ${obraName} N√ÉO FOI INSERIDA NO DOM`);
    }
    
    return inserted;
}

/**
 * üîÑ FUN√á√ïES DE ATUALIZA√á√ÉO DE INTERFACE
 */

function updateObraButtonAfterSave(obraName, obraId) {
    console.log(`üîÑ Atualizando bot√£o da obra: ${obraName} (${obraId})`);
    
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID ${obraId} n√£o encontrada para atualizar bot√£o`);
        return;
    }

    obraBlock.dataset.obraId = obraId;

    const obraContent = document.getElementById(`obra-content-${obraId}`);
    if (!obraContent) {
        console.error(`‚ùå Conte√∫do da obra ${obraId} n√£o encontrado`);
        return;
    }

    const oldFooter = obraContent.querySelector('.obra-actions-footer');
    if (!oldFooter) {
        console.error(`‚ùå Rodap√© n√£o encontrado na obra ${obraId}`);
        return;
    }

    const saveButton = oldFooter.querySelector('.btn-save, .btn-update');
    if (saveButton) {
        saveButton.textContent = "Atualizar Obra";
        saveButton.className = "btn btn-update";
        saveButton.setAttribute('onclick', `event.preventDefault(); saveOrUpdateObra('${obraId}')`);
        console.log(`‚úÖ Bot√£o atualizado para: "Atualizar Obra" (ID: ${obraId})`);
    } else {
        console.error(`‚ùå Bot√£o de salvar n√£o encontrado na obra ${obraId}`);
    }

    const projectsContainer = document.getElementById(`projects-${obraId}`);
    if (!projectsContainer) {
        console.error(`‚ùå CR√çTICO: Container de projetos PERDIDO na obra ${obraId}!`);
    }
}



/**
 * üöÄ FUN√á√ïES PRINCIPAIS DE GERENCIAMENTO
 */

async function addNewObra() {
    try {
        const obraNumber = getNextObraNumber();
        const obraName = `Obra${obraNumber}`;
        const obraId = generateObraId();

        console.log(`üèóÔ∏è Criando nova obra: ${obraName} com ID: ${obraId}`);
        await createEmptyObra(obraName, obraId);
        console.log(`‚úÖ ${obraName} adicionada com ID √∫nico: ${obraId}`);

        setTimeout(async () => {
            console.log(`üîÑ Criando projeto e sala autom√°ticos para ${obraName}`);
            if (typeof window.addNewProjectToObra === 'function') {
                await window.addNewProjectToObra(obraId);
                console.log(`‚úÖ Projeto e sala autom√°ticos criados para ${obraName}`);
            } else {
                console.error('‚ùå addNewProjectToObra n√£o dispon√≠vel');
            }
        }, 500);

    } catch (error) {
        console.error("‚ùå Erro ao adicionar nova obra:", error);
        alert("Erro ao criar nova obra. Verifique o console para detalhes.");
    }
}

async function deleteObra(obraName, obraId) {
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID ${obraId} n√£o encontrada`);
        return;
    }

    showConfirmationModal(obraName, obraId, obraBlock);
}

/**
 * üíæ FUN√á√ïES DE PERSIST√äNCIA (projects.js)
 */

async function fetchObras() {
    try {
        const response = await fetch('/obras');

        if (!response.ok) {
            if (response.status === 404) {
                return [];
            }
            throw new Error(`Erro HTTP: ${response.status}`);
        }

        const obras = await response.json();
        return obras || [];
    } catch (error) {
        console.error("‚ùå Erro ao buscar obras:", error);
        return [];
    }
}

async function atualizarObra(obraId, obraData) {
    try {
        if (!obraId || obraId === 'undefined' || obraId === 'null') {
            console.error(`ERRO FALBACK (atualizarObra) [ID de obra inv√°lido: ${obraId}]`);
            showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
            return null;
        }

        if (!isSessionActive()) {
            console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° atualizada");
            showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o atualizada.", "error");
            return null;
        }

        obraId = ensureStringId(obraId);

        console.log(`üîç Verificando se obra ${obraId} existe no servidor...`);
        
        const todasObrasResponse = await fetch('/api/backup-completo');
        if (!todasObrasResponse.ok) {
            throw new Error('Falha ao carregar backup para verifica√ß√£o');
        }
        
        const backupData = await todasObrasResponse.json();
        const todasObras = backupData.obras || [];
        const obraExistente = todasObras.find(obra => String(obra.id) === String(obraId));
        
        console.log(`üìä Verifica√ß√£o: Obra ${obraId} existe? ${!!obraExistente}`);
        console.log(`üìã TODAS as obras no backup:`, todasObras.map(o => ({ id: o.id, nome: o.nome })));

        if (!obraExistente) {
            console.log(`‚ùå Obra ${obraId} n√£o encontrada no backup, criando nova...`);
            console.log(`üÜï Criando nova obra com ID seguro preservado: ${obraId}`);
            obraData.id = obraId;
            return await salvarObra(obraData);
        }

        console.log('üîÑ ATUALIZANDO OBRA EXISTENTE:', {
            id: obraData.id,
            nome: obraData.nome,
            projetos: obraData.projetos?.length || 0
        });

        const url = `/obras/${obraId}`;
        console.log(`üéØ Fazendo PUT para: ${url}`);
        
        const response = await fetch(url, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(obraData),
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro ao atualizar obra: ${errorText}`);
        }

        const updatedObra = await response.json();
        showSystemStatus("Obra atualizada com sucesso!", "success");
        
        console.log('‚úÖ OBRA ATUALIZADA:', {
            id: updatedObra.id,
            nome: updatedObra.nome,
            projetos: updatedObra.projetos?.length || 0
        });
        return updatedObra;
    } catch (error) {
        console.error("‚ùå Erro ao ATUALIZAR obra:", error);
        showSystemStatus("ERRO: N√£o foi poss√≠vel atualizar a obra", "error");
        return null;
    }
}

async function salvarObra(obraData) {
    try {
        if (!obraData || !obraData.nome) {
            console.error(`ERRO FALBACK (salvarObra) [Dados da obra inv√°lidos: ${JSON.stringify(obraData)}]`);
            showSystemStatus("ERRO: Dados da obra inv√°lidos", "error");
            return null;
        }

        if (!isSessionActive()) {
            console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
            showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
            return null;
        }

        if (!obraData.id || obraData.id === 'undefined' || obraData.id === 'null') {
            console.error(`ERRO FALBACK (salvarObra) [Obra sem ID seguro: ${obraData.id}]`);
            showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
            return null;
        }

        console.log('üì§ SALVANDO NOVA OBRA:', {
            id: obraData.id,
            nome: obraData.nome,
            projetos: obraData.projetos?.length || 0,
            timestamp: obraData.timestamp
        });

        const response = await fetch('/obras', {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(obraData),
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro ao salvar obra: ${errorText}`);
        }

        const createdObra = await response.json();
        
        console.log(`üìù Adicionando obra ${createdObra.id} √† sess√£o...`);
        await fetch('/api/sessions/add-obra', {
            method: 'POST',
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ obra_id: createdObra.id })
        });
        
        showSystemStatus("Obra salva com sucesso!", "success");
        
        console.log('‚úÖ NOVA OBRA SALVA E ADICIONADA √Ä SESS√ÉO:', {
            id: createdObra.id,
            nome: createdObra.nome,
            projetos: createdObra.projetos?.length || 0
        });
        return createdObra;
    } catch (error) {
        console.error("‚ùå Erro ao SALVAR obra:", error);
        showSystemStatus("ERRO: N√£o foi poss√≠vel salvar a obra", "error");
        return null;
    }
}

/**
 * üîç FUN√á√ïES AUXILIARES DE BUSCA E VERIFICA√á√ÉO
 */

function findObraBlock(obraId) {
    console.log(`üîç Buscando obra pelo ID: "${obraId}"`);
    
    let obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (obraBlock) {
        console.log(`‚úÖ Obra encontrada por ID exato: "${obraId}"`);
        return obraBlock;
    }
    
    const todasObras = document.querySelectorAll('[data-obra-id]');
    console.log(`üìã Obras encontradas no DOM: ${todasObras.length}`);
    
    todasObras.forEach((obra, index) => {
        console.log(`  ${index + 1}.`, {
            id: obra.dataset.obraId,
            name: obra.dataset.obraName,
            classes: obra.className
        });
    });
    
    console.log(`‚ùå Obra com ID "${obraId}" n√£o encontrada no DOM`);
    return null;
}

async function findObraBlockWithRetry(obraId, maxAttempts = 10) {
    console.log(`üîç Buscando obra com retry: "${obraId}"`);
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
        
        if (obraBlock) {
            console.log(`‚úÖ Obra encontrada na tentativa ${attempt}/${maxAttempts}`);
            return obraBlock;
        }
        
        console.log(`‚è≥ Tentativa ${attempt}/${maxAttempts} - obra n√£o encontrada, aguardando...`);
        
        if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    console.log(`‚ùå Obra n√£o encontrada ap√≥s ${maxAttempts} tentativas`);
    return null;
}



/**
 * üíæ FUN√á√ÉO PRINCIPAL DE SALVAMENTO
 */

async function saveObra(obraId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    console.log(`üíæ SALVANDO OBRA pelo ID: "${obraId}"`);

    let obraBlock = await findObraBlockWithRetry(obraId, 15);
    
    if (!obraBlock) {
        console.error('‚ùå Obra n√£o encontrada no DOM ap√≥s m√∫ltiplas tentativas:', obraId);
        
        const todasObras = document.querySelectorAll('[data-obra-id]');
        console.log('üìã Obras dispon√≠veis no DOM:', Array.from(todasObras).map(o => ({
            id: o.dataset.obraId,
            name: o.dataset.obraName
        })));
        
        showSystemStatus("ERRO: Obra n√£o encontrada na interface", "error");
        return;
    }

    const obraOriginalReference = obraBlock;
    const obraContainer = obraBlock.parentElement;
    
    console.log('üîí REFER√äNCIA SALVA:', {
        obra: obraOriginalReference,
        container: obraContainer,
        obraNoContainer: obraContainer.contains(obraOriginalReference)
    });

    if (!isSessionActive()) {
        console.log("üÜï Iniciando sess√£o para primeira obra...");
        await startSessionOnFirstSave();
    }

    if (!isSessionActive()) {
        console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
        showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
        return;
    }

    console.log('‚úÖ Obra confirmada no DOM:', {
        element: obraBlock,
        dataset: obraBlock.dataset,
        id: obraBlock.dataset.obraId,
        name: obraBlock.dataset.obraName
    });

    console.log('üî® Construindo dados da obra...');
    const obraData = buildObraData(obraBlock);

    if (!obraData) {
        console.error('‚ùå Falha ao construir dados da obra');
        showSystemStatus("ERRO: Falha ao construir dados da obra", "error");
        return;
    }

    const obraIdFromDOM = obraBlock.dataset.obraId;
    const obraIdFromData = obraData.id;
    const finalObraId = obraIdFromDOM || obraIdFromData;
    
    console.log('üîç VERIFICA√á√ÉO DE OBRA MELHORADA:');
    console.log('- ID no DOM:', obraIdFromDOM);
    console.log('- ID nos dados:', obraIdFromData);
    console.log('- ID final para uso:', finalObraId);
    console.log('- √â ID seguro?:', finalObraId?.startsWith('obra_'));
    
    let isNewObra = true;
    
    try {
        const todasObrasResponse = await fetch('/api/backup-completo');
        if (todasObrasResponse.ok) {
            const backupData = await todasObrasResponse.json();
            const todasObras = backupData.obras || [];
            const obraExistente = todasObras.find(obra => String(obra.id) === String(finalObraId));
            
            isNewObra = !obraExistente;
            console.log(`- J√° existe no servidor?: ${!isNewObra}`);
        }
    } catch (error) {
        console.log('- N√£o foi poss√≠vel verificar servidor, assumindo como nova obra');
    }

    console.log('- √â nova obra?:', isNewObra);

    let result = null;
    
    if (isNewObra) {
        console.log('üÜï SALVANDO COMO NOVA OBRA COM ID SEGURO:', finalObraId);
        
        obraData.id = finalObraId;
        
        if (!obraData.id || !obraData.id.startsWith('obra_')) {
            console.error('‚ùå Obra n√£o possui ID seguro v√°lido para salvar');
            showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
            return;
        }
        
        result = await salvarObra(obraData);
    } else {
        console.log('üìù ATUALIZANDO OBRA EXISTENTE, ID SEGURO:', finalObraId);
        
        if (!finalObraId.startsWith('obra_')) {
            console.error(`ERRO: ID n√£o seguro para atualiza√ß√£o: ${finalObraId}`);
            showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
            return;
        }
        
        result = await atualizarObra(finalObraId, obraData);
    }

    if (result) {
        const finalId = ensureStringId(result.id);
        
        let obraBlockAtual = document.querySelector(`[data-obra-id="${finalId}"]`);
        
        if (!obraBlockAtual) {
            console.error('‚ùå CR√çTICO: Obra desapareceu do DOM durante salvamento!');
            console.log('üîç Tentando recuperar da refer√™ncia original...');
            
            if (obraContainer && document.body.contains(obraContainer)) {
                const obrasNoContainer = obraContainer.querySelectorAll('[data-obra-id]');
                console.log(`üì¶ Obras no container original: ${obrasNoContainer.length}`);
                
                if (obraContainer.contains(obraOriginalReference)) {
                    obraBlockAtual = obraOriginalReference;
                    console.log('‚úÖ Obra recuperada da refer√™ncia original');
                } else {
                    console.error('‚ùå Obra n√£o est√° mais no container original');
                    showSystemStatus("ERRO: Obra perdida durante salvamento", "error");
                    return;
                }
            } else {
                console.error('‚ùå Container original n√£o encontrado');
                showSystemStatus("ERRO: Obra perdida durante salvamento", "error");
                return;
            }
        }

        obraBlockAtual.dataset.obraId = finalId;
        obraBlockAtual.dataset.obraName = obraData.nome;
        
        const titleElement = obraBlockAtual.querySelector('.obra-title');
        if (titleElement && titleElement.textContent !== obraData.nome) {
            titleElement.textContent = obraData.nome;
        }

        if (typeof updateObraButtonAfterSave === 'function' && document.body.contains(obraBlockAtual)) {
            console.log("‚úÖ Obra confirmada no DOM, atualizando bot√£o...");
            updateObraButtonAfterSave(obraData.nome, finalId);
        } else {
            console.error('‚ùå Obra n√£o est√° no DOM para atualizar bot√£o');
        }

        console.log(`‚úÖ OBRA SALVA/ATUALIZADA COM SUCESSO! ID SEGURO: ${finalId}`);
        
        showSystemStatus("Obra salva com sucesso!", "success");
    } else {
        console.error('‚ùå FALHA AO SALVAR OBRA NO SERVIDOR');
        showSystemStatus("ERRO: Falha ao salvar obra no servidor", "error");
    }
}

/**
 * üóëÔ∏è FUN√á√ïES DE REMO√á√ÉO E VERIFICA√á√ÉO
 */

async function deleteObraFromServer(obraName, obraId) {
    try {
        if (!obraId || obraId === 'undefined' || obraId === 'null' || !obraId.startsWith('obra_')) {
            console.error(`ERRO FALBACK (deleteObraFromServer) [ID de obra inv√°lido: ${obraId}]`);
            showSystemStatus("ERRO: ID da obra inv√°lido para remo√ß√£o", "error");
            return;
        }

        if (!isSessionActive()) {
            console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° removida do servidor");
            return;
        }

        obraId = ensureStringId(obraId);

        console.log(`üóëÔ∏è Removendo obra ${obraId} do servidor...`);

        const response = await fetch(`/obras/${obraId}`, {
            method: "DELETE",
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro ao remover obra: ${errorText}`);
        }

        console.log(`‚úÖ Obra ${obraId} removida do servidor`);
        showSystemStatus("Obra removida do servidor com sucesso", "success");
    } catch (error) {
        console.error("‚ùå Erro ao remover obra do servidor:", error);
        showSystemStatus("ERRO: N√£o foi poss√≠vel remover a obra do servidor", "error");
    }
}

function verifyObraData(obraId) {
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID "${obraId}" n√£o encontrada para verifica√ß√£o`);
        alert(`ERRO: Obra com ID "${obraId}" n√£o encontrada`);
        return;
    }

    const obraName = obraBlock.dataset.obraName;
    const projects = obraBlock.querySelectorAll(".project-block");
    let totalRooms = 0;
    
    let report = `Verifica√ß√£o da Obra "${obraName}" (ID: ${obraId}):\n\n`;
    report += `Total de projetos: ${projects.length}\n\n`;

    projects.forEach((project, index) => {
        const projectName = project.dataset.projectName;
        const rooms = project.querySelectorAll(".room-block");
        totalRooms += rooms.length;
        
        report += `Projeto ${index + 1}: ${projectName}\n`;
        report += `  - Salas: ${rooms.length}\n`;
        
        rooms.forEach((room, roomIndex) => {
            const roomName = room.querySelector(".room-title")?.textContent || `Sala ${roomIndex + 1}`;
            const stats = calculateRoomCompletionStats(room);
            report += `    - ${roomName}: ${stats.filled}/${stats.total} campos (${stats.percentage}%)\n`;
        });
        report += '\n';
    });

    report += `RESUMO: ${projects.length} projetos, ${totalRooms} salas`;

    console.log(`üîç Relat√≥rio gerado para obra: ${obraName} (ID: ${obraId})`);
    alert(report);
}

/**
 * üåê EXPORTA√á√ïES E COMPATIBILIDADE GLOBAL
 */

// Exporta√ß√µes para m√≥dulos ES6
export {
    // Interface
    createEmptyObra,
    buildObraHTML,
    buildObraActionsFooter,
    insertObraIntoDOM,
    updateObraButtonAfterSave,
    addNewObra,
    deleteObra,
    
    // Persist√™ncia
    fetchObras,
    salvarObra,
    atualizarObra,
    saveObra,
    deleteObraFromServer,
    
    // Utilit√°rios
    verifyObraData,
    findObraBlock,
    findObraBlockWithRetry,

    // IDs
    generateObraId,
    ensureStringId
};

// Compatibilidade global para scripts legados
if (typeof window !== 'undefined') {
    window.deleteObra = deleteObra;
    window.addNewObra = addNewObra;
    window.saveObra = saveObra;
    window.verifyObraData = verifyObraData;
    window.findObraBlock = findObraBlock;
    window.generateObraId = generateObraId;
    window.ensureStringId = ensureStringId;
}
/* ==== FIM: obra-manager.js ==== */

/* ==== IN√çCIO: rooms.js ==== */
/**
 * data/modules/rooms.js
 * üéØ FUS√ÉO COMPLETA: room-operations.js + salas.js
 * ‚ö° REDU√á√ÉO: 2 arquivos ‚Üí 1 arquivo (~350 ‚Üí ~250 linhas)
 */

import { buildClimatizationSection } from './climatizacao.js';
import { buildMachinesSection } from './machines/machines-core.js';
import { buildConfigurationSection } from './configuracao.js';
import { generateRoomId } from '../utils/id-generator.js';
import { removeEmptyProjectMessage, showEmptyProjectMessageIfNeeded } from '../../ui/helpers.js';

// Cache para m√≥dulo de m√°quinas
let machinesPreloadModule = null;

/**
 * üèóÔ∏è FUN√á√ïES DE CONSTRU√á√ÉO DE HTML (salas.js)
 */

/**
 * Constr√≥i o HTML completo de uma sala com todas as se√ß√µes
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML completo da sala
 */
function buildRoomHTML(obraId, projectId, roomName, roomId) {
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Obra ID inv√°lido: ${obraId}]`);
        return '';
    }
    
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Project ID inv√°lido: ${projectId}]`);
        return '';
    }
    
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHTML) [Room ID inv√°lido: ${roomId}]`);
        return '';
    }
    
    console.log(`[BUILD ROOM] Par√¢metros:`, { obraId, projectId, roomName, roomId });
    console.log(`[BUILD ROOM] ID √öNICO: ${roomId}`);
    
    return `
      <div class="room-block" data-room-id="${roomId}" data-room-name="${roomName}" data-project-id="${projectId}" data-obra-id="${obraId}">
        <div class="room-header">
          <button class="minimizer" onclick="toggleRoom('${roomId}', event)">+</button>
          <h4 class="room-title editable-title" data-editable="true" onclick="makeEditable(this, 'room')">${roomName}</h4>
          <div class="room-actions">
            <button class="btn btn-delete" onclick="deleteRoom('${obraId}', '${projectId}', '${roomId}')">Remover</button>
          </div>
        </div>
        <div class="room-content collapsed" id="room-content-${roomId}">
          ${buildClimatizationSection(obraId, projectId, roomName, roomId)}
          ${buildMachinesSection(obraId, projectId, roomName, roomId)}
          ${buildConfigurationSection(obraId, projectId, roomName, roomId)}
        </div>
      </div>
    `;
}

/**
 * Constr√≥i apenas o cabe√ßalho da sala com t√≠tulo e a√ß√µes
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML do cabe√ßalho da sala
 */
function buildRoomHeader(obraId, projectId, roomName, roomId) {
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (buildRoomHeader) [Room ID inv√°lido: ${roomId}]`);
        return '';
    }
    
    return `
    <div class="room-header">
      <button class="minimizer" onclick="toggleRoom('${roomId}', event)">+</button>
      <h3 class="room-title editable-title" data-editable="true" onclick="makeEditable(this, 'room')">${roomName}</h3>
      <button class="btn btn-delete-small" onclick="deleteRoom('${obraId}', '${projectId}', '${roomId}')">Remover</button>
    </div>
  `;
}

/**
 * Constr√≥i a se√ß√£o de a√ß√µes da sala (reservado para futuras implementa√ß√µes)
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} HTML vazio
 */
function buildRoomActions(roomId) {
    return "";
}

/**
 * üîß FUN√á√ïES DE OPERA√á√ïES (room-operations.js)
 */

/**
 * Carrega o m√≥dulo de m√°quinas para pr√©-carregamento ass√≠ncrono
 * @returns {Promise<Object|null>} M√≥dulo de m√°quinas carregado
 */
async function loadMachinesPreloadModule() {
    if (!machinesPreloadModule) {
        try {
            machinesPreloadModule = await import('./machines/machines-core.js');
            console.log("‚úÖ M√≥dulo de m√°quinas carregado para pr√©-carregamento");
        } catch (error) {
            console.error("‚ùå Erro ao carregar m√≥dulo de m√°quinas:", error);
        }
    }
    return machinesPreloadModule;
}

/**
 * Cria uma nova sala vazia no projeto especificado
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto  
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala (opcional)
 * @returns {Promise<boolean>} True se a sala foi criada com sucesso
 */
async function createEmptyRoom(obraId, projectId, roomName, roomId) {
    console.log(`üîÑ Criando sala: ${roomName} na obra "${obraId}", projeto "${projectId}"`);
    
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (createEmptyRoom) [Obra ID inv√°lido: ${obraId}]`);
        return false;
    }
    
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (createEmptyRoom) [Project ID inv√°lido: ${projectId}]`);
        return false;
    }
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        
        console.log('üîç Projetos dispon√≠veis no DOM:');
        document.querySelectorAll('.project-block').forEach(proj => {
            console.log(`  - Projeto: ${proj.dataset.projectName}, 
                         ProjectID: ${proj.dataset.projectId}, 
                         ObraID: ${proj.dataset.obraId}, 
                         ObraName: ${proj.dataset.obraName}`);
        });
        return false;
    }
    
    console.log(`‚úÖ Projeto encontrado:`, projectElement.dataset);

    let finalRoomId;
    
    if (roomId && roomId !== 'undefined' && roomId !== 'null' && !roomId.includes('undefined')) {
        finalRoomId = roomId;
    } else {
        const roomCount = getRoomCountInProject(obraId, projectId);
        finalRoomId = generateRoomId(projectElement, roomCount + 1);
    }
    
    finalRoomId = finalRoomId.toString()
        .replace(/-undefined/g, '')
        .replace(/-null/g, '')
        .trim();
    
    console.log(`üìù ID SEGURO DEFINITIVO DA SALA: "${finalRoomId}"`);
    
    try {
        const machinesModule = await loadMachinesPreloadModule();
        if (machinesModule && machinesModule.preloadMachinesDataForRoom) {
            await machinesModule.preloadMachinesDataForRoom(finalRoomId);
        }
    } catch (error) {
        console.error("‚ö†Ô∏è Aviso: N√£o foi poss√≠vel pr√©-carregar dados das m√°quinas:", error);
    }

    const roomHTML = buildRoomHTML(obraId, projectId, roomName, finalRoomId);
    
    const projectContent = projectElement.querySelector('.project-content');
    
    if (!projectContent) {
        console.error(`‚ùå Conte√∫do do projeto n√£o encontrado em ${projectId}`);
        return false;
    }

    removeEmptyProjectMessage(projectContent);
    
    const addRoomSection = projectContent.querySelector('.add-room-section');
    if (addRoomSection) {
        addRoomSection.insertAdjacentHTML('beforebegin', roomHTML);
    } else {
        projectContent.insertAdjacentHTML('beforeend', roomHTML);
    }

    console.log(`‚úÖ Sala ${roomName} criada (ID: ${finalRoomId}) na obra "${obraId}", projeto "${projectId}"`);
    
    initializeRoomComponents(obraId, projectId, roomName, finalRoomId);
    
    return true;
}

/**
 * Conta quantas salas j√° existem no projeto espec√≠fico
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {number} Quantidade de salas no projeto
 */
function getRoomCountInProject(obraId, projectId) {
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    if (!projectElement) return 0;
    
    const rooms = projectElement.querySelectorAll('.room-block');
    return rooms.length;
}

/**
 * Inicializa todos os componentes da sala ap√≥s cria√ß√£o
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function initializeRoomComponents(obraId, projectId, roomName, roomId) {
    console.log(`üîß Inicializando componentes da sala: ${roomName} (ID: ${roomId})`);
    
    const initializeWithRetry = (functionName, delay, maxAttempts = 5) => {
        let attempts = 0;
        
        const tryInitialize = () => {
            if (typeof window[functionName] === 'function') {
                window[functionName](roomId);
                console.log(`‚úÖ ${functionName} inicializado para ${roomId}`);
            } else if (attempts < maxAttempts) {
                attempts++;
                console.log(`‚è≥ Tentativa ${attempts}/${maxAttempts} - ${functionName} n√£o dispon√≠vel, tentando novamente...`);
                setTimeout(tryInitialize, delay);
            } else {
                console.log(`‚ÑπÔ∏è ${functionName} n√£o dispon√≠vel ap√≥s ${maxAttempts} tentativas - pode ser normal`);
            }
        };
        
        setTimeout(tryInitialize, delay);
    };
    
    initializeWithRetry('initializeFatorSeguranca', 300, 5);
    initializeWithRetry('syncCapacityTableBackup', 500, 3);
    
    setTimeout(async () => {
        try {
            const machinesModule = await import('./machines/machines-core.js');
            if (machinesModule.preloadMachinesDataForRoom) {
                await machinesModule.preloadMachinesDataForRoom(roomId);
                console.log(`‚úÖ Dados das m√°quinas pr√©-carregados para ${roomId}`);
            }
        } catch (error) {
            console.log(`‚ÑπÔ∏è N√£o foi poss√≠vel pr√©-carregar dados das m√°quinas para ${roomId} - pode ser normal`);
        }
    }, 800);
}

/**
 * Fun√ß√£o auxiliar para inicializar fator de seguran√ßa de forma segura
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function safeInitializeFatorSeguranca(roomId) {
    if (typeof window.initializeFatorSeguranca === 'function') {
        try {
            window.initializeFatorSeguranca(roomId);
            console.log(`‚úÖ Fator de seguran√ßa inicializado para ${roomId}`);
        } catch (error) {
            console.log(`‚ÑπÔ∏è Erro ao inicializar fator de seguran√ßa para ${roomId}:`, error.message);
        }
    } else {
        console.log(`‚ÑπÔ∏è initializeFatorSeguranca n√£o dispon√≠vel - aguardando carregamento`);
    }
}

/**
 * Insere o HTML de uma sala no conte√∫do do projeto
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomHTML - HTML da sala a ser inserida
 * @param {string} roomId - ID √∫nico da sala
 * @returns {void}
 */
function insertRoomIntoProject(obraId, projectId, roomHTML, roomId) {
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }

    const projectContent = projectElement.querySelector('.project-content');
    if (!projectContent) {
        console.error(`‚ùå Conte√∫do do projeto ${projectId} n√£o encontrado`);
        return;
    }

    const addRoomSection = projectContent.querySelector(".add-room-section");
    if (addRoomSection) {
        addRoomSection.insertAdjacentHTML("beforebegin", roomHTML);
    } else {
        projectContent.insertAdjacentHTML("beforeend", roomHTML);
    }

    removeEmptyProjectMessage(projectContent);
    console.log(`‚úÖ Sala inserida no projeto ${projectId} (ID √∫nico: ${roomId})`);
}

/**
 * Adiciona uma nova sala ao projeto
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {Promise<void>}
 */
async function addNewRoom(obraId, projectId) {
    console.log(`‚ûï Adicionando nova sala √† obra "${obraId}", projeto "${projectId}"`);
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }
    
    const roomCount = getRoomCountInProject(obraId, projectId);
    const roomName = `Sala${roomCount + 1}`;

    await createEmptyRoom(obraId, projectId, roomName, null);
    console.log(`‚úÖ ${roomName} adicionada √† obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Adiciona uma nova sala ao projeto (alias para compatibilidade)
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @returns {Promise<void>}
 */
async function addNewRoomToProject(obraId, projectId) {
    console.log(`‚ûï Adicionando nova sala √† obra "${obraId}", projeto "${projectId}"`);
    
    const projectElement = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`);
    
    if (!projectElement) {
        console.error(`‚ùå Projeto ${projectId} n√£o encontrado na obra ${obraId}`);
        return;
    }
    
    const roomCount = getRoomCountInProject(obraId, projectId);
    const roomName = `Sala${roomCount + 1}`;

    await createEmptyRoom(obraId, projectId, roomName, null);
    console.log(`‚úÖ ${roomName} adicionada √† obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Fun√ß√£o de compatibilidade para c√≥digo existente que usa apenas projectName
 * @param {string} projectName - Nome do projeto
 * @returns {Promise<void>}
 */
async function addNewRoomLegacy(projectName) {
    const projectBlock = document.querySelector(`[data-project-name="${projectName}"]`);
    const obraId = projectBlock?.dataset.obraId;
    const projectId = projectBlock?.dataset.projectId;
    
    if (obraId && projectId) {
        return addNewRoomToProject(obraId, projectId);
    } else {
        console.error('‚ùå N√£o foi poss√≠vel determinar a obra do projeto:', projectName);
    }
}

/**
 * Remove uma sala do projeto ap√≥s confirma√ß√£o do usu√°rio
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomId - ID √∫nico da sala a ser removida
 * @returns {void}
 */
function deleteRoom(obraId, projectId, roomId) {
    const roomBlock = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"][data-room-id="${roomId}"]`);
    
    if (!roomBlock) {
        console.error(`‚ùå Sala com ID ${roomId} n√£o encontrada no projeto ${projectId}, obra ${obraId}`);
        return;
    }

    const roomName = roomBlock.dataset.roomName;
    const projectContent = roomBlock.closest(".project-content");

    roomBlock.remove();
    
    if (projectContent && typeof window.showEmptyProjectMessageIfNeeded === 'function') {
        window.showEmptyProjectMessageIfNeeded(projectContent);
    }

    console.log(`üóëÔ∏è Sala ${roomName} (ID: ${roomId}) removida da obra "${obraId}", projeto "${projectId}"`);
}

/**
 * Fun√ß√£o de compatibilidade para c√≥digo existente que usa apenas projectName e roomName
 * @param {string} projectName - Nome do projeto
 * @param {string} roomName - Nome da sala
 * @returns {void}
 */
function deleteRoomLegacy(projectName, roomName) {
    const projectBlock = document.querySelector(`[data-project-name="${projectName}"]`);
    const obraId = projectBlock?.dataset.obraId;
    const projectId = projectBlock?.dataset.projectId;
    
    if (obraId && projectId) {
        const roomBlock = document.querySelector(`[data-obra-id="${obraId}"][data-project-id="${projectId}"][data-room-name="${roomName}"]`);
        const roomId = roomBlock?.dataset.roomId;
        
        if (roomId) {
            return deleteRoom(obraId, projectId, roomId);
        } else {
            console.error(`‚ùå ID da sala ${roomName} n√£o encontrado`);
        }
    } else {
        console.error('‚ùå N√£o foi poss√≠vel determinar a obra do projeto:', projectName);
    }
}

/**
 * Corrige inputs de fator de seguran√ßa que estejam vazios
 * Aplica valores padr√£o baseados nas constantes do sistema
 * @returns {void}
 */
function fixExistingCapacityInputs() {
    console.log('üîÑ Verificando inputs de capacidade existentes...');
    
    const roomBlocks = document.querySelectorAll('.room-block');
    
    roomBlocks.forEach(roomBlock => {
        const roomId = roomBlock.dataset.roomId;
        const roomName = roomBlock.dataset.roomName;
        const projectBlock = roomBlock.closest('.project-block');
        const projectId = projectBlock?.dataset.projectId;
        const obraId = projectBlock?.dataset.obraId;
        
        if (roomId) {
            const input = document.getElementById(`fator-seguranca-${roomId}`);
            
            if (input && input.value === '') {
                const valor = window.systemConstants?.FATOR_SEGURANCA_CAPACIDADE || 10;
                input.value = valor;
                console.log(`‚úÖ Input ${roomId} corrigido: ${valor}% (Obra: ${obraId}, Projeto: ${projectId})`);
            }
        }
    });
}

// Executar quando o projeto for carregado
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(fixExistingCapacityInputs, 2000);
});

/**
 * üåê EXPORTA√á√ïES E COMPATIBILIDADE GLOBAL
 */

// Exporta√ß√µes para m√≥dulos ES6
export {
    // Constru√ß√£o
    buildRoomHTML,
    buildRoomHeader,
    buildRoomActions,
    
    // Opera√ß√µes
    createEmptyRoom,
    insertRoomIntoProject,
    addNewRoom,
    deleteRoom,
    deleteRoomLegacy,
    safeInitializeFatorSeguranca,
    addNewRoomToProject,
    
    // Utilit√°rios
    getRoomCountInProject,
    initializeRoomComponents,
    fixExistingCapacityInputs,
    loadMachinesPreloadModule
};

// Compatibilidade global para scripts legados
if (typeof window !== 'undefined') {
    window.addNewRoom = addNewRoom;
    window.deleteRoom = deleteRoom;
    window.addNewRoomToProject = addNewRoomToProject;
    window.createEmptyRoom = createEmptyRoom;
    window.safeInitializeFatorSeguranca = safeInitializeFatorSeguranca;
    window.buildRoomHTML = buildRoomHTML;
}
/* ==== FIM: rooms.js ==== */

/* ==== IN√çCIO: status.js ==== */
/**
 * ui/components/status.js
 * üéØ FUS√ÉO: status-manager.js ‚Üí status.js
 * ‚ö° REFATORA√á√ÉO: Import atualizado + funcionalidades estendidas
 */

import { UI_CONSTANTS } from '../../core/constants.js';

/**
 * Gerenciador de status do sistema (banners de sucesso, erro, etc.) - SISTEMA UNIFICADO
 */

// Cache para controle de banners ativos
let activeBanners = new Set();

/**
 * Exibe um banner de status do sistema
 * @param {string} message - Mensagem a ser exibida
 * @param {string} type - Tipo de status ('success', 'error', 'warning', 'info')
 * @param {number} duration - Dura√ß√£o em ms (opcional, padr√£o baseado no tipo)
 */
function showSystemStatus(message, type = 'info', duration = null) {
    removeExistingStatusBanner();

    const banner = createStatusBanner(message, type);
    insertStatusBanner(banner);
    
    // Adicionar ao controle de banners ativos
    activeBanners.add(banner);

    // Configurar remo√ß√£o autom√°tica baseada no tipo
    if (type === "success" || duration !== null) {
        const removalTime = duration || getDefaultDuration(type);
        scheduleStatusBannerRemoval(banner, removalTime);
    }
    
    // Log para debug
    console.log(`üì¢ Status [${type.toUpperCase()}]: ${message}`);
}

/**
 * Remove qualquer banner de status existente
 */
function removeExistingStatusBanner() {
    const existingBanner = document.getElementById("system-status-banner");
    if (existingBanner) {
        existingBanner.remove();
        activeBanners.delete(existingBanner);
    }
}

/**
 * Remove todos os banners de status (limpeza completa)
 */
function removeAllStatusBanners() {
    const allBanners = document.querySelectorAll('#system-status-banner, .system-status-banner');
    allBanners.forEach(banner => {
        banner.remove();
        activeBanners.delete(banner);
    });
    activeBanners.clear();
}

/**
 * Cria um elemento de banner de status
 * @param {string} message - Mensagem do banner
 * @param {string} type - Tipo de banner
 * @returns {HTMLElement} Elemento do banner criado
 */
function createStatusBanner(message, type) {
    const banner = document.createElement("div");
    banner.id = "system-status-banner";
    banner.className = `system-status-banner ${type}`;
    
    // √çcone baseado no tipo
    const icon = getStatusIcon(type);
    
    banner.innerHTML = `
        <div class="status-banner-content">
            <span class="status-icon">${icon}</span>
            <span class="status-message">${message}</span>
        </div>
    `;
    
    return banner;
}

/**
 * Obt√©m √≠cone apropriado para o tipo de status
 * @param {string} type - Tipo de status
 * @returns {string} Emoji do √≠cone
 */
function getStatusIcon(type) {
    const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        warning: '‚ö†Ô∏è',
        info: '‚ÑπÔ∏è',
        loading: '‚è≥'
    };
    return icons[type] || icons.info;
}

/**
 * Obt√©m dura√ß√£o padr√£o baseada no tipo
 * @param {string} type - Tipo de status
 * @returns {number} Dura√ß√£o em ms
 */
function getDefaultDuration(type) {
    const durations = {
        success: UI_CONSTANTS.SUCCESS_MESSAGE_DURATION || 5000,
        error: 8000,    // Erros ficam mais tempo
        warning: 6000,  // Warnings tempo m√©dio
        info: 4000,     // Info tempo curto
        loading: 0      // Loading n√£o some automaticamente
    };
    return durations[type] || 5000;
}

/**
 * Insere o banner de status no DOM
 * @param {HTMLElement} banner - Banner a ser inserido
 */
function insertStatusBanner(banner) {
    // Tentar inserir no main-content primeiro
    const mainContent = document.querySelector(".main-content");
    if (mainContent) {
        mainContent.insertBefore(banner, mainContent.firstChild);
        return;
    }
    
    // Fallback: inserir no body
    const body = document.body;
    if (body.firstChild) {
        body.insertBefore(banner, body.firstChild);
    } else {
        body.appendChild(banner);
    }
}

/**
 * Agenda a remo√ß√£o autom√°tica do banner
 * @param {HTMLElement} banner - Banner a ser removido
 * @param {number} duration - Dura√ß√£o em ms
 */
function scheduleStatusBannerRemoval(banner, duration) {
    if (duration > 0) {
        setTimeout(() => {
            if (banner && banner.parentNode) {
                banner.remove();
                activeBanners.delete(banner);
            }
        }, duration);
    }
}

/**
 * üÜï FUN√á√ÉO: Exibe status de carregamento
 * @param {string} message - Mensagem de carregamento
 * @returns {Function} Fun√ß√£o para remover o loading
 */
function showLoadingStatus(message = 'Carregando...') {
    removeExistingStatusBanner();
    const banner = createStatusBanner(message, 'loading');
    insertStatusBanner(banner);
    activeBanners.add(banner);
    
    // Retorna fun√ß√£o para remover o loading
    return () => {
        if (banner && banner.parentNode) {
            banner.remove();
            activeBanners.delete(banner);
        }
    };
}

/**
 * üÜï FUN√á√ÉO: Exibe status tempor√°rio com callback
 * @param {string} message - Mensagem
 * @param {string} type - Tipo de status
 * @param {number} duration - Dura√ß√£o
 * @param {Function} callback - Callback ap√≥s remo√ß√£o
 */
function showTemporaryStatus(message, type = 'success', duration = 3000, callback = null) {
    showSystemStatus(message, type, duration);
    
    if (callback && typeof callback === 'function') {
        setTimeout(callback, duration);
    }
}

/**
 * üÜï FUN√á√ÉO: Verifica se h√° banner ativo
 * @returns {boolean} True se h√° banner ativo
 */
function hasActiveStatusBanner() {
    return activeBanners.size > 0;
}

/**
 * üÜï FUN√á√ÉO: Obt√©m contagem de banners ativos
 * @returns {number} N√∫mero de banners ativos
 */
function getActiveBannersCount() {
    return activeBanners.size;
}

// Exporta√ß√µes para m√≥dulos ES6
export {
    showSystemStatus,
    removeExistingStatusBanner,
    removeAllStatusBanners,
    createStatusBanner,
    insertStatusBanner,
    scheduleStatusBannerRemoval,
    showLoadingStatus,
    showTemporaryStatus,
    hasActiveStatusBanner,
    getActiveBannersCount
};

// Compatibilidade global para scripts legados
if (typeof window !== 'undefined') {
    window.showSystemStatus = showSystemStatus;
    window.removeExistingStatusBanner = removeExistingStatusBanner;
    window.removeAllStatusBanners = removeAllStatusBanners;
    window.showLoadingStatus = showLoadingStatus;
    window.showTemporaryStatus = showTemporaryStatus;
}
/* ==== FIM: status.js ==== */

/* ==== IN√çCIO: ui-builders.js ==== */
/**
 * data/builders/ui-builders.js
 * üéØ FUS√ÉO COMPLETA: data-populate.js + server-utils.js
 * ‚ö° REDU√á√ÉO: 2 arquivos ‚Üí 1 arquivo (~900 ‚Üí ~600 linhas)
 */
import { buildMachinesSection, addMachine } from '../modules/machines/machines-core.js';
import { updateObraButtonAfterSave } from '../../features/managers/obra-manager.js';
import { createEmptyRoom } from '../modules/rooms.js';
import { calculateVazaoArAndThermalGains } from '../../features/calculations/air-flow.js';
import { ensureStringId, generateObraId } from '../utils/id-generator.js';
import {waitForElement} from '../../utils/core-utils.js'
/**
 * üèóÔ∏è FUN√á√ïES DE RENDERIZA√á√ÉO (server-utils.js)
 */

/**
 * Renderiza uma obra completa a partir dos dados carregados do servidor
 * @param {Object} obraData - Dados completos da obra
 * @returns {void}
 */
function renderObraFromData(obraData) {
    const obraName = obraData.nome;
    const obraId = ensureStringId(obraData.id);

    console.log(`üéØ Renderizando obra: ${obraName} (ID: ${obraId})`);

    createEmptyObra(obraName, obraId);

    if (obraData.projetos && obraData.projetos.length > 0) {
        const obraContent = document.getElementById(`obra-content-${obraId}`);

        if (obraContent) {
            const emptyMessage = obraContent.querySelector(".empty-message");
            if (emptyMessage) {
                emptyMessage.remove();
            }

            setTimeout(() => {
                obraData.projetos.forEach((projectData) => {
                    renderProjectFromData(projectData, obraId, obraName);
                });
            }, 100);
        }
    }

    console.log(`‚úÖ Obra ${obraName} renderizada com sucesso (ID: ${obraId})`);
}

/**
 * Renderiza um projeto completo a partir dos dados carregados
 * @param {Object} projectData - Dados completos do projeto
 * @param {string} obraId - ID √∫nico da obra pai
 * @param {string} obraName - Nome da obra pai
 * @returns {void}
 */
function renderProjectFromData(projectData, obraId = null, obraName = null) {
    const projectName = projectData.nome;
    const projectId = ensureStringId(projectData.id);

    console.log(`üéØ Renderizando projeto: ${projectName} (ID: ${projectId})`);

    if (!obraId) {
        const existingProject = document.querySelector(`[data-project-id="${projectId}"]`);
        obraId = existingProject?.dataset.obraId;
        obraName = existingProject?.dataset.obraName;
    }

    if (!obraId) {
        const obras = document.querySelectorAll('.obra-block');
        if (obras.length > 0) {
            const primeiraObra = obras[0];
            obraId = primeiraObra.dataset.obraId;
            obraName = primeiraObra.dataset.obraName;
        } else {
            obraName = 'Obra1';
            obraId = generateObraId();
            createEmptyObra(obraName, obraId);
        }
    }

    createEmptyProject(obraId, obraName, projectId, projectName);

    if (projectData.salas && projectData.salas.length > 0) {
        const projectContent = document.getElementById(`project-content-${projectId}`);

        if (projectContent) {
            const emptyMessage = projectContent.querySelector(".empty-message");
            if (emptyMessage) {
                emptyMessage.remove();
            }

            setTimeout(() => {
                projectData.salas.forEach((roomData) => {
                    renderRoomFromData(projectId, projectName, roomData, obraId, obraName);
                });
            }, 100);
        }
    }

    if (projectId) {
        updateProjectButton(projectName, true);
    }

    console.log(`‚úÖ Projeto ${projectName} renderizado com sucesso`);
}

/**
 * Renderiza uma sala individual a partir dos dados carregados
 * @param {string} projectId - ID √∫nico do projeto pai
 * @param {string} projectName - Nome do projeto pai
 * @param {Object} roomData - Dados completos da sala
 * @param {string} obraId - ID √∫nico da obra pai
 * @param {string} obraName - Nome da obra pai
 * @returns {void}
 */
function renderRoomFromData(projectId, projectName, roomData, obraId = null, obraName = null) {
    const roomName = roomData.nome;
    const roomId = ensureStringId(roomData.id);

    console.log(`üéØ Renderizando sala: ${roomName} no projeto ${projectName}`, {
        obra: obraName,
        projectId: projectId,
        roomId: roomId,
        inputs: Object.keys(roomData.inputs || {}).length,
        maquinas: roomData.maquinas?.length || 0,
        capacidade: Object.keys(roomData.capacidade || {}).length,
        ganhosTermicos: Object.keys(roomData.ganhosTermicos || {}).length,
        configuracao: Object.keys(roomData.configuracao || {}).length
    });

    setTimeout(() => {
        createEmptyRoom(obraId, projectId, roomName, roomId);

        setTimeout(() => {
            populateRoomInputs(projectId, projectName, roomId, roomName, roomData, obraId, obraName);
        }, 100);
        
    }, 100);
}

/**
 * üîß FUN√á√ïES DE PREENCHIMENTO ESPEC√çFICAS (data-populate.js)
 */

/**
 * Preenche os campos de climatiza√ß√£o de uma sala com dados do JSON
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Object} inputsData - Dados dos inputs de climatiza√ß√£o
 * @returns {void}
 */
function fillClimatizationInputs(roomElement, inputsData) {
    if (!roomElement || !inputsData) {
        console.error('‚ùå Elemento da sala ou dados inv√°lidos para preenchimento');
        return;
    }

    console.log(`üîÑ Preenchendo inputs de climatiza√ß√£o:`, inputsData);

    const textInputs = roomElement.querySelectorAll('.clima-input[type="text"], .clima-input[type="number"], .clima-input[data-field]');
    textInputs.forEach(input => {
        const field = input.getAttribute('data-field');
        if (!field || inputsData[field] === undefined) return;

        let value = inputsData[field];
        
        // ‚úÖ CORRE√á√ÉO: Converter boolean e valores inv√°lidos para n√∫mero
        if (input.type === 'number') {
            if (value === false || value === 'false' || value === null || value === '') {
                value = 0;
            }
            if (value === true || value === 'true') {
                value = 1;
            }
            
            // Garantir que √© um n√∫mero v√°lido
            const numericValue = parseFloat(value);
            value = isNaN(numericValue) ? 0 : numericValue;
        }
        
        input.value = value;
        console.log(`‚úÖ Campo ${field} preenchido: ${value}`);

        setTimeout(() => {
            const event = new Event('change', { bubbles: true });
            input.dispatchEvent(event);
        }, 50);
    });

    const selectInputs = roomElement.querySelectorAll('select.clima-input[data-field]');
    selectInputs.forEach(select => {
        const field = select.getAttribute('data-field');
        if (!field || inputsData[field] === undefined) return;

        const value = inputsData[field];
        select.value = value;
        console.log(`‚úÖ Select ${field} preenchido: ${value}`);

        setTimeout(() => {
            const event = new Event('change', { bubbles: true });
            select.dispatchEvent(event);
        }, 50);
    });

    if (inputsData.pressurizacao !== undefined) {
        const pressurizacaoValue = inputsData.pressurizacao ? 'sim' : 'nao';
        const roomId = roomElement.dataset.roomId;
        const radioName = `pressurizacao-${roomId}`;
        const radioToCheck = roomElement.querySelector(`input[name="${radioName}"][value="${pressurizacaoValue}"]`);
        
        if (radioToCheck) {
            radioToCheck.checked = true;
            console.log(`‚úÖ Pressuriza√ß√£o definida: ${pressurizacaoValue}`);
            
            setTimeout(() => {
                const event = new Event('change', { bubbles: true });
                radioToCheck.dispatchEvent(event);
            }, 50);
        }
    }

    console.log(`‚úÖ Inputs de climatiza√ß√£o preenchidos para sala ${roomElement.dataset.roomId}`);
}

/**
 * Preenche os dados de ganhos t√©rmicos nos elementos da sala
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Object} thermalGainsData - Dados de ganhos t√©rmicos
 * @returns {void}
 */
function fillThermalGainsData(roomElement, thermalGainsData) {
    if (!roomElement || !thermalGainsData) {
        console.error('‚ùå Elemento da sala ou dados de ganhos t√©rmicos inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo ganhos t√©rmicos para sala ${roomId}:`, thermalGainsData);

    const gainSelectors = {
        'total-ganhos-w': `#total-ganhos-w-${roomId}`,
        'total-tr': `#total-tr-${roomId}`,
        'total-externo': `#total-externo-${roomId}`,
        'total-divisoes': `#total-divisoes-${roomId}`,
        'total-piso': `#total-piso-${roomId}`,
        'total-iluminacao': `#total-iluminacao-${roomId}`,
        'total-dissi': `#total-dissi-${roomId}`,
        'total-pessoas': `#total-pessoas-${roomId}`,
        'total-ar-sensivel': `#total-ar-sensivel-${roomId}`,
        'total-ar-latente': `#total-ar-latente-${roomId}`
    };

    Object.entries(gainSelectors).forEach(([key, selector]) => {
        const element = document.querySelector(selector);
        if (element && thermalGainsData[key] !== undefined) {
            element.textContent = thermalGainsData[key];
            console.log(`‚úÖ ${key} preenchido: ${thermalGainsData[key]}`);
        }
    });

    console.log(`‚úÖ Ganhos t√©rmicos preenchidos para sala ${roomId}`);
}

/**
 * Preenche os dados de capacidade de refrigera√ß√£o da sala
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Object} capacityData - Dados de capacidade
 * @returns {void}
 */
function fillCapacityData(roomElement, capacityData) {
    if (!roomElement || !capacityData) {
        console.error('‚ùå Elemento da sala ou dados de capacidade inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo dados de capacidade para sala ${roomId}:`, capacityData);

    const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`);
    if (fatorSegurancaInput && capacityData.fatorSeguranca !== undefined) {
        fatorSegurancaInput.value = capacityData.fatorSeguranca;
        console.log(`‚úÖ Fator seguran√ßa preenchido: ${capacityData.fatorSeguranca}`);
    }

    const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`);
    if (capacidadeUnitariaSelect && capacityData.capacidadeUnitaria !== undefined) {
        capacidadeUnitariaSelect.value = capacityData.capacidadeUnitaria;
        console.log(`‚úÖ Capacidade unit√°ria preenchida: ${capacityData.capacidadeUnitaria}`);
    }

    const backupSelect = roomElement.querySelector('.backup-select');
    if (backupSelect && capacityData.backup !== undefined) {
        backupSelect.value = capacityData.backup;
        console.log(`‚úÖ Backup preenchido: ${capacityData.backup}`);
    }

    console.log(`‚úÖ Dados de capacidade preenchidos para sala ${roomId}`);
}

/**
 * Preenche as configura√ß√µes de instala√ß√£o da sala
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Object} configData - Dados de configura√ß√£o
 * @returns {void}
 */
function fillConfigurationData(roomElement, configData) {
    if (!roomElement || !configData) {
        console.error('‚ùå Elemento da sala ou dados de configura√ß√£o inv√°lidos');
        return;
    }

    const roomId = roomElement.dataset.roomId;
    console.log(`üîÑ Preenchendo configura√ß√µes para sala ${roomId}:`, configData);

    if (configData.opcoesInstalacao && Array.isArray(configData.opcoesInstalacao)) {
        configData.opcoesInstalacao.forEach(optionValue => {
            const checkbox = roomElement.querySelector(`input[name^="opcoesInstalacao-"][value="${optionValue}"]`);
            if (checkbox) {
                checkbox.checked = true;
                console.log(`‚úÖ Checkbox marcado: ${optionValue}`);
            }
        });
    }

    console.log(`‚úÖ Configura√ß√µes preenchidas para sala ${roomId}`);
}


/**
 * Encontra se√ß√£o de m√°quinas pelo t√≠tulo
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @returns {HTMLElement|null} Elemento da se√ß√£o de m√°quinas
 */
function findMachinesSection(roomElement) {
    if (!roomElement) return null;
    
    // Buscar todas as se√ß√µes .section-block
    const allSections = roomElement.querySelectorAll('.section-block');
    
    // Encontrar a que tem "M√°quinas" no t√≠tulo
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes('M√°quinas')) {
            return section;
        }
    }
    
    return null;
}

// ‚úÖ FUN√á√ÉO AUXILIAR: Encontrar se√ß√£o por t√≠tulo
function findSectionByTitle(roomElement, titleText) {
    if (!roomElement) return null;
    
    const allSections = roomElement.querySelectorAll('.section-block');
    
    for (let section of allSections) {
        const title = section.querySelector('.section-title');
        if (title && title.textContent.includes(titleText)) {
            return section;
        }
    }
    
    return null;
}

/**
 * Garante que todas as se√ß√µes da sala est√£o criadas e inicializadas
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @returns {Promise<boolean>} True se todas as se√ß√µes foram criadas
 */
async function ensureAllRoomSections(roomElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala inv√°lido');
        return false;
    }

    const obraId = roomElement.dataset.obraId;
    const projectId = roomElement.dataset.projectId; 
    const roomName = roomElement.dataset.roomName;
    const roomId = roomElement.dataset.roomId;

    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido: "${roomId}" para sala ${roomName}`);
        return false;
    }

    console.log(`üî® Verificando se√ß√µes da sala ${roomName} (ID: ${roomId})`);

    // ‚úÖ CORRE√á√ÉO: Usar as novas fun√ß√µes para verificar se√ß√µes
    const climatizationSection = findSectionByTitle(roomElement, 'Climatiza√ß√£o');
    const machinesSection = findMachinesSection(roomElement);
    const configurationSection = findSectionByTitle(roomElement, 'Configura√ß√£o');

    if (climatizationSection && machinesSection && configurationSection) {
        console.log(`‚úÖ Todas as se√ß√µes j√° existem para sala ${roomName}`);
        return true;
    }

    console.log(`üîÑ Criando se√ß√µes faltantes para sala ${roomName}`);

    try {
        const roomContent = roomElement.querySelector('.room-content');
        if (!roomContent) {
            console.error(`‚ùå Container de conte√∫do da sala n√£o encontrado`);
            return false;
        }

        if (!climatizationSection) {
            console.log(`üèóÔ∏è Criando todas as se√ß√µes para sala ${roomName}`);

            if (typeof window.buildClimatizationSection !== 'function' || 
                typeof buildMachinesSection !== 'function' ||
                typeof window.buildConfigurationSection !== 'function') {
                console.error('‚ùå Fun√ß√µes de constru√ß√£o de se√ß√µes n√£o dispon√≠veis');
                return false;
            }

            // Criar se√ß√£o de climatiza√ß√£o
            const climatizationHTML = await window.buildClimatizationSection(obraId, projectId, roomName, roomId);
            if (climatizationHTML) {
                roomContent.insertAdjacentHTML('beforeend', climatizationHTML);
                console.log(`‚úÖ Se√ß√£o de climatiza√ß√£o criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Criar se√ß√£o de m√°quinas
            const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
            if (machinesHTML) {
                roomContent.insertAdjacentHTML('beforeend', machinesHTML);
                console.log(`‚úÖ Se√ß√£o de m√°quinas criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 300));

            // Criar se√ß√£o de configura√ß√£o
            const configurationHTML = await window.buildConfigurationSection(obraId, projectId, roomName, roomId);
            if (configurationHTML) {
                roomContent.insertAdjacentHTML('beforeend', configurationHTML);
                console.log(`‚úÖ Se√ß√£o de configura√ß√£o criada`);
            }

            await new Promise(resolve => setTimeout(resolve, 500));

            console.log(`‚úÖ Todas as se√ß√µes criadas para sala ${roomName}`);
            return true;
        }

        // Criar apenas se√ß√µes faltantes
        if (climatizationSection && !machinesSection) {
            console.log(`üî® Criando apenas se√ß√£o de m√°quinas para sala ${roomName}`);

            const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
            if (machinesHTML) {
                climatizationSection.insertAdjacentHTML('afterend', machinesHTML);
                console.log(`‚úÖ Se√ß√£o de m√°quinas criada`);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                return true;
            }
        }

        console.log(`‚ùå N√£o foi poss√≠vel criar todas as se√ß√µes para sala ${roomName}`);
        return false;

    } catch (error) {
        console.error(`‚ùå Erro ao criar se√ß√µes da sala ${roomName}:`, error);
        return false;
    }
}


/**
 * Garante que a se√ß√£o de m√°quinas existe e est√° inicializada - VERS√ÉO CORRIGIDA
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @returns {Promise<HTMLElement>} Elemento da se√ß√£o de m√°quinas
 */
async function ensureMachinesSection(roomElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala inv√°lido');
        return null;
    }

    const obraId = roomElement.dataset.obraId;
    const projectId = roomElement.dataset.projectId;
    const roomName = roomElement.dataset.roomName;
    const roomId = roomElement.dataset.roomId;

    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido: "${roomId}" para sala ${roomName}`);
        return null;
    }

    console.log(`üî® Garantindo se√ß√£o de m√°quinas para sala ${roomName} (ID: ${roomId})`);

    // Primeiro garantir que todas as se√ß√µes existem
    const sectionsReady = await ensureAllRoomSections(roomElement);
    if (!sectionsReady) {
        console.error(`‚ùå N√£o foi poss√≠vel garantir todas as se√ß√µes para sala ${roomName}`);
        return null;
    }

    // ‚úÖ CORRE√á√ÉO: Buscar por .section-block que contenha "M√°quinas" no t√≠tulo
    let machinesSection = findMachinesSection(roomElement);
    
    if (machinesSection) {
        console.log(`‚úÖ Se√ß√£o de m√°quinas encontrada para sala ${roomName}`);
        return machinesSection;
    }

    // Se ainda n√£o existe, tentar criar apenas a se√ß√£o de m√°quinas
    console.log(`üîÑ Tentando criar apenas se√ß√£o de m√°quinas para sala ${roomName}`);

    // Encontrar a √∫ltima se√ß√£o para inserir ap√≥s ela
    const lastSection = roomElement.querySelector('.section-block:last-child') || 
                       roomElement.querySelector('.room-content > :last-child');

    if (!lastSection) {
        console.error(`‚ùå Nenhuma se√ß√£o encontrada para inserir m√°quinas`);
        return null;
    }

    if (typeof buildMachinesSection !== 'function') {
        console.error('‚ùå Fun√ß√£o buildMachinesSection n√£o dispon√≠vel');
        return null;
    }

    try {
        const machinesHTML = await buildMachinesSection(obraId, projectId, roomName, roomId);
        if (!machinesHTML) {
            console.error('‚ùå HTML da se√ß√£o de m√°quinas n√£o gerado');
            return null;
        }

        lastSection.insertAdjacentHTML('afterend', machinesHTML);
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // ‚úÖ CORRE√á√ÉO: Usar a nova fun√ß√£o para encontrar a se√ß√£o
        machinesSection = findMachinesSection(roomElement);
        if (machinesSection) {
            console.log(`‚úÖ Se√ß√£o de m√°quinas criada com sucesso para sala ${roomName}`);
            return machinesSection;
        } else {
            console.error(`‚ùå Se√ß√£o de m√°quinas n√£o encontrada ap√≥s cria√ß√£o`);
            return null;
        }

    } catch (error) {
        console.error(`‚ùå Erro ao criar se√ß√£o de m√°quinas:`, error);
        return null;
    }
}

/**
 * Preenche os dados das m√°quinas de uma sala - VERS√ÉO CORRIGIDA
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Array} machinesData - Array de dados das m√°quinas
 * @returns {Promise<boolean>} True se o preenchimento foi bem-sucedido
 */
async function fillMachinesData(roomElement, machinesData) {
    if (!roomElement || !machinesData || !Array.isArray(machinesData)) {
        console.error('‚ùå Elemento da sala ou dados de m√°quinas inv√°lidos');
        return false;
    }

    const roomId = roomElement.dataset.roomId;
    const roomName = roomElement.dataset.roomName;
    
    console.log(`üîÑ Preenchendo ${machinesData.length} m√°quina(s) para sala ${roomName} (ID: ${roomId})`);

    // ‚úÖ CORRE√á√ÉO: Verificar se h√° m√°quinas para preencher
    if (machinesData.length === 0) {
        console.log(`‚ÑπÔ∏è Nenhuma m√°quina para preencher na sala ${roomName}`);
        return true; // Retorna true porque n√£o h√° erro, s√≥ n√£o h√° m√°quinas
    }

    try {
        const machinesSection = await ensureMachinesSection(roomElement);
        if (!machinesSection) {
            console.error(`‚ùå N√£o foi poss√≠vel criar/obter se√ß√£o de m√°quinas para sala ${roomName}`);
            return false;
        }

        const machinesContainer = machinesSection.querySelector('.machines-container');
        if (!machinesContainer) {
            console.error(`‚ùå Container de m√°quinas n√£o encontrado para sala ${roomName}`);
            return false;
        }

        console.log(`‚úÖ Container de m√°quinas encontrado`);

        // Limpar m√°quinas existentes
        const existingMachines = machinesContainer.querySelectorAll('.climatization-machine, .machine-block');
        if (existingMachines.length > 0) {
            console.log(`üóëÔ∏è Removendo ${existingMachines.length} m√°quina(s) existente(s)`);
            existingMachines.forEach(machine => machine.remove());
        }

        let successCount = 0;

        // Adicionar cada m√°quina
        for (let i = 0; i < machinesData.length; i++) {
            const machineData = machinesData[i];
            
            if (!machineData || !machineData.tipo) {
                console.warn(`‚ö†Ô∏è Dados da m√°quina ${i} inv√°lidos:`, machineData);
                continue;
            }

            console.log(`ü§ñ [${i + 1}/${machinesData.length}] Adicionando m√°quina: ${machineData.tipo}`);

            try {
                // ‚úÖ CORRE√á√ÉO: Usar addMachine com retry
                let machineAdded = false;
                let retryCount = 0;
                
                while (!machineAdded && retryCount < 3) {
                    machineAdded = await addMachine(roomId, machineData.tipo);
                    
                    if (!machineAdded) {
                        retryCount++;
                        console.log(`üîÑ Tentativa ${retryCount}/3 para adicionar m√°quina ${machineData.tipo}`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                if (!machineAdded) {
                    console.error(`‚ùå Falha ao adicionar m√°quina ${machineData.tipo} ap√≥s ${retryCount} tentativas`);
                    continue;
                }

                console.log(`‚úÖ M√°quina ${machineData.tipo} adicionada, aguardando renderiza√ß√£o...`);

                // Aguardar renderiza√ß√£o completa
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Encontrar a m√°quina mais recente
                const machineElements = machinesContainer.querySelectorAll('.climatization-machine');
                const lastMachine = machineElements[machineElements.length - 1];
                
                if (!lastMachine) {
                    console.error(`‚ùå Elemento da m√°quina n√£o encontrado ap√≥s adi√ß√£o`);
                    continue;
                }

                console.log(`‚úÖ Elemento da m√°quina encontrado, preenchendo dados...`);

                // Preencher dados da m√°quina
                const populated = await populateMachineData(lastMachine, machineData);
                if (populated) {
                    successCount++;
                    console.log(`üéâ M√°quina ${machineData.tipo} preenchida com sucesso`);
                } else {
                    console.error(`‚ùå Falha ao preencher dados da m√°quina ${machineData.tipo}`);
                }

            } catch (error) {
                console.error(`‚ùå Erro ao processar m√°quina ${machineData.tipo}:`, error);
            }

            // Pequena pausa entre m√°quinas
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        console.log(`‚úÖ ${successCount}/${machinesData.length} m√°quina(s) preenchida(s) com sucesso para sala ${roomName}`);
        
        // ‚úÖ CORRE√á√ÉO: Retorna true se pelo menos uma m√°quina foi preenchida, ou se n√£o havia m√°quinas
        return successCount > 0 || machinesData.length === 0;

    } catch (error) {
        console.error(`‚ùå Erro cr√≠tico ao preencher m√°quinas para sala ${roomName}:`, error);
        return false;
    }
}


/**
 * üéØ FUN√á√ïES DE PREENCHIMENTO HIER√ÅRQUICO
 */


/**
 * Preenche os dados de uma obra a partir do JSON
 * @param {Object} obraData - Dados da obra do JSON
 * @returns {Promise<void>}
 */
async function populateObraData(obraData) {
    if (!obraData || typeof obraData !== 'object') {
        console.error('‚ùå Dados inv√°lidos recebidos para populateObraData:', obraData);
        return;
    }
    
    const hasValidId = obraData.id && obraData.id !== "" && obraData.id !== "null" && obraData.id !== "undefined";
    const hasValidName = obraData.nome && obraData.nome !== "" && obraData.nome !== "null" && obraData.nome !== "undefined";
    
    if (!hasValidId && !hasValidName) {
        console.error('‚ùå Dados da obra sem ID ou nome v√°lido:', obraData);
        return;
    }

    const obraName = obraData.nome || `Obra-${obraData.id}`;
    const obraId = obraData.id;
    
    console.log(`üîÑ Preenchendo obra "${obraName}" com dados do JSON`, { 
        id: obraId, 
        nome: obraName, 
        projetos: obraData.projetos?.length || 0 
    });

    let obraElement = document.querySelector(`[data-obra-id="${obraId}"]`);
    
    if (!obraElement) {
        console.log(`üî® Criando nova obra: "${obraName}"`);
        
        const obraHTML = buildObraHTML(obraName, obraId, true);
        
        const container = document.getElementById("projects-container");
        if (container) {
            container.insertAdjacentHTML("beforeend", obraHTML);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            obraElement = document.querySelector(`[data-obra-id="${obraId}"]`);
            console.log(`‚úÖ Obra criada no DOM: ${obraName} com bot√£o "Atualizar Obra"`);
        } else {
            console.error('‚ùå Container de projetos n√£o encontrado');
            return;
        }
    } else {
        console.log(`‚úÖ Obra j√° existe no DOM: ${obraName}`, obraElement);
        updateObraButtonAfterSave(obraName, obraId);
    }

    if (!obraElement) {
        console.error(`‚ùå Elemento da obra n√£o encontrado no DOM ap√≥s cria√ß√£o: ${obraId}`);
        return;
    }

    console.log(`‚úÖ Elemento da obra confirmado:`, {
        element: obraElement,
        dataset: obraElement.dataset
    });

    if (typeof window.createEmptyProject !== 'function' || typeof window.createEmptyRoom !== 'function') {
        console.error('‚ùå Fun√ß√µes necess√°rias n√£o dispon√≠veis:', {
            createEmptyProject: typeof window.createEmptyProject,
            createEmptyRoom: typeof window.createEmptyRoom
        });
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (typeof window.createEmptyProject !== 'function' || typeof window.createEmptyRoom !== 'function') {
            console.error('‚ùå Fun√ß√µes ainda n√£o dispon√≠veis ap√≥s espera');
            return;
        }
    }

    console.log(`üîß Fun√ß√µes dispon√≠veis: createEmptyProject: function, createEmptyRoom: function`);

    const projectsContainer = obraElement.querySelector('.projects-container');
    if (projectsContainer) {
        const existingProjects = projectsContainer.querySelectorAll('.project-block');
        if (existingProjects.length > 0) {
            console.log(`üóëÔ∏è Removendo ${existingProjects.length} projetos existentes antes do preenchimento`);
            existingProjects.forEach(project => project.remove());
        }
    }

    const projetos = obraData.projetos || [];
    console.log(`üìÅ Processando ${projetos.length} projeto(s) para a obra "${obraName}"`);
    
    for (let i = 0; i < projetos.length; i++) {
        const projectData = projetos[i];
        if (!projectData || !projectData.nome) {
            console.warn(`‚ö†Ô∏è Projeto ${i} inv√°lido ou sem nome:`, projectData);
            continue;
        }
        
        const projectName = projectData.nome;
        const projectId = projectData.id;
        
        console.log(`üìÅ [${i + 1}/${projetos.length}] Criando projeto: ${projectName} (ID: ${projectId})`);

        try {
            console.log(`üéØ Chamando createEmptyProject para obra "${obraName}" (${obraId}), projeto "${projectName}" (${projectId})`);
            
            const projectCreated = await window.createEmptyProject(obraId, obraName, projectId, projectName);
            
            if (!projectCreated) {
                console.error(`‚ùå Falha ao criar projeto ${projectName}`);
                continue;
            }

            const projectElement = await waitForElement(`[data-obra-id="${obraId}"][data-project-id="${projectId}"]`, 5000);
            
            if (!projectElement) {
                console.error(`‚ùå Projeto ${projectName} n√£o encontrado no DOM ap√≥s cria√ß√£o`);
                
                const allProjects = document.querySelectorAll('.project-block');
                console.log(`üîç Projetos no DOM: ${allProjects.length}`);
                allProjects.forEach((proj, idx) => {
                    console.log(`  ${idx + 1}. Projeto: "${proj.dataset.projectName}", ID: "${proj.dataset.projectId}", Obra: "${proj.dataset.obraId}"`);
                });
                continue;
            }

            console.log(`‚úÖ Projeto criado e encontrado: ${projectName}`, {
                element: projectElement,
                dataset: projectElement.dataset
            });

            await populateProjectData(projectElement, projectData, obraId, obraName);

        } catch (error) {
            console.error(`‚ùå Erro ao criar projeto ${projectName}:`, error);
        }
        
        await new Promise(resolve => setTimeout(resolve, 200));
    }

    console.log(`‚úÖ Obra "${obraName}" preenchida com sucesso - ${projetos.length} projeto(s) processado(s)`);
}

/**
 * Preenche os dados de um projeto a partir do JSON
 * @param {HTMLElement} projectElement - Elemento do projeto
 * @param {Object} projectData - Dados do projeto do JSON
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} obraName - Nome da obra
 * @returns {Promise<void>}
 */
async function populateProjectData(projectElement, projectData, obraId, obraName) {
    const projectName = projectData.nome;
    const projectId = projectData.id;
    
    console.log(`üéØ Preenchendo projeto: ${projectName}`, { 
        salas: projectData.salas?.length,
        obraId: obraId,
        projectId: projectId
    });

    console.log(`‚úÖ Projeto encontrado:`, projectElement.dataset);

    const roomsContainer = projectElement.querySelector('.rooms-container');
    if (roomsContainer) {
        const existingRooms = roomsContainer.querySelectorAll('.room-block');
        if (existingRooms.length > 0) {
            console.log(`üóëÔ∏è Removendo ${existingRooms.length} salas existentes antes do preenchimento`);
            existingRooms.forEach(room => room.remove());
        }
    }

    const salas = projectData.salas || [];
    console.log(`üö™ Processando ${salas.length} sala(s) para o projeto "${projectName}"`);
    
    for (let i = 0; i < salas.length; i++) {
        const roomData = salas[i];
        const roomName = roomData.nome;
        const roomId = roomData.id;
        
        if (!roomName || !roomId) {
            console.warn(`‚ö†Ô∏è Sala ${i} inv√°lida ou sem nome/ID:`, roomData);
            continue;
        }

        console.log(`üö™ [${i + 1}/${salas.length}] Criando sala: ${roomName} (ID: ${roomId})`);

        try {
            if (typeof window.createEmptyRoom !== 'function') {
                console.error('‚ùå createEmptyRoom n√£o dispon√≠vel');
                continue;
            }

            const roomCreated = await window.createEmptyRoom(obraId, projectId, roomName, roomId);
            
            if (!roomCreated) {
                console.error(`‚ùå Falha ao criar sala ${roomName}`);
                continue;
            }

            const roomElement = await waitForElement(`[data-room-id="${roomId}"]`, 3000);
            
            if (!roomElement) {
                console.error(`‚ùå Sala ${roomName} n√£o encontrada no DOM ap√≥s cria√ß√£o`);
                
                const allRooms = document.querySelectorAll('.room-block');
                console.log(`üîç Salas no DOM: ${allRooms.length}`);
                allRooms.forEach((room, idx) => {
                    console.log(`  ${idx + 1}. Sala: "${room.dataset.roomName}", ID: "${room.dataset.roomId}", Projeto: "${room.dataset.projectId}"`);
                });
                continue;
            }

            console.log(`‚úÖ Sala criada e encontrada: ${roomName}`, {
                element: roomElement,
                dataset: roomElement.dataset
            });

            await populateRoomData(roomElement, roomData);

        } catch (error) {
            console.error(`‚ùå Falha ao criar sala ${roomName}:`, error);
        }
        
        await new Promise(resolve => setTimeout(resolve, 300));
    }

    console.log(`‚úÖ Projeto "${projectName}" preenchido com sucesso - ${salas.length} sala(s) processada(s)`);
}

/**
 * Preenche uma sala espec√≠fica dentro de um projeto
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {Object} roomData - Dados da sala do JSON
 * @returns {Promise<boolean>} True se o preenchimento foi bem-sucedido
 */
async function populateRoomData(roomElement, roomData) {
    if (!roomElement || !roomData) {
        console.error('‚ùå Elemento da sala ou dados inv√°lidos');
        return false;
    }

    const roomId = roomElement.dataset.roomId;
    const roomName = roomElement.dataset.roomName;
    
    // ‚úÖ CORRE√á√ÉO: Validar roomId antes de prosseguir
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`‚ùå Room ID inv√°lido no populateRoomData: "${roomId}"`);
        console.log('üîç Elemento da sala:', roomElement);
        console.log('üîç Dataset:', roomElement.dataset);
        return false;
    }
    
    console.log(`üîÑ Preenchendo sala "${roomName}" (ID: ${roomId})`, roomData);

    try {
        // ‚úÖ CORRE√á√ÉO: Garantir que todas as se√ß√µes existam antes de preencher
        console.log(`üèóÔ∏è Garantindo que todas as se√ß√µes existem para sala ${roomName}`);
        const sectionsReady = await ensureAllRoomSections(roomElement);
        if (!sectionsReady) {
            console.error(`‚ùå N√£o foi poss√≠vel garantir se√ß√µes para sala ${roomName}`);
            return false;
        }

        const roomTitle = roomElement.querySelector('.room-title');
        if (roomTitle && roomData.nome) {
            roomTitle.textContent = roomData.nome;
            console.log(`‚úÖ T√≠tulo da sala atualizado: ${roomData.nome}`);
        }

        if (roomData.inputs) {
            console.log(`üå°Ô∏è Preenchendo inputs de climatiza√ß√£o para sala ${roomName}`);
            fillClimatizationInputs(roomElement, roomData.inputs);
        }

        if (roomData.ganhosTermicos) {
            console.log(`üìä Preenchendo ganhos t√©rmicos para sala ${roomName}`);
            fillThermalGainsData(roomElement, roomData.ganhosTermicos);
        }

        if (roomData.capacidade) {
            console.log(`‚ö° Preenchendo dados de capacidade para sala ${roomName}`);
            fillCapacityData(roomElement, roomData.capacidade);
        }

        if (roomData.configuracao) {
            console.log(`‚öôÔ∏è Preenchendo configura√ß√µes para sala ${roomName}`);
            fillConfigurationData(roomElement, roomData.configuracao);
        }

        if (roomData.maquinas && Array.isArray(roomData.maquinas)) {
            console.log(`ü§ñ Agendando preenchimento de ${roomData.maquinas.length} m√°quina(s) para sala ${roomName}`);
            
            // ‚úÖ Aumentar o tempo de espera para garantir que tudo esteja carregado
            setTimeout(async () => {
                try {
                    console.log(`üöÄ Iniciando preenchimento de m√°quinas para sala ${roomName}`);
                    
                    // ‚úÖ Verificar novamente se as se√ß√µes est√£o prontas
                    const sectionsReady = await ensureAllRoomSections(roomElement);
                    if (!sectionsReady) {
                        console.error(`‚ùå Se√ß√µes n√£o prontas para preencher m√°quinas`);
                        return;
                    }
                    
                    const success = await fillMachinesData(roomElement, roomData.maquinas);
                    
                    if (success) {
                        console.log(`üéâ Todas as m√°quinas preenchidas com sucesso para sala ${roomName}`);
                    } else {
                        console.error(`‚ùå Falha ao preencher m√°quinas para sala ${roomName}`);
                    }
                } catch (error) {
                    console.error(`üí• Erro ao preencher m√°quinas para sala ${roomName}:`, error);
                }
            }, 3000); // ‚úÖ Aumentado para 3 segundos
        }

        console.log(`‚úÖ Sala "${roomName}" preenchida com sucesso`);
        return true;

    } catch (error) {
        console.error(`‚ùå Erro ao preencher sala "${roomName}":`, error);
        return false;
    }
}

/**
 * Preenche os dados individuais de uma m√°quina
 * @param {HTMLElement} machineElement - Elemento HTML da m√°quina
 * @param {Object} machineData - Dados da m√°quina
 * @returns {Promise<boolean>}
 */
async function populateMachineData(machineElement, machineData) {
    if (!machineElement || !machineData) {
        console.error('‚ùå Elemento da m√°quina ou dados inv√°lidos');
        return false;
    }

    console.log(`üîß Preenchendo dados da m√°quina:`, machineData);

    try {
        const machineId = machineElement.dataset.machineId;

        // 1. DEFINIR TIPO (se dispon√≠vel)
        const typeSelect = machineElement.querySelector('.machine-type-select');
        if (typeSelect && machineData.tipo) {
            typeSelect.value = machineData.tipo;
            const typeEvent = new Event('change', { bubbles: true });
            typeSelect.dispatchEvent(typeEvent);
            console.log(`‚úÖ Tipo definido: ${machineData.tipo}`);
            
            // Aguardar processamento do tipo
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // 2. DEFINIR CAPACIDADE (se dispon√≠vel e habilitado)
        const powerSelect = machineElement.querySelector('.machine-power-select');
        if (powerSelect && machineData.potencia) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (powerSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da capacidade... (${attempts}/6)`);
            }
            
            if (!powerSelect.disabled) {
                const powerOption = Array.from(powerSelect.options).find(opt => 
                    opt.text.includes(machineData.potencia) || 
                    opt.value.includes(machineData.potencia) ||
                    opt.text.toLowerCase().includes(machineData.potencia.toLowerCase())
                );
                
                if (powerOption) {
                    powerSelect.value = powerOption.value;
                    const powerEvent = new Event('change', { bubbles: true });
                    powerSelect.dispatchEvent(powerEvent);
                    console.log(`‚úÖ Capacidade definida: ${powerOption.value}`);
                    
                    // Aguardar processamento da capacidade
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    console.log(`‚ö†Ô∏è Capacidade "${machineData.potencia}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de capacidade permanece desabilitado`);
            }
        }

        // 3. DEFINIR TENS√ÉO (se dispon√≠vel e habilitado)
        const voltageSelect = machineElement.querySelector('.machine-voltage-select');
        if (voltageSelect && machineData.tensao) {
            // Aguardar at√© que o select esteja habilitado (m√°x 3 segundos)
            let attempts = 0;
            while (voltageSelect.disabled && attempts < 6) {
                await new Promise(resolve => setTimeout(resolve, 500));
                attempts++;
                console.log(`‚è≥ Aguardando habilita√ß√£o da tens√£o... (${attempts}/6)`);
            }
            
            if (!voltageSelect.disabled) {
                const voltageOption = Array.from(voltageSelect.options).find(opt => 
                    opt.text.includes(machineData.tensao) || 
                    opt.value.includes(machineData.tensao) ||
                    opt.text.toLowerCase().includes(machineData.tensao.toLowerCase())
                );
                
                if (voltageOption) {
                    voltageSelect.value = voltageOption.value;
                    const voltageEvent = new Event('change', { bubbles: true });
                    voltageSelect.dispatchEvent(voltageEvent);
                    console.log(`‚úÖ Tens√£o definida: ${voltageOption.value}`);
                } else {
                    console.log(`‚ö†Ô∏è Tens√£o "${machineData.tensao}" n√£o encontrada`);
                }
            } else {
                console.log(`‚ö†Ô∏è Select de tens√£o permanece desabilitado`);
            }
        }

        // 4. DEFINIR OP√á√ïES SELECIONADAS (se dispon√≠veis)
        if (machineData.opcoesSelecionadas && Array.isArray(machineData.opcoesSelecionadas)) {
            // Aguardar carregamento das op√ß√µes
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const optionsContainer = machineElement.querySelector('.options-grid');
            
            if (optionsContainer) {
                const allCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                console.log(`üîç Encontrados ${allCheckboxes.length} checkboxes de op√ß√µes`);

                let optionsMarked = 0;
                machineData.opcoesSelecionadas.forEach(optionObj => {
                    // ‚úÖ CORRE√á√ÉO: Suporta tanto array de strings quanto array de objetos
                    let optionName;
                    if (typeof optionObj === 'string') {
                        optionName = optionObj;
                    } else if (typeof optionObj === 'object') {
                        optionName = optionObj.name || optionObj.originalName;
                    }
                    
                    if (!optionName) {
                        console.log(`‚ö†Ô∏è Op√ß√£o inv√°lida:`, optionObj);
                        return;
                    }

                    console.log(`Procurando op√ß√£o: "${optionName}"`);
                    
                    // Buscar pelo data-option-name (mais confi√°vel)
                    const checkbox = Array.from(allCheckboxes).find(cb => {
                        const dataName = cb.getAttribute('data-option-name');
                        return dataName === optionName;
                    });
                    
                    if (checkbox) {
                        checkbox.checked = true;
                        const checkboxEvent = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(checkboxEvent);
                        optionsMarked++;
                        console.log(`‚úÖ Op√ß√£o marcada: ${optionName}`);
                    } else {
                        console.log(`‚ùå Op√ß√£o n√£o encontrada: "${optionName}"`);
                        
                        // Debug: tentar encontrar por texto do label
                        const allOptions = optionsContainer.querySelectorAll('.option-item');
                        const foundByText = Array.from(allOptions).find(optionItem => {
                            const nameElement = optionItem.querySelector('.option-name');
                            return nameElement && nameElement.textContent.includes(optionName);
                        });
                        
                        if (foundByText) {
                            const checkboxInItem = foundByText.querySelector('input[type="checkbox"]');
                            if (checkboxInItem) {
                                checkboxInItem.checked = true;
                                const checkboxEvent = new Event('change', { bubbles: true });
                                checkboxInItem.dispatchEvent(checkboxEvent);
                                optionsMarked++;
                                console.log(`‚úÖ Op√ß√£o marcada (por texto): ${optionName}`);
                            }
                        }
                    }
                });
                
                console.log(`üìä Op√ß√µes marcadas: ${optionsMarked}/${machineData.opcoesSelecionadas.length}`);
            } else {
                console.log(`‚ö†Ô∏è Container de op√ß√µes n√£o encontrado`);
            }
        }

        // 5. DEFINIR PRE√áOS (se dispon√≠veis)
        if (machineData.precoBase !== undefined) {
            const basePriceElement = document.getElementById(`base-price-${machineId}`);
            if (basePriceElement) {
                basePriceElement.textContent = `R$ ${machineData.precoBase.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo base definido: R$ ${machineData.precoBase}`);
            }
        }

        if (machineData.precoTotal !== undefined) {
            const totalPriceElement = document.getElementById(`total-price-${machineId}`);
            if (totalPriceElement) {
                totalPriceElement.textContent = `R$ ${machineData.precoTotal.toLocaleString('pt-BR')}`;
                console.log(`‚úÖ Pre√ßo total definido: R$ ${machineData.precoTotal}`);
            }
        }

        // 6. DEFINIR NOME (se dispon√≠vel)
        if (machineData.nome) {
            const nameInput = machineElement.querySelector('.machine-title-editable');
            if (nameInput) {
                nameInput.value = machineData.nome;
                console.log(`‚úÖ Nome definido: ${machineData.nome}`);
            }
        }

        // 7. DISPARAR C√ÅLCULO FINAL
        setTimeout(() => {
            if (typeof calculateMachinePrice === 'function') {
                calculateMachinePrice(machineId);
                console.log('‚úÖ C√°lculo de pre√ßo finalizado');
            }
        }, 500);

        console.log(`‚úÖ Dados da m√°quina preenchidos com sucesso`);
        return true;

    } catch (error) {
        console.error(`‚ùå Erro ao preencher dados da m√°quina:`, error);
        return false;
    }
}


/**
 * üåê EXPORTA√á√ïES E COMPATIBILIDADE GLOBAL
 */

// Exporta√ß√µes para m√≥dulos ES6
export {
    // Renderiza√ß√£o
    renderObraFromData,
    renderProjectFromData,
    renderRoomFromData,
    
    // Preenchimento espec√≠fico
    fillClimatizationInputs,
    fillThermalGainsData,
    fillCapacityData,
    fillConfigurationData,
    ensureAllRoomSections,
    ensureMachinesSection, 
    fillMachinesData,           
    
    // Preenchimento hier√°rquico
    populateObraData,
    populateProjectData,
    populateRoomData,
    populateMachineData,  
    

};

// Compatibilidade global para scripts legados
if (typeof window !== 'undefined') {
    window.renderObraFromData = renderObraFromData;
    window.renderProjectFromData = renderProjectFromData;
    window.renderRoomFromData = renderRoomFromData;
    window.populateObraData = populateObraData;
    window.populateProjectData = populateProjectData;
    window.populateRoomData = populateRoomData;
    window.ensureMachinesSection = ensureMachinesSection;
    window.ensureAllRoomSections = ensureAllRoomSections;
    window.buildMachinesSection = buildMachinesSection;
    window.addMachine = addMachine;
    window.populateMachineData = populateMachineData;
    window.fillMachinesData = fillMachinesData;
}
/* ==== FIM: ui-builders.js ==== */
