#!/usr/bin/env python3
"""
Servidor Python com Encerramento Autom√°tico
Fecha quando: Ctrl+C, Fechar Navegador ou Fechar Terminal
"""

import os
import http.server
import socketserver
import json
import webbrowser
import threading
import time
import socket
import sys
import signal
from pathlib import Path
from urllib.parse import urlparse

# Vari√°vel global para controle do servidor
servidor_rodando = True

class UniversalHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """Handler 100% compat√≠vel com sua l√≥gica JavaScript"""
    
    def __init__(self, *args, **kwargs):
        self.project_root = Path.cwd()
        super().__init__(*args, directory=str(self.project_root), **kwargs)
    
    def do_GET(self):
        """Processa requisi√ß√µes GET"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path == '/projetos' or path == '/projects':
            self.handle_get_projetos()
        elif path == '/constants' or path == '/system-constants':
            self.handle_get_constants()
        elif path == '/dados':
            self.handle_get_dados()
        elif path == '/backup':
            self.handle_get_backup()
        elif path == '/machines':
            self.handle_get_machines()
        elif path == '/health-check':
            # Rota especial para verificar se servidor est√° vivo
            self.send_json_response({"status": "online", "timestamp": time.time()})
        else:
            try:
                super().do_GET()
            except Exception as e:
                self.send_error(404, f"Arquivo n√£o encontrado: {path}")
    
    def do_POST(self):
        """Processa POST - para NOVOS projetos (sem ID)"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path in ['/projetos', '/projects']:
            self.handle_post_projetos()  # NOVO projeto
        elif path == '/dados':
            self.handle_post_dados()
        elif path == '/backup':
            self.handle_post_backup()
        else:
            self.send_error(404, "Rota n√£o encontrada")
    
    def do_PUT(self):
        """Processa PUT - para ATUALIZAR projetos existentes (com ID)"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/projetos/') or path.startswith('/projects/'):
            self.handle_put_projeto()  # ATUALIZAR projeto existente
        else:
            self.send_error(404, "Rota n√£o encontrada")
    
    def handle_get_projetos(self):
        """Retorna todos os projetos do BACKUP.json"""
        try:
            backup_file = self.find_json_file('backup.json')
            
            if backup_file.exists():
                with open(backup_file, 'r', encoding='utf-8') as f:
                    backup_data = json.load(f)
                
                projetos = backup_data.get('projetos', [])
                print(f"üìä Retornando {len(projetos)} projetos")
                self.send_json_response(projetos)
            else:
                print("‚ö†Ô∏è  backup.json n√£o encontrado")
                self.send_json_response([])
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar projetos: {str(e)}")
            self.send_json_response([])
    
    def handle_get_constants(self):
        """Constants do DADOS.json"""
        try:
            dados_file = self.find_json_file('dados.json')
            
            if dados_file.exists():
                with open(dados_file, 'r', encoding='utf-8') as f:
                    dados_data = json.load(f)
                
                constants = dados_data.get('constants', {})
                print(f"‚öôÔ∏è  Retornando constants")
                self.send_json_response(constants)
            else:
                self.send_json_response({})
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar constants: {str(e)}")
            self.send_json_response({})
    
    def handle_get_machines(self):
        """Machines do DADOS.json"""
        try:
            dados_file = self.find_json_file('dados.json')
            
            if dados_file.exists():
                with open(dados_file, 'r', encoding='utf-8') as f:
                    dados_data = json.load(f)
                
                machines = dados_data.get('machines', [])
                print(f"üñ•Ô∏è  Retornando {len(machines)} m√°quinas")
                self.send_json_response(machines)
            else:
                self.send_json_response([])
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar machines: {str(e)}")
            self.send_json_response([])
    
    def handle_get_dados(self):
        """DADOS.json completo"""
        try:
            dados_file = self.find_json_file('dados.json')
            
            if dados_file.exists():
                with open(dados_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                print("üìÅ Retornando DADOS.json")
                self.send_json_response(data)
            else:
                default_data = {"constants": {}, "machines": []}
                with open(dados_file, 'w', encoding='utf-8') as f:
                    json.dump(default_data, f, indent=2)
                self.send_json_response(default_data)
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def handle_get_backup(self):
        """BACKUP.json completo"""
        try:
            backup_file = self.find_json_file('backup.json')
            
            if backup_file.exists():
                with open(backup_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                print("üíæ Retornando BACKUP.json")
                self.send_json_response(data)
            else:
                default_data = {"projetos": []}
                with open(backup_file, 'w', encoding='utf-8') as f:
                    json.dump(default_data, f, indent=2)
                self.send_json_response(default_data)
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar backup: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def handle_post_projetos(self):
        """üî• NOVO projeto (sem ID ou ID n√£o existente)"""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            novo_projeto = json.loads(post_data.decode('utf-8'))
            
            backup_file = self.find_json_file('backup.json')
            
            # L√™ backup existente
            if backup_file.exists():
                with open(backup_file, 'r', encoding='utf-8') as f:
                    backup_data = json.load(f)
            else:
                backup_data = {"projetos": []}
            
            projetos = backup_data.get('projetos', [])
            
            # üî• SEMPRE adiciona como NOVO projeto (POST = novo)
            projetos.append(novo_projeto)
            print(f"‚ûï ADICIONANDO novo projeto ID: {novo_projeto.get('id')}")
            
            backup_data['projetos'] = projetos
            
            # Salva
            with open(backup_file, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2, ensure_ascii=False)
            
            self.send_json_response(novo_projeto)
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar projeto: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def handle_put_projeto(self):
        """üî• ATUALIZA projeto existente (com ID)"""
        try:
            project_id = self.path.split('/')[-1]
            
            content_length = int(self.headers['Content-Length'])
            put_data = self.rfile.read(content_length)
            projeto_atualizado = json.loads(put_data.decode('utf-8'))
            
            backup_file = self.find_json_file('backup.json')
            
            if not backup_file.exists():
                self.send_error(404, "Arquivo de backup n√£o encontrado")
                return
            
            with open(backup_file, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            projetos = backup_data.get('projetos', [])
            projeto_encontrado = False
            
            # üî• PROCURA e ATUALIZA o projeto pelo ID
            for i, projeto in enumerate(projetos):
                if str(projeto.get('id')) == project_id:
                    projetos[i] = projeto_atualizado
                    projeto_encontrado = True
                    print(f"‚úèÔ∏è  ATUALIZANDO projeto {project_id}")
                    break
            
            if not projeto_encontrado:
                self.send_error(404, f"Projeto {project_id} n√£o encontrado")
                return
            
            backup_data['projetos'] = projetos
            
            # Salva
            with open(backup_file, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2, ensure_ascii=False)
            
            self.send_json_response(projeto_atualizado)
            
        except Exception as e:
            print(f"‚ùå Erro ao atualizar projeto: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def handle_post_dados(self):
        """Salva DADOS.json"""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            new_data = json.loads(post_data.decode('utf-8'))
            
            dados_file = self.find_json_file('dados.json')
            
            with open(dados_file, 'w', encoding='utf-8') as f:
                json.dump(new_data, f, indent=2, ensure_ascii=False)
            
            print("üíæ DADOS.json salvo")
            self.send_json_response({"status": "success", "message": "Dados salvos"})
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar dados: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def handle_post_backup(self):
        """Salva BACKUP.json"""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            new_data = json.loads(post_data.decode('utf-8'))
            
            backup_file = self.find_json_file('backup.json')
            
            with open(backup_file, 'w', encoding='utf-8') as f:
                json.dump(new_data, f, indent=2, ensure_ascii=False)
            
            print("üíæ BACKUP.json salvo")
            self.send_json_response({"status": "success", "message": "Backup salvo"})
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar backup: {str(e)}")
            self.send_error(500, f"Erro: {str(e)}")
    
    def find_json_file(self, filename):
        """Encontra arquivos JSON"""
        possible_locations = [
            self.project_root / "codigo" / "json" / filename,
            self.project_root / "json" / filename,
            self.project_root / filename,
        ]
        
        for location in possible_locations:
            if location.exists():
                return location
        
        target_dir = self.project_root / "codigo" / "json"
        target_dir.mkdir(parents=True, exist_ok=True)
        return target_dir / filename
    
    def send_json_response(self, data, status=200):
        """Envia resposta JSON com CORS"""
        self.send_response(status)
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
        
        response = json.dumps(data, ensure_ascii=False).encode('utf-8')
        self.wfile.write(response)
    
    def end_headers(self):
        """Headers CORS"""
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()
    
    def do_OPTIONS(self):
        """CORS"""
        self.send_response(200)
        self.end_headers()

def is_port_in_use(port):
    """Verifica se a porta est√° em uso"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.bind(('localhost', port))
            return False
        except socket.error:
            return True

def kill_process_on_port(port):
    """Tenta matar o processo usando a porta"""
    try:
        import subprocess
        result = subprocess.run(
            ['netstat', '-ano', '-p', 'tcp'], 
            capture_output=True, 
            text=True,
            creationflags=subprocess.CREATE_NO_WINDOW
        )
        
        for line in result.stdout.split('\n'):
            if f':{port} ' in line and 'LISTENING' in line:
                parts = line.split()
                if len(parts) >= 5:
                    pid = parts[-1]
                    print(f"üî´ Matando processo PID {pid}...")
                    subprocess.run(
                        ['taskkill', '/PID', pid, '/F'], 
                        capture_output=True,
                        creationflags=subprocess.CREATE_NO_WINDOW
                    )
                    time.sleep(2)
                    return True
        return False
    except Exception:
        return False

def find_available_port(start_port=8000, max_attempts=10):
    """Encontra uma porta dispon√≠vel"""
    for port in range(start_port, start_port + max_attempts):
        if not is_port_in_use(port):
            return port
    return None

def open_browser(port=8000):
    """Abre o navegador automaticamente"""
    time.sleep(2)
    
    # Procura o index.html na estrutura correta
    possible_paths = [
        Path.cwd() / "codigo" / "public" / "pages" / "index.html",
        Path.cwd() / "public" / "pages" / "index.html",
        Path.cwd() / "index.html",
    ]
    
    for path in possible_paths:
        if path.exists():
            relative_path = path.relative_to(Path.cwd())
            url = f"http://localhost:{port}/{relative_path}"
            print(f"üåê Abrindo: {url}")
            webbrowser.open(url)
            return
    
    # Fallback
    webbrowser.open(f"http://localhost:{port}")

def shutdown_server_async(httpd):
    """Desliga o servidor de forma ass√≠ncrona com timeout"""
    def shutdown_task():
        try:
            print("üîÑ Iniciando shutdown do servidor...")
            httpd.shutdown()
            print("‚úÖ Servidor desligado com sucesso")
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro durante shutdown: {e}")
    
    # Executa o shutdown em thread separada
    shutdown_thread = threading.Thread(target=shutdown_task, daemon=True)
    shutdown_thread.start()
    
    # Aguarda no m√°ximo 1 segundo pelo shutdown
    shutdown_thread.join(timeout=1.0)
    
    if shutdown_thread.is_alive():
        print("‚è∞ Timeout no shutdown - for√ßando encerramento...")
        # For√ßa encerramento imediato do processo
        os._exit(0)

def signal_handler(signum, frame):
    """Handler para sinais de interrup√ß√£o - MENSAGEM AMIG√ÅVEL"""
    global servidor_rodando
    print(f"\n‚èπÔ∏è  ENCERRANDO SERVIDOR...")
    print("üíæ Salvando todos os dados...")
    time.sleep(0.5)  # Pequeno delay para parecer que est√° salvando
    servidor_rodando = False
    print("‚úÖ Servidor encerrado com sucesso!")
    print("\nüí° DICA: Para usar novamente, d√™ duplo clique no arquivo 'servidor.py'")
    
    # For√ßa sa√≠da imediata
    os._exit(0)

def monitorar_navegador(port, httpd):
    """Monitora se o navegador foi fechado - 3 TENTATIVAS R√ÅPIDAS"""
    print("üîç Monitoramento ativo: servidor fechar√° automaticamente quando navegador for fechado")
    
    tentativas_falhas = 0
    max_tentativas_falhas = 3
    tempo_entre_verificacoes = 2
    
    while servidor_rodando:
        try:
            # Tenta conectar no servidor para verificar se ainda est√° ativo
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                resultado = s.connect_ex(('localhost', port))
                
                if resultado == 0:
                    # Conex√£o bem-sucedida - servidor est√° respondendo
                    tentativas_falhas = 0
                else:
                    # Falha na conex√£o
                    tentativas_falhas += 1
                    print(f"‚ö†Ô∏è  Verificando servidor... ({tentativas_falhas}/{max_tentativas_falhas})")
                
                if tentativas_falhas >= max_tentativas_falhas:
                    print("\nüåê NAVEGADOR FECHADO DETECTADO")
                    print("‚èπÔ∏è  Encerrando servidor automaticamente...")
                    break
            
            time.sleep(tempo_entre_verificacoes)
            
        except Exception as e:
            tentativas_falhas += 1
            print(f"‚ö†Ô∏è  Verificando servidor... ({tentativas_falhas}/{max_tentativas_falhas})")
            
            if tentativas_falhas >= max_tentativas_falhas:
                print("\nüåê NAVEGADOR FECHADO DETECTADO")
                print("‚èπÔ∏è  Encerrando servidor automaticamente...")
                break
    
    if servidor_rodando:
        print("üíæ Salvando dados finais...")
        time.sleep(0.5)  # Reduzido para encerrar mais r√°pido
        
        # Usa o shutdown ass√≠ncrono com timeout em vez de httpd.shutdown() direto
        shutdown_server_async(httpd)
        
        # Se chegou aqui, o shutdown foi bem-sucedido
        print("‚úÖ Servidor encerrado com sucesso!")
        print("\nüí° DICA: Para usar novamente, d√™ duplo clique no arquivo 'servidor.py'")
        sys.exit(0)

def main():
    """Fun√ß√£o principal"""
    global servidor_rodando
    
    # Configura handlers de sinal
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    port = 8000
    
    print("üöÄ SERVIDOR INICIADO")
    print("=" * 50)
    print(f"üìÇ Pasta do projeto: {Path.cwd().name}")
    print("üåê Acesse: http://localhost:8000")
    print("\nüéØ ENCERRAMENTO AUTOM√ÅTICO:")
    print("   ‚Ä¢ Fechar o navegador ‚Üí Servidor para automaticamente")
    print("   ‚Ä¢ Ctrl+C no terminal ‚Üí Para manualmente") 
    print("   ‚Ä¢ Fechar janela ‚Üí Para automaticamente")
    print("=" * 50)
    
    # Verifica se a estrutura existe
    if not (Path.cwd() / "codigo").exists():
        print("‚ùå ERRO: Pasta 'codigo' n√£o encontrada!")
        print("üí° Solu√ß√£o: Coloque este arquivo na mesma pasta que a pasta 'codigo'")
        input("Pressione Enter para sair...")
        return
    
    # Verifica porta
    if is_port_in_use(port):
        print(f"‚ö†Ô∏è  Porta {port} est√° em uso!")
        print("üîÑ Tentando liberar a porta...")
        
        if kill_process_on_port(port):
            print("‚úÖ Processo anterior finalizado!")
            time.sleep(3)
        else:
            available_port = find_available_port(port)
            if available_port:
                port = available_port
                print(f"üéØ Usando porta alternativa: {port}")
            else:
                print("‚ùå N√£o foi poss√≠vel encontrar porta dispon√≠vel!")
                input("Pressione Enter para sair...")
                return
    
    # Cria pastas necess√°rias
    json_dir = Path.cwd() / "codigo" / "json"
    json_dir.mkdir(parents=True, exist_ok=True)
    
    handler = UniversalHTTPRequestHandler
    
    try:
        with socketserver.TCPServer(("", port), handler) as httpd:
            # Configura timeout para evitar bloqueios eternos
            httpd.timeout = 1
            
            print(f"\n‚úÖ SERVIDOR RODANDO: http://localhost:{port}")
            print("üìã DICAS R√ÅPIDAS:")
            print("   ‚Ä¢ Use Ctrl+C para parar manualmente")
            print("   ‚Ä¢ Feche o navegador para parar automaticamente")
            print("   ‚Ä¢ Seu trabalho √© salvo automaticamente")
            print("=" * 50)
            
            # Abre navegador em thread separada
            threading.Thread(target=open_browser, args=(port,), daemon=True).start()
            
            # Inicia monitoramento do navegador em thread separada
            monitor_thread = threading.Thread(target=monitorar_navegador, args=(port, httpd), daemon=True)
            monitor_thread.start()
            
            print("üü¢ PRONTO PARA USAR! Trabalhe normalmente...")
            
            # Loop principal do servidor com verifica√ß√£o de estado
            while servidor_rodando:
                try:
                    httpd.handle_request()
                except Exception as e:
                    # Ignora exce√ß√µes menores e continua
                    if servidor_rodando:
                        continue
                    else:
                        break
                        
    except KeyboardInterrupt:
        # J√° tratado pelo signal_handler
        pass
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        print("üí° Tente reiniciar o servidor")
    finally:
        servidor_rodando = False

if __name__ == "__main__":
    main()