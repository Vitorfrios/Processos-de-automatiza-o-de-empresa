
/* ==== IN√çCIO: servidor_modules/__init__.py ==== */
"""
M√≥dulos do Servidor Python - ESTRUTURA REORGANIZADA
"""

from . import config
from .core import ServerCore, RoutesCore, SessionsManager
from .handlers import UniversalHTTPRequestHandler, RouteHandler
from .utils import FileUtils, ServerUtils, CacheCleaner, monitorar_navegador

__all__ = [
    'config', 
    'ServerCore', 'RoutesCore', 'SessionsManager',
    'UniversalHTTPRequestHandler', 'RouteHandler',
    'FileUtils', 'ServerUtils', 'CacheCleaner', 'monitorar_navegador'
]
/* ==== FIM: servidor_modules/__init__.py ==== */

/* ==== IN√çCIO: servidor_modules/core/__init__.py ==== */
"""
Core modules - N√∫cleo do sistema
"""

from .server_core import ServerCore
from .routes_core import RoutesCore
from .sessions_core import SessionsManager

__all__ = ['ServerCore', 'RoutesCore', 'SessionsManager']
/* ==== FIM: servidor_modules/core/__init__.py ==== */

/* ==== IN√çCIO: servidor_modules/handlers/__init__.py ==== */
"""
Handlers modules - Manipuladores HTTP e Rotas
"""

from .http_handler import UniversalHTTPRequestHandler
from .route_handler import RouteHandler

__all__ = ['UniversalHTTPRequestHandler', 'RouteHandler']
/* ==== FIM: servidor_modules/handlers/__init__.py ==== */

/* ==== IN√çCIO: servidor_modules/utils/__init__.py ==== */
"""
Utils modules - Utilit√°rios do sistema
"""

from .file_utils import FileUtils
from .server_utils import ServerUtils
from .cache_cleaner import CacheCleaner
from .browser_monitor import monitorar_navegador

__all__ = ['FileUtils', 'ServerUtils', 'CacheCleaner', 'monitorar_navegador']
/* ==== FIM: servidor_modules/utils/__init__.py ==== */

/* ==== IN√çCIO: servidor_modules/utils/browser_monitor.py ==== */
"""
browser_monitor.py
Monitoramento do navegador - Vers√£o SIMPLIFICADA
"""

import time

def monitorar_navegador(port, httpd):
    """
    Monitoramento SIMPLIFICADO - sem verifica√ß√µes de porta
    Mantido apenas para compatibilidade com o c√≥digo existente
    """
    print("üîç MONITOR: Sistema de monitoramento INICIADO")
    print("   ‚Ä¢ Encerramento autom√°tico DESATIVADO")
    print("   ‚Ä¢ Servidor permanecer√° aberto at√© encerramento manual")
    print("   ‚Ä¢ Use o bot√£o 'Encerrar Servidor' na interface web")
    print("   ‚Ä¢ Ou pressione Ctrl+C neste terminal\n")
    
    # Loop simples que apenas mant√©m a thread ativa
    while True:
        try:
            time.sleep(10)  # Verifica√ß√£o a cada 10 segundos (apenas para manter a thread)
        except KeyboardInterrupt:
            print("\nMONITOR: Interrup√ß√£o recebida")
            break
        except Exception as e:
            print(f"MONITOR: Erro inesperado: {e}")
            time.sleep(10)
    
    print("MONITOR: Thread finalizada")
/* ==== FIM: servidor_modules/utils/browser_monitor.py ==== */

/* ==== IN√çCIO: servidor_modules/utils/cache_cleaner.py ==== */
"""
cache_cleaner.py
Sistema de limpeza de cache para o servidor
"""

import os
import shutil
from pathlib import Path
import threading
import time

class CacheCleaner:
    """
    Gerencia a limpeza de arquivos de cache do Python
    """
    
    def __init__(self):
        self.project_root = Path(__file__).parent.parent.parent
        self.cleanup_executed = False
    
    def clean_pycache(self):
        """
        Limpa todos os arquivos __pycache__ do projeto
        Retorna estat√≠sticas da limpeza
        """
        if self.cleanup_executed:
            print("üîÑ Limpeza de cache j√° foi executada anteriormente")
            return
            
        try:
            print("üßπ Iniciando limpeza de arquivos de cache...")
            
            cache_removed_count = 0
            errors_count = 0
            
            # Procura por todas as pastas __pycache__ no projeto
            for pycache_dir in self.project_root.rglob('__pycache__'):
                if pycache_dir.is_dir():
                    try:
                        # Remove a pasta __pycache__ e todo seu conte√∫do
                        shutil.rmtree(pycache_dir)
                        cache_removed_count += 1
                        print(f"   ‚úÖ Removido: {pycache_dir.relative_to(self.project_root)}")
                    except Exception as e:
                        errors_count += 1
                        print(f"   ‚ö†Ô∏è  Erro ao remover {pycache_dir}: {e}")
            
            # Tamb√©m remove arquivos .pyc soltos (caso existam)
            for pyc_file in self.project_root.rglob('*.pyc'):
                try:
                    pyc_file.unlink()
                    cache_removed_count += 1
                    print(f"   ‚úÖ Removido: {pyc_file.relative_to(self.project_root)}")
                except Exception as e:
                    errors_count += 1
                    print(f"   ‚ö†Ô∏è  Erro ao remover {pyc_file}: {e}")
            
            self.cleanup_executed = True
            
            if cache_removed_count > 0:
                print(f"üéâ Limpeza conclu√≠da: {cache_removed_count} itens de cache removidos")
                if errors_count > 0:
                    print(f"‚ö†Ô∏è  {errors_count} erros durante a limpeza")
            else:
                print("‚ÑπÔ∏è  Nenhum arquivo de cache encontrado para limpar")
                
            return {
                'removed_count': cache_removed_count,
                'errors_count': errors_count,
                'success': True
            }
            
        except Exception as e:
            print(f"‚ùå Erro durante limpeza de cache: {e}")
            return {
                'removed_count': 0,
                'errors_count': 1,
                'success': False,
                'error': str(e)
            }
    
    def clean_pycache_async(self):
        """
        Executa a limpeza de cache em uma thread separada
        para n√£o bloquear o encerramento do servidor
        """
        def cleanup_task():
            print("üîÑ Iniciando limpeza de cache em background...")
            result = self.clean_pycache()
            if result['success']:
                print("‚úÖ Limpeza de cache conclu√≠da com sucesso")
            else:
                print("‚ùå Limpeza de cache encontrou problemas")
        
        # Inicia a limpeza em thread separada
        cleanup_thread = threading.Thread(target=cleanup_task, daemon=True)
        cleanup_thread.start()
        
        # Aguarda um tempo razo√°vel para a limpeza completar
        cleanup_thread.join(timeout=5.0)
        
        if cleanup_thread.is_alive():
            print("‚è∞ Timeout na limpeza de cache - continuando encerramento...")
        else:
            print("‚úÖ Limpeza de cache finalizada")

# Inst√¢ncia global do cleaner
cache_cleaner = CacheCleaner()

def clean_on_shutdown():
    """
    Fun√ß√£o para ser chamada durante o encerramento do servidor
    """
    return cache_cleaner.clean_pycache_async()

def force_cleanup():
    """
    For√ßa a limpeza imediata (√∫til para testes)
    """
    return cache_cleaner.clean_pycache()
/* ==== FIM: servidor_modules/utils/cache_cleaner.py ==== */

/* ==== IN√çCIO: servidor_modules/config.py ==== */
"""
config.py
Configura√ß√µes do Servidor 
Configura√ß√µes globais e constantes do sistema de climatiza√ß√£o
"""

# Vari√°veis globais de estado do servidor
servidor_rodando = True
ultimo_heartbeat = None  

# Configura√ß√µes do servidor
SERVER_TIMEOUT = 1  # 1 segundo - permite verifica√ß√£o peri√≥dica de sinais
DEFAULT_PORT = 8000
MAX_PORT_ATTEMPTS = 15  # N√∫mero m√°ximo de tentativas para encontrar porta dispon√≠vel

# Mensagens do sistema
MESSAGES = {
    'server_start': "INICIANDO SISTEMA DE CLIMATIZACAO",
    'server_running': "SISTEMA OPERACIONAL", 
    'server_stop': "ENCERRANDO SISTEMA",
    'browser_open': "APLICACAO ABERTA NO NAVEGADOR",
    'monitor_active': "MONITORANDO NAVEGADOR",
    'browser_closed': "Navegador fechado - encerrando servidor",
    'port_available': "Porta configurada com sucesso",
    'port_busy': "Porta ocupada, tentando alternativas",
    'shutdown_signal': "Sinal de encerramento recebido",
}

# Configura√ß√µes de seguran√ßa
ALLOWED_ORIGINS = ["http://localhost", "http://127.0.0.1"]  # Origens permitidas para CORS
/* ==== FIM: servidor_modules/config.py ==== */

/* ==== IN√çCIO: servidor_modules/handlers/empresa_handler.py ==== */
"""
empresa_handler.py
Manipula√ß√£o de empresas no dados.json
"""

import json
import os
from servidor_modules.utils.file_utils import FileUtils

class EmpresaHandler:
    def __init__(self):
        self.file_utils = FileUtils()
        self.dados_path = os.path.join('json', 'dados.json')

    def obter_empresas(self):
        """Obt√©m lista de empresas do dados.json"""
        try:
            dados = self.file_utils.carregar_json(self.dados_path)
            return dados.get('empresas', [])
        except Exception as e:
            print(f"‚ùå Erro ao obter empresas: {e}")
            return []

    def adicionar_empresa(self, nova_empresa):
        """Adiciona nova empresa ao dados.json"""
        try:
            # Carregar dados existentes
            dados = self.file_utils.carregar_json(self.dados_path)
            if not dados:
                dados = {"empresas": []}

            # Verificar se empresa j√° existe
            sigla = list(nova_empresa.keys())[0]
            empresas_existentes = dados.get('empresas', [])
            
            for empresa in empresas_existentes:
                if sigla in empresa:
                    return False, f"Empresa com sigla {sigla} j√° existe"

            # Adicionar nova empresa
            empresas_existentes.append(nova_empresa)
            dados['empresas'] = empresas_existentes

            # Salvar
            sucesso = self.file_utils.salvar_json(self.dados_path, dados)
            if sucesso:
                return True, f"Empresa {sigla} adicionada com sucesso"
            else:
                return False, "Erro ao salvar dados"

        except Exception as e:
            print(f"‚ùå Erro ao adicionar empresa: {e}")
            return False, f"Erro interno: {str(e)}"

    def buscar_empresa_por_termo(self, termo):
        """Busca empresas por sigla, primeiro nome ou substring"""
        try:
            empresas = self.obter_empresas()
            termo = termo.upper().strip()
            
            resultados = []
            
            for empresa_obj in empresas:
                for sigla, nome in empresa_obj.items():
                    nome_upper = nome.upper()
                    primeiro_nome = nome.split(' ')[0].upper()
                    
                    # Buscar por sigla exata
                    if sigla == termo:
                        resultados.append({sigla: nome})
                    # Buscar por primeiro nome
                    elif primeiro_nome.startswith(termo):
                        resultados.append({sigla: nome})
                    # Buscar por substring no nome
                    elif termo in nome_upper:
                        resultados.append({sigla: nome})
            
            return resultados

        except Exception as e:
            print(f"‚ùå Erro ao buscar empresas: {e}")
            return []

    def obter_proximo_numero_cliente(self, sigla):
        """Obt√©m pr√≥ximo n√∫mero de cliente para uma sigla"""
        try:
            # Carregar backup para ver obras existentes
            backup_path = os.path.join('json', 'backup.json')
            backup_data = self.file_utils.carregar_json(backup_path)
            
            if not backup_data or 'obras' not in backup_data:
                return 1
            
            obras = backup_data['obras']
            maior_numero = 0
            
            for obra in obras:
                # Verificar por empresaSigla
                if obra.get('empresaSigla') == sigla:
                    numero = obra.get('numeroClienteFinal', 0)
                    if numero > maior_numero:
                        maior_numero = numero
                
                # Verificar por idGerado
                id_gerado = obra.get('idGerado', '')
                if id_gerado.startswith(f'obra_{sigla}_'):
                    try:
                        numero_str = id_gerado.split('_')[-1]
                        numero = int(numero_str)
                        if numero > maior_numero:
                            maior_numero = numero
                    except (ValueError, IndexError):
                        continue
            
            return maior_numero + 1

        except Exception as e:
            print(f"‚ùå Erro ao obter pr√≥ximo n√∫mero: {e}")
            return 1
/* ==== FIM: servidor_modules/handlers/empresa_handler.py ==== */

/* ==== IN√çCIO: servidor_modules/utils/file_utils.py ==== */
"""
file_utils.py
Utilit√°rios para manipula√ß√£o de arquivos e paths
"""

import json
import os
from pathlib import Path

class FileUtils:
    """Utilit√°rios para manipula√ß√£o de arquivos"""
    
    def find_project_root(self):
        """Encontra a raiz do projeto procurando pela estrutura de pastas"""
        current_dir = Path(__file__).parent.parent.parent  # Pasta servidor_modules -> codigo
        
        print(f"Procurando estrutura a partir de: {current_dir}")
        
        # Verifica se estamos na estrutura correta
        if (current_dir / "public" / "pages" / "01_Create_Obras.html").exists():
            print("Estrutura encontrada: Diretorio correto")
            return current_dir
        
        # Fallback: diret√≥rio atual do script
        print("Usando diretorio do script como raiz")
        return current_dir

    def find_json_file(self, filename, project_root=None):
        """Encontra arquivos JSON"""
        if project_root is None:
            project_root = self.find_project_root()
        
        # Garante que a pasta json existe
        json_dir = project_root / "json"
        json_dir.mkdir(parents=True, exist_ok=True)
        
        target_file = json_dir / filename
        
        # Se o arquivo n√£o existe, cria com estrutura b√°sica
        if not target_file.exists():
            print(f"Criando arquivo: {target_file}")
            
            if filename == "backup.json":
                default_data = {"obras": []}
            elif filename == "dados.json":
                default_data = {"constants": {}, "machines": []}
            elif filename == "sessions.json":
                default_data = {"sessions": {}}
            else:
                default_data = {}
            
            self.save_json_file(target_file, default_data)
        
        return target_file

    def load_json_file(self, filepath, default_data=None):
        """Carrega arquivo JSON com tratamento de erro"""
        try:
            if filepath.exists():
                with open(filepath, 'r', encoding='utf-8') as f:
                    return json.load(f)
            elif default_data is not None:
                # Cria o arquivo com dados padr√£o
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump(default_data, f, indent=2, ensure_ascii=False)
                return default_data
            else:
                return None
        except Exception as e:
            print(f"ERRO ao carregar {filepath}: {e}")
            return default_data

    def save_json_file(self, filepath, data):
        """Salva dados em arquivo JSON"""
        try:
            # Garante que o diret√≥rio existe
            filepath.parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"ERRO ao salvar {filepath}: {e}")
            return False
/* ==== FIM: servidor_modules/utils/file_utils.py ==== */

/* ==== IN√çCIO: servidor_modules/handlers/http_handler.py ==== */
"""
http_handler.py
HTTP Request Handler - Interface HTTP Principal
"""

import http.server
import json
import time
from urllib.parse import urlparse
from pathlib import Path

from servidor_modules.utils.file_utils import FileUtils
from servidor_modules.core.sessions_core import sessions_manager
from servidor_modules.utils.cache_cleaner import CacheCleaner
from .route_handler import RouteHandler

class UniversalHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """Handler robusto e compat√≠vel para produ√ß√£o com sistema FOCO EM OBRAS"""
    
    def __init__(self, *args, **kwargs):
        self.file_utils = FileUtils()
        self.project_root = self.file_utils.find_project_root()
        self.cache_cleaner = CacheCleaner()
        
        print(f"üìÅ Diret√≥rio base: {self.project_root}")
        
        self.route_handler = RouteHandler(
            self.project_root, 
            sessions_manager, 
            self.file_utils, 
            self.cache_cleaner
        )
        
        serve_directory = self.project_root
        super().__init__(*args, directory=str(serve_directory), **kwargs)
    
    def do_GET(self):
        """GET robusto com tratamento de erro"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        # Log seletivo
        if path not in ['/', '/favicon.ico'] and not path.startswith('/static/'):
            print(f"üì• GET: {path}")
        
        # Roteamento APIs - FOCO EM OBRAS
        if path == '/obras':
            self.route_handler.handle_get_obras(self)
        elif path == '/constants' or path == '/system-constants':
            self.route_handler.handle_get_constants(self)
        elif path == '/dados':
            self.route_handler.handle_get_dados(self)
        elif path == '/backup':
            self.route_handler.handle_get_backup(self)
        elif path == '/machines':
            self.route_handler.handle_get_machines(self)
        elif path == '/health-check':
            self.send_json_response({"status": "online", "timestamp": time.time()})
        elif path == '/session-obras':
            self.route_handler.handle_get_session_obras(self)
        elif path == '/api/session-obras':
            self.route_handler.handle_get_session_obras(self)
        elif path == '/api/sessions/current':
            self.route_handler.handle_get_sessions_current(self)
        elif path == '/api/backup-completo':
            self.route_handler.handle_get_backup_completo(self)
        # üÜï ROTAS DE EMPRESAS
        elif path == '/api/dados/empresas':
            self.route_handler.handle_get_empresas(self)
        elif path.startswith('/api/dados/empresas/buscar/'):
            termo = path.split('/')[-1]
            self.route_handler.handle_buscar_empresas(self, termo)
        elif path.startswith('/api/dados/empresas/numero/'):
            sigla = path.split('/')[-1]
            self.route_handler.handle_get_proximo_numero(self, sigla)
        elif path.startswith('/obras/') and self.command == 'GET':
            self.route_handler.handle_get_obra_by_id(self, path.split('/')[-1])
        # ROTAS LEGACY (COMPATIBILIDADE)
        elif path == '/projetos' or path == '/projects':
            self.route_handler.handle_get_projetos(self)
        elif path == '/api/session-projects':
            self.route_handler.handle_get_session_projects(self)
        else:
            try:
                super().do_GET()
            except Exception as e:
                if path != '/favicon.ico':
                    print(f"‚ùå Erro em {path}: {e}")
                self.send_error(404, f"Recurso n√£o encontrado: {path}")     
    
    def do_POST(self):
        """POST com tratamento completo"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üì® POST: {path}")
        
        # ROTAS PRINCIPAIS
        if path == '/obras':
            self.route_handler.handle_post_obras(self)
        elif path == '/api/sessions/shutdown':
            self.route_handler.handle_post_sessions_shutdown(self)
        elif path == '/api/shutdown':
            self.route_handler.handle_shutdown(self)
        elif path == '/dados':
            self.route_handler.handle_post_dados(self)
        elif path == '/backup':
            self.route_handler.handle_post_backup(self)
        elif path == '/api/sessions/ensure-single':
            self.route_handler.handle_post_sessions_ensure_single(self)
        elif path == '/api/sessions/add-obra':
            self.route_handler.handle_post_sessions_add_obra(self)
        elif path == '/api/reload-page':
            self.route_handler.handle_post_reload_page(self)
        # üÜï ROTAS DE EMPRESAS
        elif path == '/api/dados/empresas':
            self.route_handler.handle_post_empresas(self)
        # ROTAS LEGACY (COMPATIBILIDADE)
        elif path in ['/projetos', '/projects']:
            self.route_handler.handle_post_projetos(self)
        else:
            print(f"‚ùå POST n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: POST {path}")

    def do_PUT(self):
        """PUT para atualiza√ß√µes"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üì® PUT: {path}")
        
        # ROTAS PRINCIPAIS - OBRAS
        if path.startswith('/obras/'):
            print(f"üéØ Roteando PUT para obra: {path}")
            self.route_handler.handle_put_obra(self)
        else:
            print(f"‚ùå PUT n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: PUT {path}")

    def do_DELETE(self):
        """DELETE para remo√ß√£o de recursos"""
        parsed_path = urlparse(self.path)
        path = parsed_path.path
        
        if path.startswith('/codigo/'):
            path = path[7:]
        
        print(f"üóëÔ∏è  DELETE: {path}")
        
        # ROTAS PRINCIPAIS - OBRAS
        if path.startswith('/obras/'):
            obra_id = path.split('/')[-1]
            print(f"üéØ Roteando DELETE para obra: {obra_id}")
            self.route_handler.handle_delete_obra(self, obra_id)
        # ROTAS PRINCIPAIS - SESS√ïES OBRAS
        elif path.startswith('/api/sessions/remove-obra/'):
            obra_id = path.split('/')[-1]
            self.route_handler.handle_delete_sessions_remove_obra(self, obra_id)
        # ROTAS LEGACY (COMPATIBILIDADE)
        elif path.startswith('/api/sessions/remove-project/'):
            project_id = path.split('/')[-1]
            self.route_handler.handle_delete_sessions_remove_project(self, project_id)
        else:
            print(f"‚ùå DELETE n√£o implementado: {path}")
            self.send_error(501, f"M√©todo n√£o suportado: DELETE {path}")
    
    def send_json_response(self, data, status=200):
        """Resposta JSON padronizada"""
        self.send_response(status)
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
        
        response = json.dumps(data, ensure_ascii=False).encode('utf-8')
        self.wfile.write(response)
    
    def end_headers(self):
        """Headers CORS para desenvolvimento"""
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()
    
    def do_OPTIONS(self):
        """Suporte CORS completo"""
        self.send_response(200)
        self.end_headers()

    def log_message(self, format, *args):
        """Log personalizado para melhor debugging"""
        # Filtra logs de arquivos est√°ticos para n√£o poluir o console
        if not any(static in self.path for static in ['/static/', '/favicon.ico', '.css', '.js', '.png', '.jpg']):
            print(f"üåê {self.address_string()} - {format % args}")
/* ==== FIM: servidor_modules/handlers/http_handler.py ==== */

/* ==== IN√çCIO: servidor_modules/handlers/route_handler.py ==== */
"""
route_handler.py
Handler principal de rotas - Interface entre HTTP e Core
"""

import json
from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import os
# from servidor_modules.core.routes_core import RoutesCore

class RouteHandler:
    """Manipula o roteamento de requisi√ß√µes HTTP"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        
        # RoutesCore ser√° injetado depois para evitar import circular
        self.routes_core = None
    
    def set_routes_core(self, routes_core):
        """Define o RoutesCore ap√≥s a inicializa√ß√£o para evitar import circular"""
        self.routes_core = routes_core

    # ========== ROTAS DE OBRAS ==========

    def handle_get_obras(self, handler):
        """GET /obras"""
        obras = self.routes_core.handle_get_obras()
        handler.send_json_response(obras)

    def handle_get_obra_by_id(self, handler, obra_id):
        """GET /obras/{id}"""
        obra = self.routes_core.handle_get_obra_by_id(obra_id)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_post_obras(self, handler):
        """POST /obras"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_post_obras(post_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(500, "Erro ao salvar obra")

    def handle_put_obra(self, handler):
        """PUT /obras/{id}"""
        obra_id = handler.path.split('/')[-1]
        content_length = int(handler.headers['Content-Length'])
        put_data = handler.rfile.read(content_length).decode('utf-8')
        
        obra = self.routes_core.handle_put_obra(obra_id, put_data)
        if obra:
            handler.send_json_response(obra)
        else:
            handler.send_error(404, f"Obra {obra_id} n√£o encontrada")

    def handle_delete_obra(self, handler, obra_id):
        """DELETE /obras/{id}"""
        success = self.routes_core.handle_delete_obra(obra_id)
        if success:
            handler.send_json_response({
                "success": True,
                "message": f"Obra {obra_id} deletada com sucesso"
            })
        else:
            handler.send_error(500, "Erro ao deletar obra")

    # ========== ROTAS DE EMPRESAS ==========

    def handle_get_empresas(self, handler):
        """GET /api/dados/empresas"""
        empresas = self.routes_core.handle_get_empresas()
        handler.send_json_response(empresas)

    def handle_post_empresas(self, handler):
        """POST /api/dados/empresas"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_empresas(post_data)
        handler.send_json_response(result)

    def handle_buscar_empresas(self, handler, termo):
        """GET /api/dados/empresas/buscar/{termo}"""
        empresas = self.routes_core.handle_buscar_empresas(termo)
        handler.send_json_response(empresas)

    def handle_get_proximo_numero(self, handler, sigla):
        """GET /api/dados/empresas/numero/{sigla}"""
        numero = self.routes_core.handle_get_proximo_numero(sigla)
        handler.send_json_response(numero)

    # ========== ROTAS DE SESS√ÉO ==========

    def handle_get_sessions_current(self, handler):
        """GET /api/sessions/current"""
        session_data = self.routes_core.handle_get_sessions_current()
        handler.send_json_response(session_data)

    def handle_post_sessions_add_obra(self, handler):
        """POST /api/sessions/add-obra"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_sessions_add_obra(post_data)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_delete_sessions_remove_obra(self, handler, obra_id):
        """DELETE /api/sessions/remove-obra/{id}"""
        result = self.routes_core.handle_delete_sessions_remove_obra(obra_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    def handle_get_session_obras(self, handler):
        """GET /api/session-obras"""
        result = self.routes_core.handle_get_session_obras()
        handler.send_json_response(result)

    def handle_post_sessions_shutdown(self, handler):
        """POST /api/sessions/shutdown"""
        result = self.routes_core.handle_post_sessions_shutdown()
        handler.send_json_response(result)

    def handle_post_sessions_ensure_single(self, handler):
        """POST /api/sessions/ensure-single"""
        result = self.routes_core.handle_post_sessions_ensure_single()
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])

    # ========== ROTAS DE SISTEMA ==========

    def handle_shutdown(self, handler):
        """POST /api/shutdown"""
        response = self.routes_core.handle_shutdown()
        handler.send_json_response(response)

    def handle_get_constants(self, handler):
        """GET /constants"""
        constants = self.routes_core.handle_get_constants()
        handler.send_json_response(constants)

    def handle_get_machines(self, handler):
        """GET /machines"""
        machines = self.routes_core.handle_get_machines()
        handler.send_json_response(machines)

    def handle_get_dados(self, handler):
        """GET /dados"""
        dados = self.routes_core.handle_get_dados()
        handler.send_json_response(dados)

    def handle_get_backup(self, handler):
        """GET /backup"""
        backup = self.routes_core.handle_get_backup()
        handler.send_json_response(backup)

    def handle_get_backup_completo(self, handler):
        """GET /api/backup-completo"""
        backup = self.routes_core.handle_get_backup_completo()
        handler.send_json_response(backup)

    def handle_post_dados(self, handler):
        """POST /dados"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_dados(post_data)
        handler.send_json_response(result)

    def handle_post_backup(self, handler):
        """POST /backup"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_backup(post_data)
        handler.send_json_response(result)

    def handle_post_reload_page(self, handler):
        """POST /api/reload-page"""
        content_length = int(handler.headers['Content-Length'])
        post_data = handler.rfile.read(content_length).decode('utf-8')
        
        result = self.routes_core.handle_post_reload_page(post_data)
        handler.send_json_response(result)

    # ========== ROTAS DE COMPATIBILIDADE ==========

    def handle_get_projetos(self, handler):
        """GET /projetos (legacy)"""
        projetos = self.routes_core.handle_get_projetos()
        handler.send_json_response(projetos)

    def handle_post_projetos(self, handler):
        """POST /projetos (legacy)"""
        handler.send_error(501, "Use o endpoint /obras em vez de /projetos")

    def handle_get_session_projects(self, handler):
        """GET /api/session-projects (legacy)"""
        handler.send_json_response([])

    def handle_delete_sessions_remove_project(self, handler, project_id):
        """DELETE /api/sessions/remove-project/{id} (legacy)"""
        result = self.routes_core.handle_delete_sessions_remove_project(project_id)
        if result["success"]:
            handler.send_json_response(result)
        else:
            handler.send_error(500, result["error"])
/* ==== FIM: servidor_modules/handlers/route_handler.py ==== */

/* ==== IN√çCIO: servidor_modules/core/routes_core.py ==== */
"""
routes_core.py
N√∫cleo das rotas - Divis√£o l√≥gica das funcionalidades
"""

import json
import time
import threading
from pathlib import Path
from servidor_modules.handlers.empresa_handler import EmpresaHandler


class RoutesCore:
    """N√∫cleo das funcionalidades de rotas organizadas por categoria"""
    
    def __init__(self, project_root, sessions_manager, file_utils, cache_cleaner):
        self.project_root = project_root
        self.sessions_manager = sessions_manager
        self.file_utils = file_utils
        self.cache_cleaner = cache_cleaner
        self.empresa_handler = EmpresaHandler()


    # ========== ROTAS DE OBRAS ==========
    
    def handle_get_obras(self):
        """Obt√©m todas as obras da sess√£o atual"""
        try:
            print("üéØ [OBRAS] Obtendo obras da sess√£o")
            
            current_session_id = self.sessions_manager.get_current_session_id()
            session_data = self.sessions_manager._load_sessions_data()
            session_obra_ids = session_data["sessions"].get(current_session_id, {}).get("obras", [])
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return []
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_data = json.loads(f.read())
            
            obras = backup_data.get('obras', [])
            if not isinstance(obras, list):
                obras = []
                
            obras_da_sessao = []
            for obra in obras:
                if not isinstance(obra, dict):
                    continue
                    
                obra_id = str(obra.get('id', ''))
                if obra_id in session_obra_ids:
                    obras_da_sessao.append(obra)
            
            print(f"üéØ ENVIANDO: {len(obras_da_sessao)} obras da sess√£o")
            return obras_da_sessao
            
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obras: {str(e)}")
            return []

    def handle_get_obra_by_id(self, obra_id):
        """Obt√©m uma obra espec√≠fica por ID"""
        try:
            print(f"üéØ [OBRA POR ID] Buscando obra {obra_id}")
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return None
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_data = json.loads(f.read())
            
            obras = backup_data.get('obras', [])
            
            for obra in obras:
                if str(obra.get('id')) == obra_id:
                    print(f"‚úÖ Obra {obra_id} encontrada")
                    return obra
            
            print(f"‚ùå Obra {obra_id} n√£o encontrada")
            return None
                
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_obra_by_id: {str(e)}")
            return None

    def handle_post_obras(self, post_data):
        """Salva nova obra e adiciona √† sess√£o"""
        try:
            nova_obra = json.loads(post_data)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": [], "projetos": []})
            
            obra_id = nova_obra.get('id')
            
            if not obra_id or obra_id.isdigit():
                import random
                import string
                letters = 'abcdefghjkmnpqrstwxyz'
                random_letter1 = random.choice(letters)
                random_letter2 = random.choice(letters)
                random_num = random.randint(10, 99)
                obra_id = f"obra_{random_letter1}{random_num}"
                
                print(f"üÜï Backend gerou ID seguro: {obra_id}")
            
            nova_obra['id'] = obra_id
            
            if 'timestamp' not in nova_obra:
                from datetime import datetime
                nova_obra['timestamp'] = datetime.now().isoformat()
            
            print(f"üìù Tentando adicionar obra {obra_id} √† sess√£o...")
            success = self.sessions_manager.add_obra_to_session(obra_id)
            
            if not success:
                print(f"‚ùå FALHA ao adicionar obra {obra_id} √† sess√£o")
                return None
            
            obras = backup_data.get('obras', [])
            obras.append(nova_obra)
            backup_data['obras'] = obras
            
            print(f"‚ûï ADICIONANDO nova obra ID: {obra_id}")
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                print(f"‚úÖ Obra {obra_id} salva com sucesso")
                return nova_obra
            else:
                return None
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra: {str(e)}")
            return None

    def handle_put_obra(self, obra_id, put_data):
        """Atualiza obra existente"""
        try:
            obra_atualizada = json.loads(put_data)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file)
            
            if not backup_data:
                return None
            
            obras = backup_data.get('obras', [])
            obra_encontrada = False
            
            for i, obra in enumerate(obras):
                if str(obra.get('id')) == obra_id:
                    obras[i] = obra_atualizada
                    obra_encontrada = True
                    print(f"‚úèÔ∏è  ATUALIZANDO obra {obra_id}")
                    break
            
            if not obra_encontrada:
                return None
            
            backup_data['obras'] = obras
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                return obra_atualizada
            else:
                return None
            
        except Exception as e:
            print(f"‚ùå Erro ao atualizar obra: {str(e)}")
            return None

    def handle_delete_obra(self, obra_id):
        """Deleta uma obra do servidor"""
        try:
            print(f"üóëÔ∏è  Deletando obra {obra_id} do servidor")
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": []})
            
            obras = backup_data.get('obras', [])
            obra_encontrada = False
            
            obras_atualizadas = []
            for obra in obras:
                if str(obra.get('id')) != obra_id:
                    obras_atualizadas.append(obra)
                else:
                    obra_encontrada = True
                    print(f"‚úÖ Obra {obra_id} encontrada para remo√ß√£o")
            
            if not obra_encontrada:
                return False
            
            backup_data['obras'] = obras_atualizadas
            
            if self.file_utils.save_json_file(backup_file, backup_data):
                self.sessions_manager.remove_obra(obra_id)
                return True
            else:
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao deletar obra: {str(e)}")
            return False


    # ========= Metodos para empresas ========
    def handle_get_empresas(self):
        """Obt√©m todas as empresas"""
        try:
            empresas = self.empresa_handler.obter_empresas()
            return {
                "success": True,
                "empresas": empresas
            }
        except Exception as e:
            print(f"‚ùå Erro ao obter empresas: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def handle_post_empresas(self, post_data):
        """Adiciona nova empresa"""
        try:
            empresa_data = json.loads(post_data)
            sucesso, mensagem = self.empresa_handler.adicionar_empresa(empresa_data)
            
            return {
                "success": sucesso,
                "message": mensagem
            }
        except Exception as e:
            print(f"‚ùå Erro ao adicionar empresa: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def handle_buscar_empresas(self, termo):
        """Busca empresas por termo"""
        try:
            from urllib.parse import unquote
            termo_decodificado = unquote(termo)
            resultados = self.empresa_handler.buscar_empresa_por_termo(termo_decodificado)
            
            return {
                "success": True,
                "resultados": resultados
            }
        except Exception as e:
            print(f"‚ùå Erro ao buscar empresas: {e}")
            return {
                "success": False,
                "error": str(e),
                "resultados": []
            }

    def handle_get_proximo_numero(self, sigla):
        """Obt√©m pr√≥ximo n√∫mero para sigla"""
        try:
            from urllib.parse import unquote
            sigla_decodificada = unquote(sigla)
            numero = self.empresa_handler.obter_proximo_numero_cliente(sigla_decodificada)
            
            return {
                "success": True,
                "numero": numero
            }
        except Exception as e:
            print(f"‚ùå Erro ao obter pr√≥ximo n√∫mero: {e}")
            return {
                "success": False,
                "error": str(e),
                "numero": 1
            }


    # ========== ROTAS DE SESS√ÉO ==========
    
    def handle_get_sessions_current(self):
        """Retorna a sess√£o atual"""
        try:
            data = self.sessions_manager._load_sessions_data()
            current_session_id = self.sessions_manager.get_current_session_id()
            
            if current_session_id not in data["sessions"]:
                return {"sessions": {}}
            
            current_session = {
                current_session_id: data["sessions"][current_session_id]
            }
            
            print(f"üìä Retornando sess√£o {current_session_id}")
            return {"sessions": current_session}
            
        except Exception as e:
            print(f"‚ùå Erro ao obter sess√£o atual: {str(e)}")
            return {"sessions": {}}

    def handle_post_sessions_add_obra(self, post_data):
        """Adiciona uma obra √† sess√£o atual"""
        try:
            data = json.loads(post_data)
            obra_id = data.get('obra_id')
            
            if not obra_id:
                return {"success": False, "error": "ID da obra n√£o fornecido"}
            
            print(f"‚ûï Adicionando obra {obra_id} √† sess√£o")
            success = self.sessions_manager.add_obra_to_session(obra_id)
            
            if success:
                return {
                    "success": True,
                    "message": f"Obra {obra_id} adicionada √† sess√£o"
                }
            else:
                return {"success": False, "error": "Erro ao adicionar obra √† sess√£o"}
                
        except Exception as e:
            print(f"‚ùå Erro ao adicionar obra √† sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_delete_sessions_remove_obra(self, obra_id):
        """Remove uma obra da sess√£o atual"""
        try:
            print(f"üóëÔ∏è  Removendo obra {obra_id} da sess√£o")
            
            success = self.sessions_manager.remove_obra(obra_id)
            
            if success:
                return {
                    "success": True, 
                    "message": f"Obra {obra_id} removida da sess√£o"
                }
            else:
                return {"success": False, "error": "Erro ao remover obra da sess√£o"}
                
        except Exception as e:
            print(f"‚ùå Erro ao remover obra da sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}

    def handle_get_session_obras(self):
        """Retorna apenas os IDs das obras da sess√£o atual"""
        try:
            session_obras = self.sessions_manager.get_session_obras()
            current_session_id = self.sessions_manager.get_current_session_id()
            
            print(f"üìã [SESSION-OBRAS] Sess√£o {current_session_id} - Obras: {session_obras}")
            
            return {
                "session_id": current_session_id,
                "obras": session_obras
            }
            
        except Exception as e:
            print(f"‚ùå Erro em handle_get_session_obras: {str(e)}")
            return {"session_id": "error", "obras": []}

    def handle_post_sessions_shutdown(self):
        """Limpa COMPLETAMENTE TODAS as sess√µes"""
        try:
            print(f"üî¥ SHUTDOWN COMPLETO: Deletando TODAS as sess√µes")
            
            data_before = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado ANTES do shutdown: {data_before}")
            
            success = self.sessions_manager.clear_session()
            
            data_after = self.sessions_manager._load_sessions_data()
            print(f"üìÑ Estado DEPOIS do shutdown: {data_after}")
            
            is_empty = (
                not data_after.get("sessions") or 
                data_after["sessions"] == {} or
                (data_after.get("sessions", {}).get("session_active", {}).get("obras", []) == [])
            )
            
            if success and is_empty:
                return {
                    "success": True,
                    "message": "Sess√µes DELETADAS completamente",
                    "final_state": data_after
                }
            else:
                print("üîÑ M√©todo normal falhou - for√ßando limpeza...")
                success = self.sessions_manager.force_clear_all_sessions()
                data_final = self.sessions_manager._load_sessions_data()
                
                final_is_empty = (
                    not data_final.get("sessions") or 
                    data_final["sessions"] == {} or
                    (data_final.get("sessions", {}).get("session_active", {}).get("obras", []) == [])
                )
                
                if success and final_is_empty:
                    return {
                        "success": True,
                        "message": "Sess√µes DELETADAS (for√ßado)",
                        "final_state": data_final
                    }
                else:
                    print(f"‚ö†Ô∏è  Sess√£o final n√£o est√° completamente vazia, mas considerando sucesso: {data_final}")
                    return {
                        "success": True,
                        "message": "Sess√µes limpas com aviso",
                        "final_state": data_final,
                        "warning": "Sess√£o pode conter dados residuais"
                    }
                    
        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")
            return {
                "success": True,
                "message": "Sess√µes limpas (com erro ignorado)",
                "error_ignored": str(e)
            }

    def handle_post_sessions_ensure_single(self):
        """Garante que apenas uma sess√£o esteja ativa por vez"""
        try:
            print(f"üîí Garantindo sess√£o √∫nica")
            
            success = self.sessions_manager.ensure_single_session()
            current_session_id = self.sessions_manager.get_current_session_id()
            obra_ids = self.sessions_manager.get_session_obras()
            
            if success:
                return {
                    "success": True,
                    "message": "Sess√£o √∫nica configurada",
                    "session_id": current_session_id,
                    "obras_count": len(obra_ids),
                    "obras": obra_ids
                }
            else:
                return {"success": False, "error": "Erro ao configurar sess√£o √∫nica"}
                
        except Exception as e:
            print(f"‚ùå Erro ao configurar sess√£o √∫nica: {str(e)}")
            return {"success": False, "error": str(e)}

    # ========== ROTAS DE SISTEMA ==========
    
    def handle_shutdown(self):
        """Encerra o servidor com limpeza de cache"""
        try:
            print("üî¥ SHUTDOWN SOLICITADO VIA BOT√ÉO - ENCERRANDO SERVIDOR")
            
            response = {
                "status": "shutting_down", 
                "message": "Servidor encerrado com sucesso via bot√£o",
                "action": "close_window",
                "close_delay": 3000
            }
            
            print("‚úÖ Resposta enviada ao cliente - servidor ser√° encerrado")
            
            def shutdown_sequence():
                print("üîÑ Iniciando sequ√™ncia de encerramento...")
                
                try:
                    print("üßπ Executando limpeza de cache...")
                    self.cache_cleaner.clean_pycache_async()
                except Exception as cache_error:
                    print(f"‚ö†Ô∏è  Erro na limpeza de cache: {cache_error}")
                
                time.sleep(2)
                print("üí• For√ßando encerramento do processo Python...")
                
                import os
                os._exit(0)
            
            shutdown_thread = threading.Thread(target=shutdown_sequence)
            shutdown_thread.daemon = True
            shutdown_thread.start()
            
            return response
            
        except Exception as e:
            print(f"‚ùå Erro no shutdown: {str(e)}")
            
            try:
                self.cache_cleaner.clean_pycache_async()
            except:
                pass
                
            import os
            os._exit(0)

    def handle_get_constants(self):
        """Constants do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            constants = dados_data.get('constants', {})
            print(f"‚öôÔ∏è  Retornando constants")
            return constants
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar constants: {str(e)}")
            return {}

    def handle_get_machines(self):
        """Machines do DADOS.json"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {})
            
            machines = dados_data.get('machines', [])
            print(f"üñ•Ô∏è  Retornando {len(machines)} m√°quinas")
            return machines
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar machines: {str(e)}")
            return []

    def handle_get_dados(self):
        """DADOS.json completo"""
        try:
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            dados_data = self.file_utils.load_json_file(dados_file, {"constants": {}, "machines": []})
            
            print("üìÅ Retornando DADOS.json")
            return dados_data
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar dados: {str(e)}")
            return {"constants": {}, "machines": []}

    def handle_get_backup(self):
        """BACKUP.json completo"""
        try:
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            backup_data = self.file_utils.load_json_file(backup_file, {"obras": [], "projetos": []})
            
            print("üíæ Retornando BACKUP.json")
            return backup_data
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar backup: {str(e)}")
            return {"obras": [], "projetos": []}

    def handle_get_backup_completo(self):
        """Obt√©m TODAS as obras do backup (sem filtro de sess√£o)"""
        try:
            print("üéØ [BACKUP COMPLETO] Obtendo TODAS as obras")
            
            backup_path = self.project_root / "json" / "backup.json"
            
            if not backup_path.exists():
                return {"obras": []}
                
            with open(backup_path, 'r', encoding='utf-8') as f:
                backup_content = f.read()
                
            backup_data = json.loads(backup_content)
            obras = backup_data.get('obras', [])
            
            print(f"üìÅ Total de obras no backup: {len(obras)}")
            return {"obras": obras}
            
        except Exception as e:
            print(f"‚ùå ERRO em handle_get_backup_completo: {str(e)}")
            return {"obras": []}

    def handle_post_dados(self, post_data):
        """Salva DADOS.json"""
        try:
            new_data = json.loads(post_data)
            
            dados_file = self.file_utils.find_json_file('dados.json', self.project_root)
            
            if self.file_utils.save_json_file(dados_file, new_data):
                print("üíæ DADOS.json salvo")
                return {"status": "success", "message": "Dados salvos"}
            else:
                return {"status": "error", "message": "Erro ao salvar dados"}
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar dados: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_backup(self, post_data):
        """Salva BACKUP.json"""
        try:
            new_data = json.loads(post_data)
            
            backup_file = self.file_utils.find_json_file('backup.json', self.project_root)
            
            if self.file_utils.save_json_file(backup_file, new_data):
                print("üíæ BACKUP.json salvo")
                return {"status": "success", "message": "Backup salvo"}
            else:
                return {"status": "error", "message": "Erro ao salvar backup"}
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar backup: {str(e)}")
            return {"status": "error", "message": str(e)}

    def handle_post_reload_page(self, post_data):
        """For√ßa recarregamento da p√°gina via Python"""
        try:
            data = json.loads(post_data)
            
            action = data.get('action', 'unknown')
            obra_id = data.get('obraId')
            obra_name = data.get('obraName')
            
            print(f"üîÑ [RECARREGAMENTO] A√ß√£o: {action}, Obra: {obra_name} (ID: {obra_id})")
            
            if action == 'undo':
                print(f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o da obra {obra_name} - mantendo na sess√£o")
            elif action == 'undo_no_data':
                print(f"‚Ü©Ô∏è Usu√°rio desfez exclus√£o (dados insuficientes) - recarregando p√°gina")
            elif action.startswith('timeout'):
                print(f"‚è∞ Timeout completo - obra {obra_name} removida da sess√£o")
            
            return {
                "reload_required": True,
                "action": action,
                "obra_id": obra_id,
                "obra_name": obra_name,
                "message": "P√°gina ser√° recarregada",
                "reload_delay": 500
            }
            
            print(f"‚úÖ Comando de recarregamento enviado para o frontend")
                
        except Exception as e:
            print(f"‚ùå Erro no recarregamento: {str(e)}")
            return {
                "reload_required": True,
                "error": str(e),
                "message": "Recarregamento for√ßado devido a erro"
            }

    # ========== ROTAS DE COMPATIBILIDADE ==========

    def handle_get_projetos(self):
        """COMPATIBILIDADE: Retorna array vazio"""
        print("‚ö†Ô∏è  AVISO: handle_get_projetos() - m√©todo legado, retornando vazia")
        return []

    def handle_delete_sessions_remove_project(self, project_id):
        """COMPATIBILIDADE: Remove projeto/obra da sess√£o"""
        try:
            print(f"üóëÔ∏è  [COMPAT] Removendo projeto/obra {project_id} da sess√£o")
            
            success = self.sessions_manager.remove_obra(project_id)
            
            if success:
                return {
                    "success": True, 
                    "message": f"Obra {project_id} removida da sess√£o"
                }
                print(f"‚úÖ Obra {project_id} removida da sess√£o via rota de compatibilidade")
            else:
                print(f"‚ùå Falha ao remover obra {project_id} da sess√£o")
                return {"success": False, "error": "Erro ao remover obra da sess√£o"}
                
        except Exception as e:
            print(f"‚ùå Erro ao remover obra da sess√£o: {str(e)}")
            return {"success": False, "error": str(e)}
/* ==== FIM: servidor_modules/core/routes_core.py ==== */

/* ==== IN√çCIO: servidor_modules/core/server_core.py ==== */
"""
server_core.py
N√∫cleo principal do servidor - L√≥gica centralizada
"""

import socket
import socketserver
import threading
import time
import signal
import sys
import subprocess
import os
from pathlib import Path

class ServerCore:
    """N√∫cleo principal do servidor com todas as funcionalidades essenciais"""
    
    def __init__(self):
        self.servidor_rodando = True
        self.project_root = self._find_project_root()
        
    def _find_project_root(self):
        """Encontra a raiz do projeto"""
        current_dir = Path(__file__).parent.parent.parent
        return current_dir

    def is_port_in_use(self, port):
        """Verifica se uma porta est√° em uso"""
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)
            try:
                s.bind(('localhost', port))
                return False
            except socket.error:
                return True

    def kill_process_on_port(self, port):
        """Tenta finalizar processos na porta"""
        try:
            if sys.platform == "win32":
                result = subprocess.run(
                    ['netstat', '-ano'], 
                    capture_output=True, 
                    text=True,
                    encoding='utf-8',
                    errors='ignore'
                )
                
                for line in result.stdout.split('\n'):
                    if f':{port}' in line and 'LISTENING' in line:
                        parts = line.split()
                        if len(parts) >= 5:
                            pid = parts[-1]
                            if pid.isdigit():
                                print(f"üîÑ Liberando porta {port} (PID: {pid})...")
                                try:
                                    subprocess.run(
                                        ['taskkill', '/PID', pid, '/F'], 
                                        capture_output=True,
                                        timeout=5
                                    )
                                    time.sleep(1)
                                    if not self.is_port_in_use(port):
                                        return True
                                except subprocess.TimeoutExpired:
                                    print(f"‚è∞ Timeout ao tentar finalizar processo {pid}")
                                except Exception as e:
                                    print(f"‚ö†Ô∏è Erro ao finalizar processo: {e}")
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è  Aviso ao liberar porta: {e}")
            return False

    def find_available_port(self, start_port=8000, max_attempts=15):
        """Encontra uma porta dispon√≠vel"""
        for port in range(start_port, start_port + max_attempts):
            if not self.is_port_in_use(port):
                return port
        
        import random
        for attempt in range(10):
            port = random.randint(8000, 9000)
            if not self.is_port_in_use(port):
                print(f"üéØ Usando porta alternativa: {port}")
                return port
        
        print("‚ùå N√£o foi poss√≠vel encontrar porta dispon√≠vel")
        return None

    def setup_port(self, default_port):
        """Configura a porta do servidor"""
        print(f"üîß Configurando porta do servidor...")
        
        if not self.is_port_in_use(default_port):
            print(f"‚úÖ Porta {default_port} dispon√≠vel")
            return default_port
        
        print(f"‚ö†Ô∏è  Porta {default_port} ocupada. Tentando liberar...")
        
        if self.kill_process_on_port(default_port):
            time.sleep(2)
            if not self.is_port_in_use(default_port):
                print(f"‚úÖ Porta {default_port} liberada com sucesso!")
                return default_port
        
        print("üîÑ Buscando porta alternativa...")
        available_port = self.find_available_port(default_port)
        
        if available_port:
            print(f"üîÄ Usando porta alternativa: {available_port}")
            return available_port
        else:
            print("‚ùå N√£o foi poss√≠vel encontrar porta dispon√≠vel")
            return None

    def setup_signal_handlers(self):
        """Configura handlers de sinal"""
        try:
            signal.signal(signal.SIGINT, self.signal_handler)
            signal.signal(signal.SIGTERM, self.signal_handler)
            print("‚úÖ Handlers de sinal configurados")
        except Exception as e:
            print(f"‚ö†Ô∏è  Aviso na configura√ß√£o de sinais: {e}")

    def signal_handler(self, signum, frame):
        """Manipulador de sinais do sistema"""
        print(f"\nüîÑ Recebido sinal {signum}. Encerrando graceful...")
        self.servidor_rodando = False

    def create_server(self, port, handler_class):
        """Cria inst√¢ncia do servidor"""
        try:
            server = socketserver.TCPServer(("", port), handler_class)
            server.timeout = 1  # 1 segundo timeout
            server.allow_reuse_address = True
            print(f"‚úÖ Servidor criado na porta {port}")
            return server
        except Exception as e:
            print(f"‚ùå Erro ao criar servidor: {e}")
            raise

    def print_server_info(self, port):
        """Exibe informa√ß√µes do servidor"""
        print(f"\nüéâ SERVIDOR INICIADO COM SUCESSO!")
        print("=" * 50)
        print(f"üåê URL: http://localhost:{port}/public/pages/01_Create_Obras.html")
        print("=" * 50)
        print("üìã CONTROLES:")
        print("   ‚Ä¢ Pressione Ctrl+C para PARAR o servidor")
        print("   ‚Ä¢ Feche o navegador para encerramento autom√°tico")
        print("   ‚Ä¢ Seu trabalho √© salvo automaticamente")
        print("=" * 50)

    def open_browser(self, port=8000):
        """Abre o navegador automaticamente"""
        time.sleep(2)
        
        url = f"http://localhost:{port}/public/pages/01_Create_Obras.html"
        print(f"üåê Abrindo aplica√ß√£o: {url}")
        
        try:
            import webbrowser
            webbrowser.open(url)
            print("‚úÖ Navegador iniciado com sucesso!")
        except Exception as e:
            print(f"‚ö†Ô∏è  N√£o foi poss√≠vel abrir navegador automaticamente: {e}")
            print(f"üí° Acesse manualmente: {url}")

    def start_server_threads(self, port, httpd, monitor_function):
        """Inicia threads auxiliares"""
        try:
            browser_thread = threading.Thread(target=self.open_browser, args=(port,), daemon=True)
            browser_thread.start()
            
            monitor_thread = threading.Thread(target=monitor_function, args=(port, httpd), daemon=True)
            monitor_thread.start()
            
            print("\nüü¢ SISTEMA PRONTO!")
            print("   Aplica√ß√£o carregada no navegador")
            print("   Trabalhe normalmente - tudo √© salvo automaticamente\n")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao iniciar threads: {e}")

    def run_server_loop(self, httpd):
        """Loop principal do servidor"""
        print("üîÑ Servidor em execu√ß√£o...")
        
        while self.servidor_rodando:
            try:
                httpd.handle_request()
            except socket.timeout:
                continue  
            except KeyboardInterrupt:
                print("\n‚èπÔ∏è  Interrup√ß√£o pelo usu√°rio detectada")
                self.servidor_rodando = False
                break
            except Exception as e:
                if self.servidor_rodando:
                    print(f"‚ö†Ô∏è  Erro n√£o cr√≠tico no servidor: {e}")
                    time.sleep(1)
                    continue
                else:
                    break
        
        print("üëã Encerramento solicitado...")

    def shutdown_server_async(self, httpd, cache_cleaner):
        """Desligamento graceful do servidor"""
        def shutdown_task():
            try:
                print("üîÑ Finalizando conex√µes do servidor...")
                httpd.shutdown()
                httpd.server_close()
                print("‚úÖ Conex√µes do servidor finalizadas")
                
                # Limpeza de cache
                print("üîÑ Iniciando limpeza de cache...")
                cache_cleaner.clean_pycache_async()
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Aviso no encerramento: {e}")
        
        shutdown_thread = threading.Thread(target=shutdown_task, daemon=True)
        shutdown_thread.start()
        
        shutdown_thread.join(timeout=8.0)
        
        if shutdown_thread.is_alive():
            print("‚è∞ Timeout no encerramento - finalizando for√ßadamente...")
            try:
                httpd.server_close()
            except:
                pass
/* ==== FIM: servidor_modules/core/server_core.py ==== */

/* ==== IN√çCIO: servidor_modules/utils/server_utils.py ==== */
"""
server_utils.py
Utilit√°rios do servidor - Vers√£o Simplificada
"""

import socket
import socketserver
import threading
import time
import signal
import sys
import subprocess
import os
from pathlib import Path

class ServerUtils:
    """Utilit√°rios do servidor - Mantido para compatibilidade"""
    
    @staticmethod
    def setup_signal_handlers():
        """Configura handlers de sinal"""
        try:
            signal.signal(signal.SIGINT, lambda s, f: print("\nüîÑ Encerrando..."))
            signal.signal(signal.SIGTERM, lambda s, f: print("\nüîÑ Encerrando..."))
            print("‚úÖ Handlers de sinal configurados")
        except Exception as e:
            print(f"‚ö†Ô∏è  Aviso na configura√ß√£o de sinais: {e}")

    @staticmethod
    def print_server_info(port):
        """Exibe informa√ß√µes do servidor"""
        print(f"\nüéâ SERVIDOR INICIADO COM SUCESSO!")
        print("=" * 50)
        print(f"üåê URL: http://localhost:{port}/public/pages/01_Create_Obras.html")
        print("=" * 50)

    @staticmethod
    def open_browser(port=8000):
        """Abre o navegador automaticamente"""
        time.sleep(2)
        
        url = f"http://localhost:{port}/public/pages/01_Create_Obras.html"
        print(f"üåê Abrindo aplica√ß√£o: {url}")
        
        try:
            import webbrowser
            webbrowser.open(url)
            print("‚úÖ Navegador iniciado com sucesso!")
        except Exception as e:
            print(f"‚ö†Ô∏è  N√£o foi poss√≠vel abrir navegador automaticamente: {e}")
            print(f"üí° Acesse manualmente: {url}")

    @staticmethod
    def start_server_threads(port, httpd, monitor_function):
        """Inicia threads auxiliares"""
        try:
            browser_thread = threading.Thread(target=ServerUtils.open_browser, args=(port,), daemon=True)
            browser_thread.start()
            
            monitor_thread = threading.Thread(target=monitor_function, args=(port, httpd), daemon=True)
            monitor_thread.start()
            
            print("\nüü¢ SISTEMA PRONTO!")
            print("   Aplica√ß√£o carregada no navegador")
            print("   Trabalhe normalmente - tudo √© salvo automaticamente\n")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao iniciar threads: {e}")
/* ==== FIM: servidor_modules/utils/server_utils.py ==== */

/* ==== IN√çCIO: servidor.py ==== */
#!/usr/bin/env python3
"""
servidor.py
Sistema de Climatiza√ß√£o - Servidor Principal REORGANIZADO
"""

import os
import sys
import time
import traceback
import threading

# Adiciona o diret√≥rio atual ao path para garantir imports
diretorio_atual = os.path.dirname(os.path.abspath(__file__))
if diretorio_atual not in sys.path:
    sys.path.insert(0, diretorio_atual)

print("=" * 60)
print("SISTEMA DE CLIMATIZA√á√ÉO - INICIANDO DIAGN√ìSTICO")
print("=" * 60)

def diagnostico_completo():
    """Faz diagn√≥stico completo do sistema"""
    print("\n1. VERIFICANDO DIRET√ìRIOS...")
    print(f"   Diret√≥rio atual: {diretorio_atual}")
    print(f"   Pasta json: {os.path.exists(os.path.join(diretorio_atual, 'json'))}")
    print(f"   Pasta servidor_modules: {os.path.exists(os.path.join(diretorio_atual, 'servidor_modules'))}")
    
    print("\n2. VERIFICANDO ARQUIVOS...")
    arquivos = [
        'servidor.py',
        'servidor_modules/__init__.py',
        'servidor_modules/config.py', 
        'servidor_modules/core/__init__.py',
        'servidor_modules/core/server_core.py',
        'servidor_modules/core/routes_core.py',
        'servidor_modules/core/sessions_core.py',
        'servidor_modules/handlers/__init__.py',
        'servidor_modules/handlers/http_handler.py',
        'servidor_modules/handlers/route_handler.py',
        'servidor_modules/utils/__init__.py',
        'servidor_modules/utils/file_utils.py',
        'servidor_modules/utils/server_utils.py',
        'servidor_modules/utils/cache_cleaner.py',
        'servidor_modules/utils/browser_monitor.py',
        'json/backup.json',
        'json/dados.json',
        'json/sessions.json'
    ]
    
    for arquivo in arquivos:
        caminho = os.path.join(diretorio_atual, arquivo)
        existe = os.path.exists(caminho)
        status = "‚úÖ" if existe else "‚ùå"
        print(f"   {status} {arquivo}: {existe}")

# Executa diagn√≥stico primeiro
diagnostico_completo()

# Agora tenta importar os m√≥dulos
try:
    print("\n4. IMPORTANDO M√ìDULOS...")
    from servidor_modules.core.server_core import ServerCore
    from servidor_modules.handlers.http_handler import UniversalHTTPRequestHandler
    from servidor_modules.utils.browser_monitor import monitorar_navegador
    from servidor_modules.core.sessions_core import SessionsManager
    from servidor_modules.utils.cache_cleaner import CacheCleaner
    from servidor_modules.utils.file_utils import FileUtils
    
    print("   ‚úÖ M√≥dulos importados com sucesso!")
    
except ImportError as e:
    print(f"   ‚ùå ERRO DE IMPORTA√á√ÉO: {e}")
    print(f"   TRACEBACK:")
    traceback.print_exc()
    print("\nPressione Enter para sair...")
    input()
    sys.exit(1)

def active_session_after_delay(interval_seconds, server_core):
    """Mostra tempo de execu√ß√£o a cada intervalo"""
    def monitor():
        start_time = time.time()
        last_report = 0
        
        while server_core.servidor_rodando:
            try:
                elapsed_time = time.time() - start_time
                
                if elapsed_time >= last_report + interval_seconds:
                    hours = int(elapsed_time // 3600)
                    minutes = int((elapsed_time % 3600) // 60)
                    seconds = int(elapsed_time % 60)
                    
                    if hours > 0:
                        print(f"‚è∞ Monitoramento: Servidor ativo h√° {hours}h{minutes:02d}min{seconds:02d}s")
                    elif minutes > 0:
                        print(f"‚è∞ Monitoramento: Servidor ativo h√° {minutes}min{seconds:02d}s")
                    else:
                        print(f"‚è∞ Monitoramento: Servidor ativo h√° {seconds}s")
                    
                    last_report = elapsed_time
                
                time.sleep(0.1)
                
            except Exception as e:
                print(f"‚ùå Erro no monitor: {e}")
                break
    
    monitor_thread = threading.Thread(target=monitor)
    monitor_thread.daemon = True
    monitor_thread.start()
    print(f"üîî Monitor ativado: mostrando tempo a cada {interval_seconds} segundos")

def main():
    """Fun√ß√£o principal com nova estrutura"""
    try:
        print("\n5. INICIANDO SERVIDOR...")
        
        # Inicializa componentes
        server_core = ServerCore()
        cache_cleaner = CacheCleaner()
        file_utils = FileUtils()
        sessions_manager = SessionsManager()
        
        # Configura√ß√£o
        print("   Configurando handlers de sinal...")
        server_core.setup_signal_handlers()
        
        # Configura porta
        print("   Configurando porta...")
        port = server_core.setup_port(8000)
        if not port:
            print("   ‚ùå N√£o foi poss√≠vel configurar porta")
            print("Pressione Enter para sair...")
            input()
            return
        
        print(f"   ‚úÖ Porta {port} configurada")
        
        # Inicializa√ß√£o do servidor
        print("   Criando servidor...")
        with server_core.create_server(port, UniversalHTTPRequestHandler) as httpd:
            # Informa√ß√µes do sistema
            server_core.print_server_info(port)
            
            # Inicializa√ß√£o das threads
            print("   Iniciando threads...")
            server_core.start_server_threads(port, httpd, monitorar_navegador)
            
            print("   ‚úÖ SERVIDOR INICIADO COM SUCESSO!")
            print("   üü¢ SISTEMA OPERACIONAL")
            
            # Ativar monitor de tempo
            active_session_after_delay(1200, server_core)
            
            # Loop principal
            server_core.run_server_loop(httpd)
            
    except KeyboardInterrupt:
        print("\n   ‚èπÔ∏è  Encerramento solicitado pelo usu√°rio (Ctrl+C)")
        server_core.servidor_rodando = False
    except Exception as e:
        print(f"\n   ‚ùå ERRO CR√çTICO: {e}")
        print("   TRACEBACK COMPLETO:")
        traceback.print_exc()
        print("\n   O sistema ser√° finalizado em 10 segundos...")
        time.sleep(10)
    finally:
        print("\n   üî¥ Servidor finalizado!")
        
        # Garantir shutdown
        try:
            if 'httpd' in locals() and 'server_core' in locals():
                print("   üîÑ Executando shutdown ass√≠ncrono...")
                server_core.shutdown_server_async(httpd, cache_cleaner)
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Erro no shutdown: {e}")
        
        print("   ‚è≥ Aguardando finaliza√ß√£o dos processos...")
        time.sleep(2)
        
        print("   üö™ Encerrando processo Python...")
        os._exit(0)     
        
if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"ERRO FATAL: {e}")
        traceback.print_exc()
        os._exit(1)
/* ==== FIM: servidor.py ==== */

/* ==== IN√çCIO: servidor_modules/core/sessions_core.py ==== */
"""
sessions_core.py
Gerenciador de sess√µes -  e Otimizada
"""

import json
import time
import os
from pathlib import Path

class SessionsManager:
    """
    Gerenciador de sess√µes para sistema que come√ßa vazio
    Gerencia uma √∫nica sess√£o ativa com lista de obras
    """
    
    def __init__(self):
        # Usa caminho absoluto baseado na localiza√ß√£o do arquivo
        current_file = Path(__file__)  # sessions_core.py
        project_root = current_file.parent.parent.parent  # sobe para pasta codigo
        self.sessions_dir = project_root / "json"  # pasta json dentro de codigo
        self.sessions_file = self.sessions_dir / "sessions.json"
        
        print(f"SessionsManager: Inicializando em {self.sessions_dir}")
        self.ensure_sessions_file()
    
    def ensure_sessions_file(self):
        """Garante que o arquivo de sess√µes existe com estrutura vazia"""
        try:
            # Cria diret√≥rio se n√£o existir
            self.sessions_dir.mkdir(parents=True, exist_ok=True)
            print(f"SessionsManager: Pasta json verificada: {self.sessions_dir.exists()}")
            
            if not self.sessions_file.exists():
                print("SessionsManager: Criando arquivo sessions.json vazio")
                self._initialize_sessions_file()
            else:
                print("SessionsManager: Arquivo sessions.json j√° existe")
                
        except Exception as e:
            print(f"ERRO em ensure_sessions_file: {e}")
            raise
    
    def _initialize_sessions_file(self):
        """Inicializa o arquivo de sess√µes com estrutura vazia"""
        initial_data = {
            "sessions": {
                "session_active": {  
                    "obras": []      
                }
            }
        }
        self._save_sessions_data(initial_data)
    
    def get_current_session_id(self) -> str:
        """Retorna o ID da sess√£o ativa"""
        return "session_active"

    def add_obra_to_session(self, obra_id: str) -> bool:
        """Adiciona uma obra √† sess√£o ativa"""
        data = self._load_sessions_data()
        current_session_id = self.get_current_session_id()
        
        # Garante que existe apenas a sess√£o ativa
        data["sessions"] = {
            current_session_id: data["sessions"].get(current_session_id, {"obras": []})
        }
        
        # Adiciona ID da obra se n√£o existir
        obra_id_str = str(obra_id)
        if obra_id_str not in data["sessions"][current_session_id]["obras"]:
            data["sessions"][current_session_id]["obras"].append(obra_id_str)
            print(f"‚úÖ Obra {obra_id_str} adicionada √† sess√£o {current_session_id}")
        
        return self._save_sessions_data(data)

    def remove_obra(self, obra_id: str) -> bool:
        """Remove uma obra da sess√£o ativa"""
        data = self._load_sessions_data()
        current_session_id = self.get_current_session_id()
        obra_id_str = str(obra_id)
        
        print(f"üîç Tentando remover obra {obra_id_str} da sess√£o {current_session_id}")
        print(f"üìä Obras na sess√£o antes: {data['sessions'][current_session_id]['obras']}")
        
        if (current_session_id in data["sessions"] and 
            obra_id_str in data["sessions"][current_session_id]["obras"]):
            
            # Remove o ID da obra
            data["sessions"][current_session_id]["obras"].remove(obra_id_str)
            print(f"üóëÔ∏è Obra {obra_id_str} removida da sess√£o {current_session_id}")
            
            # Salva os dados atualizados
            success = self._save_sessions_data(data)
            
            # Verifica se realmente foi removido
            if success:
                updated_data = self._load_sessions_data()
                still_exists = obra_id_str in updated_data["sessions"][current_session_id]["obras"]
                if still_exists:
                    print(f"‚ùå ERRO: Obra {obra_id_str} ainda est√° na sess√£o ap√≥s remo√ß√£o!")
                    return False
                else:
                    print(f"‚úÖ Obra {obra_id_str} removida com sucesso")
                    print(f"üìä Obras na sess√£o depois: {updated_data['sessions'][current_session_id]['obras']}")
                    return True
            else:
                print(f"‚ùå ERRO: Falha ao salvar dados ap√≥s remo√ß√£o da obra {obra_id_str}")
                return False
        
        print(f"‚ö†Ô∏è Obra {obra_id_str} n√£o encontrada na sess√£o {current_session_id}")
        return False

    def remove_obra_from_session(self, obra_id: str) -> dict:
        """Remove uma obra da sess√£o ativa - para uso com modal"""
        try:
            obra_id_str = str(obra_id)
            print(f"üóëÔ∏è [MODAL] Tentando remover obra {obra_id_str} da sess√£o")
            
            # Carrega dados atuais
            data = self._load_sessions_data()
            current_session_id = self.get_current_session_id()
            
            # Verifica se a obra existe na sess√£o
            if (current_session_id in data["sessions"] and 
                obra_id_str in data["sessions"][current_session_id]["obras"]):
                
                # Remove a obra
                data["sessions"][current_session_id]["obras"].remove(obra_id_str)
                print(f"‚úÖ Obra {obra_id_str} removida da sess√£o")
                
                # Salva os dados
                if self._save_sessions_data(data):
                    # Verifica se realmente foi removido
                    updated_data = self._load_sessions_data()
                    still_exists = obra_id_str in updated_data["sessions"][current_session_id]["obras"]
                    
                    if not still_exists:
                        return {
                            'success': True, 
                            'message': 'Obra removida da sess√£o',
                            'reload_required': True
                        }
                    else:
                        return {
                            'success': False, 
                            'error': 'Obra ainda est√° na sess√£o ap√≥s remo√ß√£o',
                            'reload_required': True
                        }
                else:
                    return {
                        'success': False, 
                        'error': 'Falha ao salvar sess√£o',
                        'reload_required': True
                    }
            else:
                print(f"‚ö†Ô∏è Obra {obra_id_str} n√£o encontrada na sess√£o")
                return {
                    'success': True, 
                    'message': 'Obra n√£o estava na sess√£o', 
                    'reload_required': True
                }
                
        except Exception as e:
            print(f"‚ùå Erro ao remover obra {obra_id} da sess√£o: {e}")
            return {
                'success': False, 
                'error': str(e),
                'reload_required': True
            }

    def check_obra_in_session(self, obra_id: str) -> dict:
        """Verifica se uma obra est√° na sess√£o ativa"""
        try:
            data = self._load_sessions_data()
            current_session_id = self.get_current_session_id()
            
            exists = (current_session_id in data["sessions"] and 
                     str(obra_id) in data["sessions"][current_session_id]["obras"])
            
            return {
                'exists': exists,
                'obra_id': obra_id
            }
        except Exception as e:
            print(f"‚ùå Erro ao verificar obra {obra_id} na sess√£o: {e}")
            return {'exists': False, 'error': str(e)}
    
    def get_session_obras(self) -> list:
        """Retorna lista de IDs de obras da sess√£o ativa"""
        data = self._load_sessions_data()
        current_session_id = self.get_current_session_id()
        
        return data["sessions"].get(current_session_id, {"obras": []})["obras"]

    def add_project_to_session(self, project_id: str) -> bool:
        """M√©todo de compatibilidade: converte projetos para obras"""
        print(f"üîÑ [COMPAT] Convertendo projeto {project_id} para obra")
        
        # Em sistemas atualizados, project_id J√Å √â o obra_id
        obra_id = str(project_id)
        
        # Se for um ID num√©rico antigo, mant√©m para compatibilidade
        if obra_id.isdigit():
            print(f"üìù [COMPAT] ID num√©rico legado: {obra_id}")
        else:
            print(f"üìù [COMPAT] ID seguro moderno: {obra_id}")
        
        return self.add_obra_to_session(obra_id)

    def remove_project(self, project_id: str) -> bool:
        """M√©todo de compatibilidade: remove projetos (legado)"""
        print(f"‚ö†Ô∏è  AVISO: remove_project({project_id}) - m√©todo legado")
        
        # Para compatibilidade, n√£o remove nada
        return True

    def get_session_projects(self) -> list:
        """M√©todo de compatibilidade: retorna lista vazia (legado)"""
        print("‚ö†Ô∏è  AVISO: get_session_projects() - m√©todo legado, retornando vazia")
        return []

    def clear_session(self) -> bool:
        """Limpa completamente todas as sess√µes"""
        print("SHUTDOWN: Limpando sess√£o ativa")
        
        # Mant√©m estrutura mas limpa as obras
        data = {
            "sessions": {
                "session_active": {
                    "obras": []  # Sempre volta vazia
                }
            }
        }
        
        success = self._save_sessions_data(data)
        
        if success:
            # Confirma√ß√£o
            final_data = self._load_sessions_data()
            print(f"sessions.json ap√≥s limpeza: {final_data}")
            return True
        else:
            print("ERRO: N√£o foi poss√≠vel limpar sess√£o ativa")
            return False
   
    def force_clear_all_sessions(self) -> bool:
        """For√ßa a limpeza total deletando e recriando o arquivo"""
        try:
            # Deleta fisicamente o arquivo e recria vazio
            if self.sessions_file.exists():
                self.sessions_file.unlink()
                print("Arquivo sessions.json deletado fisicamente")
            
            # Recria com sess√£o ativa vazia
            self._initialize_sessions_file()
            print("Arquivo sessions.json recriado com sess√£o ativa vazia")
            
            return True
        except Exception as e:
            print(f"Erro ao for√ßar limpeza: {e}")
            return False

    def ensure_single_session(self) -> bool:
        """Garante que apenas uma sess√£o ativa exista"""
        data = self._load_sessions_data()
        current_session_id = self.get_current_session_id()
        
        # Mant√©m apenas a sess√£o ativa
        current_obras = data["sessions"].get(current_session_id, {"obras": []})["obras"]
        
        # Remove todas as outras sess√µes
        data["sessions"] = {
            current_session_id: {
                "obras": current_obras
            }
        }
        
        print(f"‚úÖ Sess√£o √∫nica garantida: {current_session_id} com {len(current_obras)} obras")
        return self._save_sessions_data(data)
    
    def _load_sessions_data(self) -> dict:
        """Carrega os dados das sess√µes do arquivo"""
        try:
            if self.sessions_file.exists():
                with open(self.sessions_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Garante estrutura b√°sica
                if "sessions" not in data:
                    data["sessions"] = {}
                
                # Cria sess√£o ativa vazia se n√£o existir
                if "session_active" not in data["sessions"]:
                    data["sessions"] = {
                        "session_active": {"obras": []}
                    }
                    print("‚úÖ Sess√£o ativa vazia criada")
                
                # Garante que cada sess√£o tem "obras" 
                for session_id, session_data in data["sessions"].items():
                    if "obras" not in session_data:
                        session_data["obras"] = []
                
                return data
            else:
                return {"sessions": {"session_active": {"obras": []}}}
                
        except (FileNotFoundError, json.JSONDecodeError):
            return {"sessions": {"session_active": {"obras": []}}}
    
    def _save_sessions_data(self, data: dict) -> bool:
        """Salva os dados das sess√µes no arquivo"""
        try:
            # Garante que o diret√≥rio existe
            self.sessions_dir.mkdir(parents=True, exist_ok=True)
            
            with open(self.sessions_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            # Verifica se o arquivo foi realmente criado/atualizado
            if self.sessions_file.exists():
                print(f"‚úÖ Arquivo sessions.json salvo com sucesso: {self.sessions_file}")
                return True
            else:
                print(f"‚ùå ERRO: Arquivo sessions.json n√£o foi criado: {self.sessions_file}")
                return False
                
        except Exception as e:
            print(f"‚ùå ERRO ao salvar sessions: {e}")
            return False

    def get_current_session(self) -> dict:
        """Retorna a sess√£o atual completa"""
        data = self._load_sessions_data()
        current_session_id = self.get_current_session_id()
        
        # Retorna apenas a sess√£o ativa
        return {
            "sessions": {
                current_session_id: data["sessions"].get(current_session_id, {"obras": []})
            }
        }

    def debug_sessions(self):
        """M√©todo de debug para verificar o estado das sess√µes"""
        data = self._load_sessions_data()
        print("=== DEBUG SESSIONS ===")
        print(f"Sess√µes encontradas: {len(data['sessions'])}")
        for session_id, session_data in data["sessions"].items():
            print(f"  {session_id}: {len(session_data.get('obras', []))} obras")
        print("======================")

# Inst√¢ncia global com tratamento de erro
try:
    sessions_manager = SessionsManager()
    print("‚úÖ SessionsManager CORRIGIDO inicializado com sucesso!")
    
    # For√ßa sess√£o √∫nica na inicializa√ß√£o
    sessions_manager.ensure_single_session()
    sessions_manager.debug_sessions()
    
except Exception as e:
    print(f"‚ùå ERRO CR√çTICO no SessionsManager: {e}")
    
    # Gerenciador de sess√µes de emerg√™ncia
    class EmergencySessionsManager:
        """Gerenciador de sess√µes de emerg√™ncia CORRIGIDO"""
        
        def __init__(self):
            self.project_root = Path(__file__).parent.parent.parent
            print(f"‚ö†Ô∏è  Usando EmergencySessionsManager CORRIGIDO: {self.project_root}")
        
        def get_current_session_id(self):
            return "session_active"
        
        def add_obra_to_session(self, obra_id):
            print(f"‚úÖ [EMERGENCY] Obra {obra_id} adicionada √† sess√£o ativa")
            return True

        def remove_obra(self, obra_id):
            print(f"‚úÖ [EMERGENCY] Obra {obra_id} removida da sess√£o ativa")
            return True

        def remove_obra_from_session(self, obra_id):
            print(f"‚úÖ [EMERGENCY] Obra {obra_id} removida da sess√£o ativa (modal)")
            return {'success': True, 'message': 'Obra removida', 'reload_required': True}

        def check_obra_in_session(self, obra_id):
            print(f"‚úÖ [EMERGENCY] Verificando obra {obra_id} na sess√£o")
            return {'exists': False, 'obra_id': obra_id}

        def get_session_obras(self):
            return []
            
        def get_current_session(self):
            return {"sessions": {"session_active": {"obras": []}}}
        
        def add_project_to_session(self, project_id):
            print(f"üîÑ [EMERGENCY] Convertendo projeto {project_id} para obra")
            return self.add_obra_to_session(project_id)
            
        def remove_project(self, project_id):
            return True
            
        def get_session_projects(self):
            return []

        def clear_session(self):
            return True

        def force_clear_all_sessions(self):
            return True

        def ensure_single_session(self):
            return True
            
        def debug_sessions(self):
            print("=== DEBUG EMERGENCY SESSIONS ===")
            print("session_active: 0 obras")
            print("================================")
    
    sessions_manager = EmergencySessionsManager()
/* ==== FIM: servidor_modules/core/sessions_core.py ==== */
