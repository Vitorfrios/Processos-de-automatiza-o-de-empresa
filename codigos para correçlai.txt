/**
 * data-builders.js
 * M√≥dulo de constru√ß√£o de objetos de dados
 * Respons√°vel por criar estruturas de obras, projetos e salas COM IDs √öNICOS
 */

// Importa√ß√µes necess√°rias
import { generateObraId, generateProjectId, generateRoomId, getObraName, getProjectName, getRoomName } from './data-utils-core.js'
import { extractClimatizationInputs, extractMachinesData, extractCapacityData, extractThermalGainsData, extractConfigurationData } from './data-extractors.js'

/**
 * Constr√≥i o objeto de dados completo de uma obra a partir do HTML
 * @param {string|HTMLElement} obraIdOrElement - ID da obra ou elemento HTML
 * @returns {Object|null} Dados completos da obra ou null em caso de erro
 */
function buildObraData(obraIdOrElement) {
    let obraElement
    
    if (typeof obraIdOrElement === 'string') {
        obraElement = document.querySelector(`.obra-block[data-obra-id="${obraIdOrElement}"]`) || 
                     document.querySelector(`.obra-block[data-obra-name="${obraIdOrElement}"]`)
    } else if (obraIdOrElement instanceof HTMLElement) {
        if (obraIdOrElement.classList.contains('obra-block')) {
            obraElement = obraIdOrElement
        } else {
            console.error('‚ùå Elemento n√£o √© uma obra:', obraIdOrElement)
            return null
        }
    } else {
        console.error('‚ùå Tipo inv√°lido para obraIdOrElement:', typeof obraIdOrElement, obraIdOrElement)
        return null
    }

    if (!obraElement) {
        console.error('‚ùå Elemento da obra n√£o encontrado:', obraIdOrElement)
        return null
    }

    const obraName = obraElement.dataset.obraName
    const obraId = obraElement.dataset.obraId

    console.log(`üì¶ Construindo dados da obra: "${obraName}" (ID: ${obraId})`)

    // ‚úÖ CORRE√á√ÉO: SEMPRE usar ID √∫nico, mesmo se j√° existir (para consist√™ncia)
    const finalObraId = obraId || generateObraId()
    
    const obraData = {
        id: finalObraId, // ‚úÖ ID √öNICO CURTO
        nome: getObraName(obraElement),
        timestamp: new Date().toISOString(),
        projetos: []
    }

    const projectElements = obraElement.querySelectorAll('.project-block')
    console.log(`üîç Encontrados ${projectElements.length} projetos na obra "${obraName}"`)
    
    projectElements.forEach((projectElement, index) => {
        const projectData = buildProjectData(projectElement)
        if (projectData) {
            obraData.projetos.push(projectData)
            console.log(`‚úÖ Projeto "${projectData.nome}" adicionado √† obra "${obraName}"`)
        } else {
            console.error(`‚ùå Falha ao construir projeto ${index} da obra "${obraName}"`)
        }
    })

    console.log('üì¶ Dados da obra constru√≠dos:', {
        obra: obraData.nome,
        id: obraData.id,
        projetos: obraData.projetos.length
    })
    
    return obraData
}

/**
 * Constr√≥i o objeto de dados completo de um projeto a partir do HTML
 * @param {string|HTMLElement} projectIdOrElement - ID do projeto ou elemento HTML
 * @returns {Object|null} Dados completos do projeto ou null em caso de erro
 */
function buildProjectData(projectIdOrElement) {
    let projectElement
    
    if (typeof projectIdOrElement === 'string') {
        projectElement = document.querySelector(`[data-project-name="${projectIdOrElement}"]`)
    } else if (projectIdOrElement instanceof HTMLElement) {
        projectElement = projectIdOrElement
    } else {
        console.error('‚ùå Tipo inv√°lido para projectIdOrElement:', projectIdOrElement)
        return null
    }

    if (!projectElement) {
        console.error('‚ùå Elemento do projeto n√£o encontrado:', projectIdOrElement)
        return null
    }

    const projectName = projectElement.dataset.projectName || projectElement.id
    const projectId = projectElement.dataset.projectId
    const obraElement = projectElement.closest('.obra-block')

    if (!obraElement) {
        console.error('‚ùå Elemento da obra pai n√£o encontrado para projeto:', projectName)
        return null
    }

    // ‚úÖ CORRE√á√ÉO: SEMPRE usar ID hier√°rquico √∫nico
    const finalProjectId = projectId || generateProjectId(obraElement)

    const projectData = {
        id: finalProjectId, // ‚úÖ ID HIER√ÅRQUICO √öNICO
        nome: getProjectName(projectElement),
        salas: [],
        timestamp: new Date().toISOString()
    }

    const roomElements = projectElement.querySelectorAll('.room-block')
    console.log(`üîç Encontradas ${roomElements.length} salas no projeto "${projectName}"`)
    
    roomElements.forEach((roomElement, index) => {
        const roomData = extractRoomData(roomElement, projectElement)
        if (roomData) {
            projectData.salas.push(roomData)
        }
    })

    return projectData
}

/**
 * Extrai todos os dados de uma sala a partir do elemento HTML
 * @param {HTMLElement} roomElement - Elemento HTML da sala
 * @param {HTMLElement} projectElement - Elemento HTML do projeto pai
 * @returns {Object|null} Dados completos da sala ou null em caso de erro
 */
function extractRoomData(roomElement, projectElement) {
    if (!roomElement) {
        console.error('‚ùå Elemento da sala √© nulo')
        return null
    }

    if (!projectElement) {
        console.error('‚ùå Elemento do projeto pai √© nulo')
        return null
    }

    // ‚úÖ CORRE√á√ÉO: SEMPRE usar ID hier√°rquico √∫nico
    const roomId = roomElement.dataset.roomId || generateRoomId(projectElement)
    const roomName = getRoomName(roomElement) || `Sala ${roomId}`

    console.log(`üîç Extraindo dados da sala: "${roomName}" (ID: ${roomId})`)

    const roomData = {
        id: roomId, // ‚úÖ ID HIER√ÅRQUICO √öNICO
        nome: roomName,
        inputs: extractClimatizationInputs(roomElement),
        maquinas: extractMachinesData(roomElement),
        capacidade: extractCapacityData(roomElement),
        ganhosTermicos: extractThermalGainsData(roomElement),
        configuracao: extractConfigurationData(roomElement)
    }

    console.log(`üìä Dados extra√≠dos da sala ${roomId} "${roomData.nome}":`, {
        inputs: Object.keys(roomData.inputs).length,
        maquinas: roomData.maquinas.length,
        capacidade: Object.keys(roomData.capacidade).length,
        ganhosTermicos: Object.keys(roomData.ganhosTermicos).length,
        configuracao: Object.keys(roomData.configuracao).length
    })
    
    return roomData
}

export {
    buildObraData,
    buildProjectData,
    extractRoomData
}
/**
 * data-utils-core.js
 * Utilit√°rios core e fun√ß√µes auxiliares
 * Gera√ß√£o de IDs SEGUROS E √öNICOS - SISTEMA CORRIGIDO
 */

// =============================================================================
// SISTEMA DE IDs SEGUROS E √öNICOS - CORRE√á√ÉO COMPLETA
// =============================================================================

/**
 * Gera um ID seguro baseado em letras + n√∫meros
 * @param {string} prefix - Prefixo para o ID
 * @returns {string} ID seguro
 * @generator @example obra_x87
 */
function generateSecureId(prefix = 'item') {
    // CARACTERES ASCII SEGUROS DO TECLADO (59 caracteres)
    const safeChars = 'abcdefghjkmnpqrstwxyzABCDEFGHJKMNPQRSTWXYZ0123456789-'; 
    
    // Gerar 8 caracteres aleat√≥rios usando Crypto API
    const randomValues = new Uint32Array(8);
    crypto.getRandomValues(randomValues);
    
    let id = prefix + '_';
    
    for (let i = 0; i < 4; i++) {
        const randomIndex = randomValues[i] % safeChars.length;
        id += safeChars[randomIndex];
    }
    
    return id;
}

/**
 * Gera ID √∫nico para obra - SEGURO E √öNICO
 * @returns {string} ID √∫nico da obra
 */
function generateObraId() {
    return generateSecureId('obra');
}

/**
 * Gera ID hier√°rquico seguro para projeto - SEGURO E √öNICO (VERS√ÉO CORRIGIDA)
 * @param {HTMLElement} obraElement - Elemento da obra pai
 * @param {number} projectNumber - N√∫mero sequencial do projeto
 * @returns {string} ID √∫nico do projeto
 */
function generateProjectId(obraElement, projectNumber) {
    if (!obraElement) {
        console.error(`ERRO FALBACK (generateProjectId) [Elemento da obra n√£o fornecido]`);
        return generateSecureId('proj');
    }
    
    const obraId = obraElement.dataset?.obraId;
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (generateProjectId) [Obra ID inv√°lido no dataset: ${obraId}]`);
        return generateSecureId('proj');
    }
    
    // ‚úÖ CORRE√á√ÉO: Se projectNumber for undefined, calcular automaticamente
    let finalProjectNumber = projectNumber;
    if (finalProjectNumber === undefined || finalProjectNumber === null) {
        console.warn(`‚ö†Ô∏è  projectNumber √© ${projectNumber}, calculando automaticamente...`);
        
        // Calcula contando projetos existentes
        const existingProjects = obraElement.querySelectorAll('[data-project-id]');
        finalProjectNumber = existingProjects.length + 1;
        console.log(`üìä Calculado: ${existingProjects.length} projetos + 1 = ${finalProjectNumber}`);
    }
    
    const projectPrefix = generateSecureId('proj').replace('proj_', '');
    const projectId = `${obraId}_proj_${projectPrefix}_${finalProjectNumber}`;
    
    console.log(`üÜï ID do projeto gerado: ${projectId}`);
    return projectId;
}

/**
 * Gera ID hier√°rquico seguro para sala - SEGURO E √öNICO
 * @param {HTMLElement} projectElement - Elemento do projeto pai
 * @param {number} roomNumber - N√∫mero sequencial da sala
 * @returns {string} ID √∫nico da sala
 */
function generateRoomId(projectElement, roomNumber) {
    if (!projectElement) {
        console.error(`ERRO FALBACK (generateRoomId) [Elemento do projeto n√£o fornecido]`);
        return generateSecureId('sala');
    }
    
    const projectId = projectElement.dataset?.projectId;
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (generateRoomId) [Project ID inv√°lido no dataset: ${projectId}]`);
        return generateSecureId('sala');
    }
    
    // ‚úÖ CORRE√á√ÉO: Se roomNumber for undefined, calcular automaticamente
    let finalRoomNumber = roomNumber;
    if (finalRoomNumber === undefined || finalRoomNumber === null) {
        console.warn(`‚ö†Ô∏è  roomNumber √© ${roomNumber}, calculando automaticamente...`);
        
        // Calcula contando salas existentes
        const existingRooms = projectElement.querySelectorAll('[data-room-id]');
        finalRoomNumber = existingRooms.length + 1;
        console.log(`üìä Calculado: ${existingRooms.length} salas + 1 = ${finalRoomNumber}`);
    }
    
    const roomPrefix = generateSecureId('sala').replace('sala_', '');
    const roomId = `${projectId}_sala_${roomPrefix}_${finalRoomNumber}`;
    
    console.log(`üÜï ID da sala gerado: ${roomId}`);
    return roomId;
}

// =============================================================================
// FUN√á√ïES DE NUMERA√á√ÉO - NOVAS FUN√á√ïES ADICIONADAS
// =============================================================================

/**
 * Obt√©m o pr√≥ximo n√∫mero de projeto dispon√≠vel PARA UMA OBRA ESPEC√çFICA - CORRIGIDO
 * @param {string} obraId - ID √∫nico da obra
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para projeto na obra espec√≠fica
 */
function getNextProjectNumber(obraId) {
  try {
    // ‚úÖ CORRE√á√ÉO: Buscar apenas projetos DESTA obra espec√≠fica
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
      console.warn(`‚ö†Ô∏è Obra ${obraId} n√£o encontrada, usando projeto 1`);
      return 1;
    }

    const projectBlocks = obraBlock.querySelectorAll('.project-block');
    let maxNumber = 0;

    projectBlocks.forEach(project => {
      const projectName = project.dataset.projectName || 
                         project.querySelector('.project-title')?.textContent || '';
      
      if (projectName) {
        // Suporta: "Projeto1", "Projeto 2", "Projeto-3", etc.
        const match = projectName.match(/Projeto\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next project number for obra ${obraId}: ${maxNumber + 1} (max found: ${maxNumber})`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextProjectNumber:', error);
    return 1; // Fallback seguro
  }
}



/**
 * Obt√©m o pr√≥ximo n√∫mero de sala - CORRIGIDO
 * @param {string} projectId - ID do projeto
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para sala
 */
function getNextRoomNumber(projectId) {
  try {
    const projectBlock = document.querySelector(`[data-project-id="${projectId}"]`);
    if (!projectBlock) {
      console.warn(`‚ö†Ô∏è Projeto ${projectId} n√£o encontrado, usando sala 1`);
      return 1;
    }

    const roomBlocks = projectBlock.querySelectorAll('.room-block');
    let maxNumber = 0;

    roomBlocks.forEach(room => {
      const roomName = room.dataset.roomName || 
                      room.querySelector('.room-title')?.textContent || '';

      if (roomName) {
        // Suporta: "Sala1", "Sala 2", "Sala-3", etc.
        const match = roomName.match(/Sala\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next room number for project ${projectId}: ${maxNumber + 1}`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextRoomNumber:', error);
    return 1; // Fallback seguro
  }
}

/**
 * Obt√©m o pr√≥ximo n√∫mero de obra dispon√≠vel
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para obra
 */
function getNextObraNumber() {
  try {
    const obraBlocks = document.querySelectorAll('.obra-block');
    let maxNumber = 0;

    obraBlocks.forEach(obra => {
      const obraName = obra.dataset.obraName || 
                      obra.querySelector('.obra-title')?.textContent || '';
      
      if (obraName) {
        // Suporta: "Obra1", "Obra 2", "Obra-3", etc.
        const match = obraName.match(/Obra\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next obra number: ${maxNumber + 1} (max found: ${maxNumber})`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextObraNumber:', error);
    return 1; // Fallback seguro
  }
}

// =============================================================================
// FUN√á√ïES DE NOMEA√á√ÉO - CORRE√á√ïES (MANTIDAS)
// =============================================================================

/**
 * Obt√©m o ID completo da sala no formato correto
 * @param {HTMLElement} roomElement - Elemento da sala
 * @returns {string} ID completo da sala
 */
function getRoomFullId(roomElement) {
    const roomId = roomElement.dataset.roomId;
    
    if (!roomId || roomId === 'undefined' || roomId === 'null' || roomId.includes('undefined')) {
        console.error(`ERRO FALBACK (getRoomFullId) data-utils-core.js [Room ID inv√°lido: ${roomId}]`);
        return generateSecureId('sala');
    }
    
    console.log(`‚úÖ ID da sala obtido do data attribute: ${roomId}`);
    return roomId;
}

/**
 * Obt√©m o nome da obra a partir do elemento - CORRIGIDO
 * @param {HTMLElement} obraElement - Elemento da obra
 * @returns {string} Nome da obra
 */
function getObraName(obraElement) {
    if (!obraElement) {
        console.error(`ERRO FALBACK (getObraName) data-utils-core.js [Elemento da obra n√£o fornecido]`);
        return 'Obra_Erro';
    }

    const titleElement = obraElement.querySelector('.obra-title');
    if (titleElement) {
        const name = titleElement.textContent || titleElement.innerText || '';
        const trimmedText = name.trim();
        if (trimmedText && trimmedText !== 'Obra') {
            return trimmedText;
        }
    }
    
    const obraNameFromData = obraElement.dataset.obraName;
    if (obraNameFromData && obraNameFromData !== 'undefined' && obraNameFromData !== 'null') {
        return obraNameFromData;
    }
    
    console.error(`ERRO FALBACK (getObraName) data-utils-core.js [Nome da obra n√£o encontrado]`);
    return 'Obra_Erro';
}

/**
 * Obt√©m o nome do projeto a partir do elemento - CORRIGIDO
 * @param {HTMLElement} projectElement - Elemento do projeto
 * @returns {string} Nome do projeto
 */
function getProjectName(projectElement) {
    if (!projectElement) {
        console.error(`ERRO FALBACK (getProjectName) data-utils-core.js [Elemento do projeto n√£o fornecido]`);
        return 'Projeto_Erro';
    }

    const titleElement = projectElement.querySelector('.project-title');
    if (titleElement) {
        const titleText = titleElement.textContent || titleElement.innerText || '';
        const trimmedText = titleText.trim();
        if (trimmedText && trimmedText !== 'Projeto') {
            console.log(`üìù Nome do projeto obtido do t√≠tulo: "${trimmedText}"`);
            return trimmedText;
        }
    }
    
    const projectNameFromData = projectElement.dataset.projectName;
    if (projectNameFromData && projectNameFromData !== 'undefined' && projectNameFromData !== 'null' && projectNameFromData !== 'Projeto') {
        console.log(`üìù Nome do projeto obtido do data attribute: "${projectNameFromData}"`);
        return projectNameFromData;
    }
    
    console.error(`ERRO FALBACK (getProjectName) data-utils-core.js [Nome do projeto n√£o encontrado]`);
    return 'Projeto_Erro';
}

/**
 * Obt√©m o nome da sala a partir do elemento - CORRIGIDO
 * @param {HTMLElement} roomElement - Elemento da sala
 * @returns {string} Nome da sala
 */
function getRoomName(roomElement) {
    if (!roomElement) {
        console.error(`ERRO FALBACK (getRoomName) data-utils-core.js [Elemento da sala n√£o fornecido]`);
        return 'Sala_Erro';
    }

    const titleElement = roomElement.querySelector('.room-title');
    if (titleElement) {
        const name = titleElement.textContent || titleElement.value || titleElement.getAttribute('value') || '';
        const trimmedName = name.trim();
        if (trimmedName) return trimmedName;
    }
    
    const roomNameFromData = roomElement.dataset.roomName;
    if (roomNameFromData && roomNameFromData !== 'undefined' && roomNameFromData !== 'null') {
        return roomNameFromData;
    }
    
    const roomId = roomElement.dataset.roomId;
    if (roomId && roomId !== 'undefined' && roomId !== 'null') {
        return `Sala ${roomId.split('_').pop()}`;
    }
    
    console.error(`ERRO FALBACK (getRoomName) data-utils-core.js [Nome da sala n√£o encontrado]`);
    return 'Sala_Erro';
}

// =============================================================================
// FUN√á√ïES UTILIT√ÅRIAS EXISTENTES (MANTIDAS)
// =============================================================================

/**
 * Extrai n√∫mero de um texto, convertendo v√≠rgula para ponto decimal
 * @param {string} text - Texto contendo n√∫mero
 * @returns {number|null} N√∫mero extra√≠do ou null se n√£o encontrado
 */
function extractNumberFromText(text) {
    if (!text) return null
    
    const numberMatch = text.match(/-?\d+(?:[.,]\d+)?/)
    if (numberMatch) {
        const numericString = numberMatch[0].replace(',', '.')
        const numericValue = parseFloat(numericString)
        return isNaN(numericValue) ? null : numericValue
    }
    
    return null
}

/**
 * Obt√©m o nome da m√°quina a partir do elemento
 * @param {HTMLElement} machineElement - Elemento da m√°quina
 * @param {string} machineId - ID da m√°quina
 * @returns {string} Nome da m√°quina
 */
function getMachineName(machineElement, machineId) {
    const titleElement = machineElement.querySelector('.machine-title-editable')
    if (!titleElement) return `M√°quina ${machineId}`
    
    const name = titleElement.value || titleElement.textContent || titleElement.getAttribute('value') || `M√°quina ${machineId}`
    return name.trim() || `M√°quina${machineId}`
}

/**
 * Converte texto de pre√ßo em n√∫mero
 * @param {string} priceText - Texto do pre√ßo no formato "R$ X.XXX,XX"
 * @returns {number} Valor num√©rico do pre√ßo
 */
function parseMachinePrice(priceText) {
    if (!priceText || priceText === 'R$ 0,00') return 0
    
    try {
        const cleaned = priceText.replace('R$', '')
                                .replace(/\./g, '')
                                .replace(',', '.')
                                .trim()
        return parseFloat(cleaned) || 0
    } catch (error) {
        console.error('‚ùå Erro ao converter pre√ßo:', priceText, error)
        return 0
    }
}

/**
 * Converte valores para n√∫mero com tratamento de seguran√ßa
 * @param {any} value - Valor a ser convertido
 * @returns {number} Valor num√©rico
 */
function safeNumber(value) {
    if (value === null || value === undefined || value === '') return 0
    const num = parseFloat(value.toString().replace(',', '.'))
    return isNaN(num) ? 0 : num
}

/**
 * Fun√ß√£o de debug para mostrar todos os elementos de ganhos t√©rmicos dispon√≠veis
 * @param {HTMLElement} roomElement - Elemento da sala para debug
 * @returns {void}
 */
function debugThermalGainsElements(roomElement) {
    const roomFullId = getRoomFullId(roomElement)
    console.log('üêõ DEBUG: Todos os elementos de ganhos t√©rmicos dispon√≠veis:')
    
    const selectors = [
        'total-ganhos-w', 'total-tr', 'total-externo', 'total-divisoes',
        'total-piso', 'total-iluminacao', 'total-dissi', 'total-pessoas',
        'total-ar-sensivel', 'total-ar-latente'
    ]
    
    selectors.forEach(selector => {
        const element = document.querySelector(`#${selector}-${roomFullId}`)
        console.log(`üîç ${selector}-${roomFullId}:`, element ? `ENCONTRADO - "${element.textContent}"` : 'N√ÉO ENCONTRADO')
    })
}

// =============================================================================
// EXPORTA√á√ïES - SISTEMA ATUALIZADO
// =============================================================================

export {
    // NOVO SISTEMA DE IDs SEGUROS
    generateSecureId,
    generateObraId,
    generateProjectId,
    generateRoomId,
    
    // SISTEMA DE NUMERA√á√ÉO - NOVAS FUN√á√ïES
    getNextProjectNumber,
    getNextRoomNumber,
    getNextObraNumber,
    
    // FUN√á√ïES DE NOMEA√á√ÉO CORRIGIDAS
    getRoomFullId,
    getObraName,
    getProjectName,
    getRoomName,
    
    // FUN√á√ïES UTILIT√ÅRIAS (MANTIDAS)
    extractNumberFromText,
    getMachineName,
    parseMachinePrice,
    safeNumber,
    debugThermalGainsElements
}
// adapters/obra-adapter.js - CORRE√á√ÉO COMPLETA:

import { isSessionActive } from "../adapters/session-adapter.js"

/**
 * Remove todas as obras base do container HTML
 */
function removeBaseObraFromHTML() {
    const obrasContainer = document.getElementById("projects-container")
    if (!obrasContainer) return

    const existingObras = obrasContainer.querySelectorAll(".obra-block")
    existingObras.forEach((obra) => obra.remove())
}

/**
 * Carrega obras salvas do servidor para a sess√£o atual - VERS√ÉO CORRIGIDA
 */
async function loadObrasFromServer() {
    console.log("üîÑ [LOAD OBRAS] Carregando OBRAS do servidor...");
    
    try {
        const sessionResponse = await fetch('/api/session-obras');
        if (!sessionResponse.ok) {
            console.log("üì≠ Nenhuma sess√£o ativa encontrada");
            return;
        }
        
        const sessionData = await sessionResponse.json();
        const obraIds = sessionData.obras || [];
        
        console.log(`üìä [LOAD OBRAS] Sess√£o com ${obraIds.length} obras:`, obraIds);
        
        if (obraIds.length === 0) {
            console.log("üì≠ [LOAD OBRAS] Nenhuma obra na sess√£o");
            return;
        }

        // ‚úÖ CORRE√á√ÉO CR√çTICA: Buscar TODAS as obras do servidor
        const obrasResponse = await fetch('/obras');
        if (!obrasResponse.ok) {
            console.error("‚ùå [LOAD OBRAS] Erro ao buscar dados das obras");
            return;
        }

        const todasObras = await obrasResponse.json();
        console.log(`üì¶ [LOAD OBRAS] ${todasObras.length} obras dispon√≠veis no servidor`);
        
        // ‚úÖ CORRE√á√ÉO CR√çTICA: Converter IDs da sess√£o para string e encontrar correspond√™ncias
        const obrasDaSessao = todasObras.filter(obra => {
            // Tentar encontrar por ID exato (novo formato)
            if (obraIds.includes(obra.id)) {
                return true;
            }
            
            // ‚úÖ CORRE√á√ÉO: Tentar encontrar por ID num√©rico (compatibilidade com sess√£o antiga)
            const obraIdNumero = obra.id.toString();
            if (obraIds.includes(obraIdNumero)) {
                return true;
            }
            
            return false;
        });
        
        console.log(`üéØ [LOAD OBRAS] ${obrasDaSessao.length} obras da sess√£o encontradas:`, 
            obrasDaSessao.map(o => ({id: o.id, nome: o.nome})));

        if (obrasDaSessao.length === 0) {
            console.log("üì≠ [LOAD OBRAS] Nenhuma obra correspondente encontrada");
            
            // ‚úÖ CORRE√á√ÉO: Limpar sess√£o se n√£o encontrar obras correspondentes
            console.log("üîÑ [LOAD OBRAS] Tentando migrar sess√£o para novos IDs...");
            await migrateSessionToNewIds(obraIds, todasObras);
            return;
        }

        // ‚úÖ CORRE√á√ÉO: Limpar interface antes de carregar
        removeBaseObraFromHTML();
        
        // ‚úÖ CORRE√á√ÉO: Carregar cada obra individualmente com await
        let loadedCount = 0;
        for (const obraData of obrasDaSessao) {
            const success = await loadSingleObra(obraData);
            if (success) loadedCount++;
        }
        
        console.log(`‚úÖ [LOAD OBRAS] ${loadedCount}/${obrasDaSessao.length} obras carregadas com sucesso`);
        
    } catch (error) {
        console.error("‚ùå [LOAD OBRAS] Erro ao carregar obras da sess√£o:", error);
    }
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Migra sess√£o de IDs antigos para novos
 */
async function migrateSessionToNewIds(oldObraIds, todasObras) {
    try {
        console.log("üîÑ [MIGRATION] Iniciando migra√ß√£o de sess√£o...");
        
        // Buscar TODAS as obras dispon√≠veis
        const novasObraIds = todasObras.map(obra => obra.id);
        
        if (novasObraIds.length > 0) {
            // Atualizar sess√£o com novos IDs
            await fetch('/api/session-obras', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ obras: novasObraIds })
            });
            
            console.log(`‚úÖ [MIGRATION] Sess√£o migrada: ${oldObraIds.length} IDs antigos ‚Üí ${novasObraIds.length} IDs novos`);
            console.log("üîÑ [MIGRATION] Recarregando obras com novos IDs...");
            
            // Recarregar com novos IDs
            await loadObrasFromServer();
        } else {
            console.log("üì≠ [MIGRATION] Nenhuma obra dispon√≠vel para migra√ß√£o");
        }
    } catch (error) {
        console.error("‚ùå [MIGRATION] Erro na migra√ß√£o:", error);
    }
}

/**
 * ‚úÖ CORRE√á√ÉO: Fun√ß√£o para carregar uma obra individual
 */
async function loadSingleObra(obraData) {
    if (!obraData || !obraData.id) {
        console.error('‚ùå [LOAD OBRAS] Dados de obra inv√°lidos:', obraData);
        return false;
    }

    console.log(`üîÑ [LOAD OBRAS] Carregando obra: "${obraData.nome}" (ID: ${obraData.id})`);
    
    try {
        // ‚úÖ CORRE√á√ÉO: Verificar se a obra j√° existe no DOM
        const obraExistente = document.querySelector(`[data-obra-id="${obraData.id}"]`);
        if (obraExistente) {
            console.log(`‚ö†Ô∏è [LOAD OBRAS] Obra "${obraData.nome}" j√° existe no DOM, atualizando...`);
            
            if (typeof window.populateObraData === 'function') {
                await window.populateObraData(obraData);
                console.log(`‚úÖ [LOAD OBRAS] Obra "${obraData.nome}" atualizada com sucesso`);
                return true;
            }
        }
        
        // ‚úÖ CORRE√á√ÉO: Se n√£o existe, criar nova obra
        if (typeof window.createEmptyObra === 'function') {
            console.log(`üî® [LOAD OBRAS] Criando nova obra: "${obraData.nome}"`);
            
            // Criar obra vazia com ID espec√≠fico
            await window.createEmptyObra(obraData.nome, obraData.id);
            
            // ‚úÖ CORRE√á√ÉO: Aguardar cria√ß√£o no DOM
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Verificar se foi criada
            const obraCriada = document.querySelector(`[data-obra-id="${obraData.id}"]`);
            if (obraCriada && typeof window.populateObraData === 'function') {
                console.log(`üé® [LOAD OBRAS] Preenchendo dados da obra "${obraData.nome}"...`);
                await window.populateObraData(obraData);
                console.log(`‚úÖ [LOAD OBRAS] Obra "${obraData.nome}" carregada com sucesso`);
                return true;
            } else {
                console.error(`‚ùå [LOAD OBRAS] Falha ao criar obra "${obraData.nome}" no DOM`);
            }
        } else {
            console.error(`‚ùå [LOAD OBRAS] createEmptyObra n√£o dispon√≠vel`);
        }
        
        return false;
    } catch (error) {
        console.error(`üí• [LOAD OBRAS] ERRO ao carregar obra "${obraData.nome}":`, error);
        return false;
    }
}

// ‚úÖ CORRE√á√ÉO: Fun√ß√£o alternativa para debug
async function debugLoadObras() {
    console.log("üêõ [DEBUG] Iniciando debug do carregamento...");
    
    // Verificar fun√ß√µes globais
    console.log("üîç [DEBUG] Fun√ß√µes dispon√≠veis:", {
        createEmptyObra: typeof window.createEmptyObra,
        populateObraData: typeof window.populateObraData,
        createEmptyProject: typeof window.createEmptyProject,
        createEmptyRoom: typeof window.createEmptyRoom
    });
    
    // Verificar obras no servidor
    try {
        const response = await fetch('/obras');
        if (response.ok) {
            const obras = await response.json();
            console.log(`üì¶ [DEBUG] Obras no servidor: ${obras.length}`, obras.map(o => ({id: o.id, nome: o.nome})));
        }
    } catch (error) {
        console.error("‚ùå [DEBUG] Erro ao buscar obras:", error);
    }
}

export {
    loadObrasFromServer,
    removeBaseObraFromHTML,
    loadSingleObra,
    debugLoadObras // ‚úÖ Exportar fun√ß√£o de debug
};
/**
 * =====================
 * Gerenciador de obras - obra-manager.js
 * SISTEMA CORRIGIDO COM IDs √öNICOS
 * =====================
 */

import { 
    showConfirmationModal, 
    undoDeletion,
    hideToast 
} from './modal/modal.js'

import { generateObraId } from '../../data/data-files/data-utils-core.js';
import {addNewProjectToObra} from './project-manager.js'


/**
 * Cria uma obra vazia na interface - CORRIGIDA
 * @param {string} obraName - Nome da obra
 * @param {string} obraId - ID da obra (opcional)
 */
async function createEmptyObra(obraName, obraId) {
    // ‚úÖ CORRE√á√ÉO: SEMPRE usar ID √∫nico, mesmo se fornecido (para consist√™ncia)
    const finalObraId = obraId || generateObraId();
    const obraHTML = buildObraHTML(obraName, finalObraId);
    
    console.log(`üèóÔ∏è Criando obra: ${obraName} com ID: ${finalObraId}`);
    console.log(`üìù HTML gerado:`, obraHTML.substring(0, 200) + '...');
    
    // ‚úÖ‚úÖ‚úÖ CORRE√á√ÉO CR√çTICA: Inserir no DOM e CONFIRMAR
    const inserted = await insertObraIntoDOM(obraHTML, finalObraId);
    
    if (inserted) {
        console.log(`‚úÖ Obra ${obraName} criada e INSERIDA NO DOM - ID: ${finalObraId}`);
        
        // ‚úÖ CONFIRMA√á√ÉO: Verificar se realmente est√° no DOM
        setTimeout(() => {
            const obraNoDOM = document.querySelector(`[data-obra-id="${finalObraId}"]`);
            if (obraNoDOM) {
                console.log(`‚úÖ CONFIRMADO: Obra ${finalObraId} encontrada no DOM`);
            } else {
                console.error(`‚ùå FALHA CR√çTICA: Obra ${finalObraId} N√ÉO est√° no DOM ap√≥s cria√ß√£o`);
            }
        }, 100);
    } else {
        console.error(`‚ùå FALHA: Obra ${obraName} N√ÉO FOI INSERIDA NO DOM`);
    }
    
    return inserted;
}
/**
 * Constr√≥i o HTML de uma obra
 * @param {string} obraName - Nome da obra
 * @param {string} obraId - ID √∫nico da obra
 * @returns {string} HTML da obra
 */
function buildObraHTML(obraName, obraId) {
  // ‚úÖ CORRE√á√ÉO: Validar ID √∫nico
  if (!obraId || obraId === 'undefined' || obraId === 'null') {
      console.error(`ERRO FALBACK (buildObraHTML) obra-manager.js [ID de obra inv√°lido: ${obraId}]`);
      obraId = generateObraId();
  }
  
  console.log(`üîç Build Obra HTML: ${obraName}, ID: ${obraId}`);

  return `
  <div class="obra-block" data-obra-id="${obraId}" data-obra-name="${obraName}">
    <div class="obra-header">
      <button class="minimizer" onclick="toggleObra('${obraId}', event)">+</button>
      <h2 class="obra-title compact-title editable-title" data-editable="true" onclick="makeEditable(this, 'obra')">${obraName}</h2>
      <div class="obra-header-spacer"><span>Adicionar campos de cadastro de empresas</span></div>
      <div class="obra-actions">
        <button class="btn btn-delete" onclick="window.deleteObra('${obraName}', '${obraId}')">Remover Obra</button>
      </div>
    </div>

    
    <div class="obra-content collapsed" id="obra-content-${obraId}">
      <div class="projetc-header-record very-dark">
          <span>Adicionar campos de cadastro de empresas</span>
      </div>
      <div class="projects-container" id="projects-${obraId}">

      </div>
      <div class="add-project-section">
        <button class="btn btn-add-secondary" onclick="addNewProjectToObra('${obraId}')">+ Adicionar Projeto</button>
      </div>
      ${buildObraActionsFooter(obraId, obraName, false)} 
    </div>
  </div>
  `;
}

/**
 * Constr√≥i o rodap√© de a√ß√µes da obra
 * @param {string} obraName - Nome da obra
 * @param {boolean} hasId - Se a obra j√° foi SALVA no servidor
 * @returns {string} HTML do rodap√© de a√ß√µes
 */
function buildObraActionsFooter(obraId, obraName, hasId = false) {
  const buttonText = hasId ? "Atualizar Obra" : "Salvar Obra";
  const buttonClass = hasId ? "btn-update" : "btn-save";

  console.log(`üîß Build Obra Footer: ${obraName}, ID: ${obraId}, HasId: ${hasId}, Button: ${buttonText}`);

  // ‚úÖ CORRE√á√ÉO: Usar obraId em TODAS as chamadas
  return `
    <div class="obra-actions-footer">
      <button class="btn btn-verify" onclick="verifyObraData('${obraId}')">Verificar Dados</button>
      <button class="btn ${buttonClass}" onclick="event.preventDefault(); saveOrUpdateObra('${obraId}')">${buttonText}</button>      
      <button class="btn btn-download" onclick="downloadPDF('${obraId}')">Baixar PDF</button>
      <button class="btn btn-download" onclick="downloadWord('${obraId}')">Baixar Word</button>
    </div>
  `;
}

/**
 * Insere o HTML da obra no DOM - CORRIGIDA
 * @param {string} obraHTML - HTML da obra a ser inserida
 * @param {string} obraId - ID da obra para debug
 * @returns {boolean} True se inserido com sucesso
 */
async function insertObraIntoDOM(obraHTML, obraId) {
    console.log(`üì§ Inserindo obra no DOM: ${obraId}`);
    
    const projectsContainer = document.getElementById("projects-container");
    
    if (!projectsContainer) {
        console.error('‚ùå Container de projetos n√£o encontrado');
        
        // ‚úÖ FALLBACK: Tentar criar o container
        console.log('üîÑ Tentando criar projects-container...');
        const mainContent = document.querySelector('main, body');
        if (mainContent) {
            const newContainer = document.createElement('div');
            newContainer.id = 'projects-container';
            newContainer.innerHTML = '<!-- Hierarquia: Obra ‚Üí Projeto ‚Üí Sala -->';
            mainContent.appendChild(newContainer);
            console.log('‚úÖ projects-container criado');
            return insertObraIntoDOM(obraHTML, obraId); // Tentar novamente
        }
        
        return false;
    }
    
    console.log(`‚úÖ Container encontrado, inserindo obra ${obraId}...`);
    console.log(`üì¶ Container antes:`, projectsContainer.children.length, 'elementos');
    
    try {
        projectsContainer.insertAdjacentHTML("beforeend", obraHTML);
        
        // ‚úÖ CONFIRMAR inser√ß√£o
        setTimeout(() => {
            const obraInserida = document.querySelector(`[data-obra-id="${obraId}"]`);
            if (obraInserida) {
                console.log(`‚úÖ Obra ${obraId} INSERIDA COM SUCESSO no container`);
                console.log(`üì¶ Container depois:`, projectsContainer.children.length, 'elementos');
            } else {
                console.error(`‚ùå FALHA: Obra ${obraId} N√ÉO FOI INSERIDA no container`);
            }
        }, 50);
        
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao inserir obra no DOM:', error);
        return false;
    }
}

/**
 * Atualiza o bot√£o de uma obra ap√≥s salvamento - CORRIGIDA (APENAS ID)
 * @param {string} obraName - Nome da obra
 * @param {string} obraId - ID da obra salva
 */
function updateObraButtonAfterSave(obraName, obraId) {
    console.log(`üîÑ Atualizando bot√£o da obra: ${obraName} (${obraId})`);
    
    // ‚úÖ BUSCAR APENAS POR ID √öNICO
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID ${obraId} n√£o encontrada para atualizar bot√£o`);
        return; // ‚ùå NUNCA tentar buscar por nome
    }

    // ‚úÖ ATUALIZAR ID NO DATASET (para garantir consist√™ncia)
    obraBlock.dataset.obraId = obraId;

    // ‚úÖ BUSCAR CONTE√öDO DA OBRA APENAS POR ID
    const obraContent = document.getElementById(`obra-content-${obraId}`);
    if (!obraContent) {
        console.error(`‚ùå Conte√∫do da obra ${obraId} n√£o encontrado`);
        return;
    }

    // ‚úÖ BUSCAR RODAP√â APENAS DENTRO DA OBRA ESPEC√çFICA
    const oldFooter = obraContent.querySelector('.obra-actions-footer');
    if (!oldFooter) {
        console.error(`‚ùå Rodap√© n√£o encontrado na obra ${obraId}`);
        return;
    }

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Atualizar APENAS o bot√£o, preservando o container de projetos
    const saveButton = oldFooter.querySelector('.btn-save, .btn-update');
    if (saveButton) {
        saveButton.textContent = "Atualizar Obra";
        saveButton.className = "btn btn-update";
        saveButton.setAttribute('onclick', `event.preventDefault(); saveOrUpdateObra('${obraId}')`);
        console.log(`‚úÖ Bot√£o atualizado para: "Atualizar Obra" (ID: ${obraId})`);
    } else {
        console.error(`‚ùå Bot√£o de salvar n√£o encontrado na obra ${obraId}`);
    }

    // ‚úÖ VERIFICAR se o container de projetos ainda existe (apenas por ID)
    const projectsContainer = document.getElementById(`projects-${obraId}`);
    if (!projectsContainer) {
        console.error(`‚ùå CR√çTICO: Container de projetos PERDIDO na obra ${obraId}!`);
    }
}

/**
 * Fun√ß√£o principal de deletar obra (ATUALIZADA)
 */
async function deleteObra(obraName, obraId) {
  // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
  const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`)
  if (!obraBlock) {
    console.error(`‚ùå Obra com ID ${obraId} n√£o encontrada`)
    return
  }

  // Mostra o modal personalizado em vez do confirm b√°sico
  showConfirmationModal(obraName, obraId, obraBlock)
}

/**
 * Obt√©m o pr√≥ximo n√∫mero de obra
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para obra
 */
function getNextObraNumber() {
  const obraBlocks = document.querySelectorAll('.obra-block')
  const obraNumbers = Array.from(obraBlocks).map(obra => {
    const obraName = obra.dataset.obraName
    const match = obraName.match(/Obra(\d+)/)
    return match ? parseInt(match[1]) : 0
  })

  const maxNumber = Math.max(0, ...obraNumbers)
  return maxNumber + 1
}

/**
 * Adiciona uma nova obra √† interface
 */
async function addNewObra() {
  try {
    const obraNumber = getNextObraNumber();
    const obraName = `Obra${obraNumber}`;
    
    // ‚úÖ CORRE√á√ÉO: Gerar ID √∫nico para nova obra
    const obraId = generateObraId();

    console.log(`üèóÔ∏è Criando nova obra: ${obraName} com ID: ${obraId}`);
    createEmptyObra(obraName, obraId);
    console.log(`‚úÖ ${obraName} adicionada com ID √∫nico: ${obraId}`);

    // ‚úÖ‚úÖ‚úÖ AGUARDAR um pouco para o DOM ser atualizado antes de criar projeto
    setTimeout(async () => {
        console.log(`üîÑ Criando projeto e sala autom√°ticos para ${obraName}`);
        if (typeof window.addNewProjectToObra === 'function') {
            await window.addNewProjectToObra(obraId);
            console.log(`‚úÖ Projeto e sala autom√°ticos criados para ${obraName}`);
        } else {
            console.error('‚ùå addNewProjectToObra n√£o dispon√≠vel');
        }
    }, 500);

  } catch (error) {
    console.error("‚ùå Erro ao adicionar nova obra:", error);
    alert("Erro ao criar nova obra. Verifique o console para detalhes.");
  }
}




// ===== EXPORTA√á√ïES E CONFIGURA√á√ÉO GLOBAL =====

// Torne as fun√ß√µes globais para o HTML poder acessar
window.deleteObra = deleteObra
window.addNewObra = addNewObra
window.undoDeletion = undoDeletion
window.hideToast = hideToast

// Exporta√ß√µes para m√≥dulos
export {
    createEmptyObra,
    buildObraHTML,
    buildObraActionsFooter,
    insertObraIntoDOM,
    updateObraButtonAfterSave,
    deleteObra,
    getNextObraNumber,
    addNewObra,
    generateObraId
}
// projects.js
import { ensureStringId } from "../utils/utils.js"
import { buildObraData } from "./data-utils.js"
import { showSystemStatus} from '../ui/intr-files/status-manager.js'
import{ updateObraButtonAfterSave } from "../ui/intr-files/obra-manager.js"
import { isSessionActive, startSessionOnFirstSave } from "./server.js";

/**
 * Busca todas as obras do servidor
 * @returns {Promise<Array>} Lista de obras
 */
async function fetchObras() {
  try {
    const response = await fetch('/obras')

    if (!response.ok) {
      // Se o endpoint n√£o existir, retorna array vazio (para obras novas)
      if (response.status === 404) {
        return [];
      }
      throw new Error(`Erro HTTP: ${response.status}`)
    }

    const obras = await response.json()
    return obras || [];
  } catch (error) {
    console.error("‚ùå Erro ao buscar obras:", error)

    // Em caso de erro, assumir que n√£o h√° obras (para desenvolvimento)
    return [];
  }
}

/**
 * Atualiza uma obra existente no servidor
 * @param {string|number} obraId - ID da obra
 * @param {Object} obraData - Dados atualizados da obra
 * @returns {Promise<Object|null>} Obra atualizada ou null em caso de erro
 */
async function atualizarObra(obraId, obraData) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de processar
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
      console.error(`ERRO FALBACK (atualizarObra) projects.js [ID de obra inv√°lido: ${obraId}]`);
      showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
      return null;
    }

    // S√≥ atualizar se sess√£o estiver ativa
    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° atualizada");
      showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o atualizada.", "error");
      return null;
    }

    obraId = ensureStringId(obraId);

    console.log(`üîç Verificando se obra ${obraId} existe no servidor...`);
    
    // Buscar TODAS as obras usando o novo endpoint
    const todasObrasResponse = await fetch('/api/backup-completo');
    if (!todasObrasResponse.ok) {
      throw new Error('Falha ao carregar backup para verifica√ß√£o');
    }
    
    const backupData = await todasObrasResponse.json();
    const todasObras = backupData.obras || [];
    const obraExistente = todasObras.find(obra => String(obra.id) === String(obraId));
    
    console.log(`üìä Verifica√ß√£o: Obra ${obraId} existe? ${!!obraExistente}`);
    console.log(`üìã TODAS as obras no backup:`, todasObras.map(o => ({ id: o.id, nome: o.nome })));

    if (!obraExistente) {
      console.log(`‚ùå Obra ${obraId} n√£o encontrada no backup, criando nova...`);

      // ‚úÖ CORRE√á√ÉO: Se obra n√£o existe, criar como nova preservando ID seguro
      console.log(`üÜï Criando nova obra com ID seguro preservado: ${obraId}`);
      obraData.id = obraId; // ‚úÖ PRESERVAR ID SEGUR
      return await salvarObra(obraData);
    }

    // ‚úÖ CORRE√á√ÉO: Garantir que o ID nos dados seja o correto (j√° est√° correto)
    console.log('üîÑ ATUALIZANDO OBRA EXISTENTE:', {
      id: obraData.id,
      nome: obraData.nome,
      projetos: obraData.projetos?.length || 0
    });

    // Usar PUT para /obras/{id}
    const url = `/obras/${obraId}`;
    console.log(`üéØ Fazendo PUT para: ${url}`);
    
    const response = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(obraData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao atualizar obra: ${errorText}`);
    }

    const updatedObra = await response.json();
    showSystemStatus("Obra atualizada com sucesso!", "success");
    
    console.log('‚úÖ OBRA ATUALIZADA:', {
      id: updatedObra.id,
      nome: updatedObra.nome,
      projetos: updatedObra.projetos?.length || 0
    });
    return updatedObra;
  } catch (error) {
    console.error("‚ùå Erro ao ATUALIZAR obra:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel atualizar a obra", "error");
    return null;
  }
}

/**
 * Salva uma nova obra no servidor e adiciona √† sess√£o atual
 * @param {Object} obraData - Dados da obra a ser salva
 * @returns {Promise<Object|null>} Obra criada ou null em caso de erro
 */
async function salvarObra(obraData) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar dados da obra antes de salvar
    if (!obraData || !obraData.nome) {
      console.error(`ERRO FALBACK (salvarObra) projects.js [Dados da obra inv√°lidos: ${JSON.stringify(obraData)}]`);
      showSystemStatus("ERRO: Dados da obra inv√°lidos", "error");
      return null;
    }

    // S√≥ salvar se sess√£o estiver ativa
    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
      showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
      return null;
    }

    // ‚úÖ CORRE√á√ÉO: Garantir que obra tenha ID seguro
    if (!obraData.id || obraData.id === 'undefined' || obraData.id === 'null') {
      console.error(`ERRO FALBACK (salvarObra) projects.js [Obra sem ID seguro: ${obraData.id}]`);
      showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
      return null;
    }

    console.log('üì§ SALVANDO NOVA OBRA:', {
      id: obraData.id,
      nome: obraData.nome,
      projetos: obraData.projetos?.length || 0,
      timestamp: obraData.timestamp
    });

    // Sempre usar POST para nova obra
    const response = await fetch('/obras', {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(obraData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao salvar obra: ${errorText}`);
    }

    const createdObra = await response.json();
    
    // Adicionar obra √† sess√£o
    console.log(`üìù Adicionando obra ${createdObra.id} √† sess√£o...`);
    await fetch('/api/sessions/add-obra', {
      method: 'POST',
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ obra_id: createdObra.id })
    });
    
    showSystemStatus("Obra salva com sucesso!", "success");
    
    console.log('‚úÖ NOVA OBRA SALVA E ADICIONADA √Ä SESS√ÉO:', {
      id: createdObra.id,
      nome: createdObra.nome,
      projetos: createdObra.projetos?.length || 0
    });
    return createdObra;
  } catch (error) {
    console.error("‚ùå Erro ao SALVAR obra:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel salvar a obra", "error");
    return null;
  }
}


/**
 * Encontra o elemento HTML de uma obra pelo ID
 * @param {string} obraId - ID da obra a ser encontrada
 * @returns {HTMLElement|null} Elemento da obra ou null se n√£o encontrado
 */
function findObraBlock(obraId) {
    console.log(`üîç Buscando obra pelo ID: "${obraId}"`);
    
    // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
    // 1. Tentar pelo ID exato (mais espec√≠fico)
    let obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (obraBlock) {
        console.log(`‚úÖ Obra encontrada por ID exato: "${obraId}"`);
        return obraBlock;
    }
    
    
    // 3. Listar todas as obras dispon√≠veis para debug
    const todasObras = document.querySelectorAll('[data-obra-id]');
    console.log(`üìã Obras encontradas no DOM: ${todasObras.length}`);
    
    todasObras.forEach((obra, index) => {
        console.log(`  ${index + 1}.`, {
            id: obra.dataset.obraId,
            name: obra.dataset.obraName,
            classes: obra.className
        });
    });
    
    // ‚ùå REMOVIDO: NUNCA retornar obra errada como fallback
    console.log(`‚ùå Obra com ID "${obraId}" n√£o encontrada no DOM`);
    return null;
}


/**
 * Aguarda at√© que um elemento esteja dispon√≠vel no DOM
 * @param {string} selector - Seletor do elemento
 * @param {number} timeout - Timeout em milissegundos
 * @returns {Promise<HTMLElement>}
 */
function waitForElement(selector, timeout = 3000) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        function check() {
            const element = document.querySelector(selector);
            if (element) {
                console.log(`‚úÖ Elemento encontrado: ${selector}`);
                resolve(element);
                return;
            }
            
            if (Date.now() - startTime > timeout) {
                reject(new Error(`Timeout: Elemento n√£o encontrado - ${selector}`));
                return;
            }
            
            setTimeout(check, 100);
        }
        
        check();
    });
}

/**
 * Verifica se uma obra existe no DOM com retry
 * @param {string} obraId - ID da obra
 * @param {number} maxAttempts - N√∫mero m√°ximo de tentativas
 * @returns {Promise<HTMLElement|null>}
 */
async function findObraBlockWithRetry(obraId, maxAttempts = 10) {
    console.log(`üîç Buscando obra com retry: "${obraId}"`);
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
        
        if (obraBlock) {
            console.log(`‚úÖ Obra encontrada na tentativa ${attempt}/${maxAttempts}`);
            return obraBlock;
        }
        
        console.log(`‚è≥ Tentativa ${attempt}/${maxAttempts} - obra n√£o encontrada, aguardando...`);
        
        if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    console.log(`‚ùå Obra n√£o encontrada ap√≥s ${maxAttempts} tentativas`);
    return null;
}


/**
 * Salva ou atualiza uma obra no servidor (fun√ß√£o principal)
 * @param {string} obraId - ID da obra
 * @param {Event} event - Evento do clique
 * @returns {Promise<void>}
 */
async function saveObra(obraId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    console.log(`üíæ SALVANDO OBRA pelo ID: "${obraId}"`);

    // ‚úÖ CORRE√á√ÉO 1: AGUARDAR obra estar no DOM antes de qualquer opera√ß√£o
    console.log(`‚è≥ Aguardando obra "${obraId}" estar no DOM...`);
    
    let obraBlock = await findObraBlockWithRetry(obraId, 15);
    
    if (!obraBlock) {
        console.error('‚ùå Obra n√£o encontrada no DOM ap√≥s m√∫ltiplas tentativas:', obraId);
        
        // Debug detalhado
        const todasObras = document.querySelectorAll('[data-obra-id]');
        console.log('üìã Obras dispon√≠veis no DOM:', Array.from(todasObras).map(o => ({
            id: o.dataset.obraId,
            name: o.dataset.obraName
        })));
        
        showSystemStatus("ERRO: Obra n√£o encontrada na interface", "error");
        return;
    }

    // ‚úÖ CORRE√á√ÉO 2: Verificar se a sess√£o est√° ativa AP√ìS confirmar que a obra existe
    if (!isSessionActive()) {
        console.log("üÜï Iniciando sess√£o para primeira obra...");
        await startSessionOnFirstSave();
    }

    // Log para sess√£o ativa
    if (!isSessionActive()) {
        console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
        showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
        return;
    }

    console.log('‚úÖ Obra confirmada no DOM:', {
        element: obraBlock,
        dataset: obraBlock.dataset,
        id: obraBlock.dataset.obraId,
        name: obraBlock.dataset.obraName
    });

    console.log('üî® Construindo dados da obra...');
    const obraData = buildObraData(obraBlock);

    if (!obraData) {
        console.error('‚ùå Falha ao construir dados da obra');
        showSystemStatus("ERRO: Falha ao construir dados da obra", "error");
        return;
    }

    // ‚úÖ CORRE√á√ÉO 3: L√≥gica MELHORADA para determinar se √© nova obra
    const obraIdFromDOM = obraBlock.dataset.obraId;
    const obraIdFromData = obraData.id;
    
    // ‚úÖ VERIFICA√á√ÉO MAIS ROBUSTA - usar o ID que veio do DOM como fonte da verdade
    const finalObraId = obraIdFromDOM || obraIdFromData;
    
    console.log('üîç VERIFICA√á√ÉO DE OBRA MELHORADA:');
    console.log('- ID no DOM:', obraIdFromDOM);
    console.log('- ID nos dados:', obraIdFromData);
    console.log('- ID final para uso:', finalObraId);
    console.log('- √â ID seguro?:', finalObraId?.startsWith('obra_'));
    
    // ‚úÖ CORRE√á√ÉO: Determinar se √© nova obra baseado na presen√ßa no servidor
    let isNewObra = true; // Assume que √© nova por padr√£o
    
    try {
        // Verificar se a obra j√° existe no servidor
        const todasObrasResponse = await fetch('/api/backup-completo');
        if (todasObrasResponse.ok) {
            const backupData = await todasObrasResponse.json();
            const todasObras = backupData.obras || [];
            const obraExistente = todasObras.find(obra => String(obra.id) === String(finalObraId));
            
            isNewObra = !obraExistente;
            console.log(`- J√° existe no servidor?: ${!isNewObra}`);
        }
    } catch (error) {
        console.log('- N√£o foi poss√≠vel verificar servidor, assumindo como nova obra');
    }

    console.log('- √â nova obra?:', isNewObra);

    let result = null;
    
    if (isNewObra) {
        console.log('üÜï SALVANDO COMO NOVA OBRA COM ID SEGURO:', finalObraId);
        
        // ‚úÖ CORRE√á√ÉO: Garantir que obraData tenha o ID correto
        obraData.id = finalObraId;
        
        if (!obraData.id || !obraData.id.startsWith('obra_')) {
            console.error('‚ùå Obra n√£o possui ID seguro v√°lido para salvar');
            showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
            return;
        }
        
        result = await salvarObra(obraData);
    } else {
        console.log('üìù ATUALIZANDO OBRA EXISTENTE, ID SEGURO:', finalObraId);
        
        // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de atualizar
        if (!finalObraId.startsWith('obra_')) {
            console.error(`ERRO: ID n√£o seguro para atualiza√ß√£o: ${finalObraId}`);
            showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
            return;
        }
        
        result = await atualizarObra(finalObraId, obraData);
    }

    if (result) {
        const finalId = ensureStringId(result.id);
        
        // ‚úÖ CORRE√á√ÉO: Atualizar DOM com o ID seguro correto
        obraBlock.dataset.obraId = finalId;
        obraBlock.dataset.obraName = obraData.nome;
        
        // Atualizar t√≠tulo se necess√°rio
        const titleElement = obraBlock.querySelector('.obra-title');
        if (titleElement && titleElement.textContent !== obraData.nome) {
            titleElement.textContent = obraData.nome;
        }

        if (typeof updateObraButtonAfterSave === 'function') {
            console.info("Setpoint informa√ß√£o chegando at√© aqui")
            updateObraButtonAfterSave(obraData.nome, finalId);
        }

        console.log(`‚úÖ OBRA SALVA/ATUALIZADA COM SUCESSO! ID SEGURO: ${finalId}`);
        
        showSystemStatus("Obra salva com sucesso!", "success");
    } else {
        console.error('‚ùå FALHA AO SALVAR OBRA NO SERVIDOR');
        showSystemStatus("ERRO: Falha ao salvar obra no servidor", "error");
    }
}


/**
 * Deleta uma obra do servidor
 * @param {string} obraName - Nome da obra
 * @param {string} obraId - ID da obra
 * @returns {Promise<void>}
 */
async function deleteObraFromServer(obraName, obraId) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de deletar
    if (!obraId || obraId === 'undefined' || obraId === 'null' || !obraId.startsWith('obra_')) {
      console.error(`ERRO FALBACK (deleteObraFromServer) projects.js [ID de obra inv√°lido: ${obraId}]`);
      showSystemStatus("ERRO: ID da obra inv√°lido para remo√ß√£o", "error");
      return;
    }

    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° removida do servidor");
      return;
    }

    obraId = ensureStringId(obraId);

    console.log(`üóëÔ∏è Removendo obra ${obraId} do servidor...`);

    const response = await fetch(`/obras/${obraId}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao remover obra: ${errorText}`);
    }

    console.log(`‚úÖ Obra ${obraId} removida do servidor`);
    showSystemStatus("Obra removida do servidor com sucesso", "success");
  } catch (error) {
    console.error("‚ùå Erro ao remover obra do servidor:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel remover a obra do servidor", "error");
  }
}

/**
 * Verifica os dados de uma obra e gera relat√≥rio de completude
 * @param {string} obraId - ID da obra
 * @returns {void}
 */
function verifyObraData(obraId) {
  const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
  if (!obraBlock) {
    console.error(`‚ùå Obra com ID "${obraId}" n√£o encontrada para verifica√ß√£o`);
    alert(`ERRO: Obra com ID "${obraId}" n√£o encontrada`);
    return;
  }

  const obraName = obraBlock.dataset.obraName;
  const projects = obraBlock.querySelectorAll(".project-block");
  let totalRooms = 0;
  
  let report = `Verifica√ß√£o da Obra "${obraName}" (ID: ${obraId}):\n\n`;
  report += `Total de projetos: ${projects.length}\n\n`;

  projects.forEach((project, index) => {
    const projectName = project.dataset.projectName;
    const rooms = project.querySelectorAll(".room-block");
    totalRooms += rooms.length;
    
    report += `Projeto ${index + 1}: ${projectName}\n`;
    report += `  - Salas: ${rooms.length}\n`;
    
    rooms.forEach((room, roomIndex) => {
      const roomName = room.querySelector(".room-title")?.textContent || `Sala ${roomIndex + 1}`;
      const stats = calculateRoomCompletionStats(room);
      report += `    - ${roomName}: ${stats.filled}/${stats.total} campos (${stats.percentage}%)\n`;
    });
    report += '\n';
  });

  report += `RESUMO: ${projects.length} projetos, ${totalRooms} salas`;

  console.log(`üîç Relat√≥rio gerado para obra: ${obraName} (ID: ${obraId})`);
  alert(report);
}

/**
 * Calcula estat√≠sticas de preenchimento de uma sala
 * @param {HTMLElement} room - Elemento da sala
 * @returns {Object} Estat√≠sticas de preenchimento
 */
function calculateRoomCompletionStats(room) {
  const inputs = room.querySelectorAll(".form-input, .clima-input");
  const filledInputs = Array.from(inputs).filter((input) => {
    if (input.type === 'checkbox' || input.type === 'radio') {
      return input.checked;
    }
    return input.value && input.value.trim() !== "";
  }).length;
  
  const totalInputs = inputs.length;
  const percentage = totalInputs > 0 ? ((filledInputs / totalInputs) * 100).toFixed(1) : 0;

  return {
    filled: filledInputs,
    total: totalInputs,
    percentage: percentage,
  };
}


// Exporta√ß√µes para compatibilidade
window.saveObra = saveObra;
window.verifyObraData = verifyObraData;

export {
  fetchObras,
  salvarObra,
  atualizarObra,
  saveObra,

  deleteObraFromServer,
  verifyObraData,
  calculateRoomCompletionStats,
  findObraBlock,
}
