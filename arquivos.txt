
/* ==== IN√çCIO: data-utils-core.js ==== */
/**
 * data-utils-core.js
 * Utilit√°rios core e fun√ß√µes auxiliares
 * Gera√ß√£o de IDs SEGUROS E √öNICOS - SISTEMA CORRIGIDO
 */

// =============================================================================
// SISTEMA DE IDs SEGUROS E √öNICOS - CORRE√á√ÉO COMPLETA
// =============================================================================

/**
 * Gera um ID seguro baseado em letras + n√∫meros
 * @param {string} prefix - Prefixo para o ID
 * @returns {string} ID seguro
 * @generator @example obra_x87
 */
function generateSecureId(prefix = 'item') {
    // CARACTERES ASCII SEGUROS DO TECLADO (59 caracteres)
    const safeChars = 'abcdefghjkmnpqrstwxyzABCDEFGHJKMNPQRSTWXYZ0123456789-'; 
    
    // Gerar 8 caracteres aleat√≥rios usando Crypto API
    const randomValues = new Uint32Array(8);
    crypto.getRandomValues(randomValues);
    
    let id = prefix + '_';
    
    for (let i = 0; i < 4; i++) {
        const randomIndex = randomValues[i] % safeChars.length;
        id += safeChars[randomIndex];
    }
    
    return id;
}

/**
 * Gera ID √∫nico para obra - SEGURO E √öNICO
 * @returns {string} ID √∫nico da obra
 */
function generateObraId() {
    return generateSecureId('obra');
}

/**
 * Gera ID hier√°rquico seguro para projeto - SEGURO E √öNICO (VERS√ÉO CORRIGIDA)
 * @param {HTMLElement} obraElement - Elemento da obra pai
 * @param {number} projectNumber - N√∫mero sequencial do projeto
 * @returns {string} ID √∫nico do projeto
 */
function generateProjectId(obraElement, projectNumber) {
    if (!obraElement) {
        console.error(`ERRO FALBACK (generateProjectId) [Elemento da obra n√£o fornecido]`);
        return generateSecureId('proj');
    }
    
    const obraId = obraElement.dataset?.obraId;
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (generateProjectId) [Obra ID inv√°lido no dataset: ${obraId}]`);
        return generateSecureId('proj');
    }
    
    // ‚úÖ CORRE√á√ÉO: Se projectNumber for undefined, calcular automaticamente
    let finalProjectNumber = projectNumber;
    if (finalProjectNumber === undefined || finalProjectNumber === null) {
        console.warn(`‚ö†Ô∏è  projectNumber √© ${projectNumber}, calculando automaticamente...`);
        
        // Calcula contando projetos existentes
        const existingProjects = obraElement.querySelectorAll('[data-project-id]');
        finalProjectNumber = existingProjects.length + 1;
        console.log(`üìä Calculado: ${existingProjects.length} projetos + 1 = ${finalProjectNumber}`);
    }
    
    const projectPrefix = generateSecureId('proj').replace('proj_', '');
    const projectId = `${obraId}_proj_${projectPrefix}_${finalProjectNumber}`;
    
    console.log(`üÜï ID do projeto gerado: ${projectId}`);
    return projectId;
}

/**
 * Gera ID hier√°rquico seguro para sala - SEGURO E √öNICO
 * @param {HTMLElement} projectElement - Elemento do projeto pai
 * @param {number} roomNumber - N√∫mero sequencial da sala
 * @returns {string} ID √∫nico da sala
 */
function generateRoomId(projectElement, roomNumber) {
    if (!projectElement) {
        console.error(`ERRO FALBACK (generateRoomId) [Elemento do projeto n√£o fornecido]`);
        return generateSecureId('sala');
    }
    
    const projectId = projectElement.dataset?.projectId;
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (generateRoomId) [Project ID inv√°lido no dataset: ${projectId}]`);
        return generateSecureId('sala');
    }
    
    // ‚úÖ CORRE√á√ÉO: Se roomNumber for undefined, calcular automaticamente
    let finalRoomNumber = roomNumber;
    if (finalRoomNumber === undefined || finalRoomNumber === null) {
        console.warn(`‚ö†Ô∏è  roomNumber √© ${roomNumber}, calculando automaticamente...`);
        
        // Calcula contando salas existentes
        const existingRooms = projectElement.querySelectorAll('[data-room-id]');
        finalRoomNumber = existingRooms.length + 1;
        console.log(`üìä Calculado: ${existingRooms.length} salas + 1 = ${finalRoomNumber}`);
    }
    
    const roomPrefix = generateSecureId('sala').replace('sala_', '');
    const roomId = `${projectId}_sala_${roomPrefix}_${finalRoomNumber}`;
    
    console.log(`üÜï ID da sala gerado: ${roomId}`);
    return roomId;
}

// =============================================================================
// FUN√á√ïES DE NUMERA√á√ÉO - NOVAS FUN√á√ïES ADICIONADAS
// =============================================================================

/**
 * Obt√©m o pr√≥ximo n√∫mero de projeto dispon√≠vel PARA UMA OBRA ESPEC√çFICA - CORRIGIDO
 * @param {string} obraId - ID √∫nico da obra
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para projeto na obra espec√≠fica
 */
function getNextProjectNumber(obraId) {
  try {
    // ‚úÖ CORRE√á√ÉO: Buscar apenas projetos DESTA obra espec√≠fica
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
      console.warn(`‚ö†Ô∏è Obra ${obraId} n√£o encontrada, usando projeto 1`);
      return 1;
    }

    const projectBlocks = obraBlock.querySelectorAll('.project-block');
    let maxNumber = 0;

    projectBlocks.forEach(project => {
      const projectName = project.dataset.projectName || 
                         project.querySelector('.project-title')?.textContent || '';
      
      if (projectName) {
        // Suporta: "Projeto1", "Projeto 2", "Projeto-3", etc.
        const match = projectName.match(/Projeto\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next project number for obra ${obraId}: ${maxNumber + 1} (max found: ${maxNumber})`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextProjectNumber:', error);
    return 1; // Fallback seguro
  }
}



/**
 * Obt√©m o pr√≥ximo n√∫mero de sala - CORRIGIDO
 * @param {string} projectId - ID do projeto
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para sala
 */
function getNextRoomNumber(projectId) {
  try {
    const projectBlock = document.querySelector(`[data-project-id="${projectId}"]`);
    if (!projectBlock) {
      console.warn(`‚ö†Ô∏è Projeto ${projectId} n√£o encontrado, usando sala 1`);
      return 1;
    }

    const roomBlocks = projectBlock.querySelectorAll('.room-block');
    let maxNumber = 0;

    roomBlocks.forEach(room => {
      const roomName = room.dataset.roomName || 
                      room.querySelector('.room-title')?.textContent || '';

      if (roomName) {
        // Suporta: "Sala1", "Sala 2", "Sala-3", etc.
        const match = roomName.match(/Sala\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next room number for project ${projectId}: ${maxNumber + 1}`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextRoomNumber:', error);
    return 1; // Fallback seguro
  }
}

/**
 * Obt√©m o pr√≥ximo n√∫mero de obra dispon√≠vel
 * @returns {number} Pr√≥ximo n√∫mero dispon√≠vel para obra
 */
function getNextObraNumber() {
  try {
    const obraBlocks = document.querySelectorAll('.obra-block');
    let maxNumber = 0;

    obraBlocks.forEach(obra => {
      const obraName = obra.dataset.obraName || 
                      obra.querySelector('.obra-title')?.textContent || '';
      
      if (obraName) {
        // Suporta: "Obra1", "Obra 2", "Obra-3", etc.
        const match = obraName.match(/Obra\s*[-_]?\s*(\d+)/i);
        if (match) {
          const num = parseInt(match[1]);
          if (num > maxNumber) maxNumber = num;
        }
      }
    });

    console.log(`üî¢ Next obra number: ${maxNumber + 1} (max found: ${maxNumber})`);
    return maxNumber + 1;

  } catch (error) {
    console.error('‚ùå Erro em getNextObraNumber:', error);
    return 1; // Fallback seguro
  }
}

// =============================================================================
// FUN√á√ïES DE NOMEA√á√ÉO - CORRE√á√ïES (MANTIDAS)
// =============================================================================

/**
 * Obt√©m o ID completo da sala no formato correto
 * @param {HTMLElement} roomElement - Elemento da sala
 * @returns {string} ID completo da sala
 */
function getRoomFullId(roomElement) {
    const roomId = roomElement.dataset.roomId;
    
    if (!roomId || roomId === 'undefined' || roomId === 'null' || roomId.includes('undefined')) {
        console.error(`ERRO FALBACK (getRoomFullId) data-utils-core.js [Room ID inv√°lido: ${roomId}]`);
        return generateSecureId('sala');
    }
    
    console.log(`‚úÖ ID da sala obtido do data attribute: ${roomId}`);
    return roomId;
}

/**
 * Obt√©m o nome da obra a partir do elemento - CORRIGIDO
 * @param {HTMLElement} obraElement - Elemento da obra
 * @returns {string} Nome da obra
 */
function getObraName(obraElement) {
    if (!obraElement) {
        console.error(`ERRO FALBACK (getObraName) data-utils-core.js [Elemento da obra n√£o fornecido]`);
        return 'Obra_Erro';
    }

    const titleElement = obraElement.querySelector('.obra-title');
    if (titleElement) {
        const name = titleElement.textContent || titleElement.innerText || '';
        const trimmedText = name.trim();
        if (trimmedText && trimmedText !== 'Obra') {
            return trimmedText;
        }
    }
    
    const obraNameFromData = obraElement.dataset.obraName;
    if (obraNameFromData && obraNameFromData !== 'undefined' && obraNameFromData !== 'null') {
        return obraNameFromData;
    }
    
    console.error(`ERRO FALBACK (getObraName) data-utils-core.js [Nome da obra n√£o encontrado]`);
    return 'Obra_Erro';
}

/**
 * Obt√©m o nome do projeto a partir do elemento - CORRIGIDO
 * @param {HTMLElement} projectElement - Elemento do projeto
 * @returns {string} Nome do projeto
 */
function getProjectName(projectElement) {
    if (!projectElement) {
        console.error(`ERRO FALBACK (getProjectName) data-utils-core.js [Elemento do projeto n√£o fornecido]`);
        return 'Projeto_Erro';
    }

    const titleElement = projectElement.querySelector('.project-title');
    if (titleElement) {
        const titleText = titleElement.textContent || titleElement.innerText || '';
        const trimmedText = titleText.trim();
        if (trimmedText && trimmedText !== 'Projeto') {
            console.log(`üìù Nome do projeto obtido do t√≠tulo: "${trimmedText}"`);
            return trimmedText;
        }
    }
    
    const projectNameFromData = projectElement.dataset.projectName;
    if (projectNameFromData && projectNameFromData !== 'undefined' && projectNameFromData !== 'null' && projectNameFromData !== 'Projeto') {
        console.log(`üìù Nome do projeto obtido do data attribute: "${projectNameFromData}"`);
        return projectNameFromData;
    }
    
    console.error(`ERRO FALBACK (getProjectName) data-utils-core.js [Nome do projeto n√£o encontrado]`);
    return 'Projeto_Erro';
}

/**
 * Obt√©m o nome da sala a partir do elemento - CORRIGIDO
 * @param {HTMLElement} roomElement - Elemento da sala
 * @returns {string} Nome da sala
 */
function getRoomName(roomElement) {
    if (!roomElement) {
        console.error(`ERRO FALBACK (getRoomName) data-utils-core.js [Elemento da sala n√£o fornecido]`);
        return 'Sala_Erro';
    }

    const titleElement = roomElement.querySelector('.room-title');
    if (titleElement) {
        const name = titleElement.textContent || titleElement.value || titleElement.getAttribute('value') || '';
        const trimmedName = name.trim();
        if (trimmedName) return trimmedName;
    }
    
    const roomNameFromData = roomElement.dataset.roomName;
    if (roomNameFromData && roomNameFromData !== 'undefined' && roomNameFromData !== 'null') {
        return roomNameFromData;
    }
    
    const roomId = roomElement.dataset.roomId;
    if (roomId && roomId !== 'undefined' && roomId !== 'null') {
        return `Sala ${roomId.split('_').pop()}`;
    }
    
    console.error(`ERRO FALBACK (getRoomName) data-utils-core.js [Nome da sala n√£o encontrado]`);
    return 'Sala_Erro';
}

// =============================================================================
// FUN√á√ïES UTILIT√ÅRIAS EXISTENTES (MANTIDAS)
// =============================================================================

/**
 * Extrai n√∫mero de um texto, convertendo v√≠rgula para ponto decimal
 * @param {string} text - Texto contendo n√∫mero
 * @returns {number|null} N√∫mero extra√≠do ou null se n√£o encontrado
 */
function extractNumberFromText(text) {
    if (!text) return null
    
    const numberMatch = text.match(/-?\d+(?:[.,]\d+)?/)
    if (numberMatch) {
        const numericString = numberMatch[0].replace(',', '.')
        const numericValue = parseFloat(numericString)
        return isNaN(numericValue) ? null : numericValue
    }
    
    return null
}

/**
 * Obt√©m o nome da m√°quina a partir do elemento
 * @param {HTMLElement} machineElement - Elemento da m√°quina
 * @param {string} machineId - ID da m√°quina
 * @returns {string} Nome da m√°quina
 */
function getMachineName(machineElement, machineId) {
    const titleElement = machineElement.querySelector('.machine-title-editable')
    if (!titleElement) return `M√°quina ${machineId}`
    
    const name = titleElement.value || titleElement.textContent || titleElement.getAttribute('value') || `M√°quina ${machineId}`
    return name.trim() || `M√°quina${machineId}`
}

/**
 * Converte texto de pre√ßo em n√∫mero
 * @param {string} priceText - Texto do pre√ßo no formato "R$ X.XXX,XX"
 * @returns {number} Valor num√©rico do pre√ßo
 */
function parseMachinePrice(priceText) {
    if (!priceText || priceText === 'R$ 0,00') return 0
    
    try {
        const cleaned = priceText.replace('R$', '')
                                .replace(/\./g, '')
                                .replace(',', '.')
                                .trim()
        return parseFloat(cleaned) || 0
    } catch (error) {
        console.error('‚ùå Erro ao converter pre√ßo:', priceText, error)
        return 0
    }
}

/**
 * Converte valores para n√∫mero com tratamento de seguran√ßa
 * @param {any} value - Valor a ser convertido
 * @returns {number} Valor num√©rico
 */
function safeNumber(value) {
    if (value === null || value === undefined || value === '') return 0
    const num = parseFloat(value.toString().replace(',', '.'))
    return isNaN(num) ? 0 : num
}

/**
 * Fun√ß√£o de debug para mostrar todos os elementos de ganhos t√©rmicos dispon√≠veis
 * @param {HTMLElement} roomElement - Elemento da sala para debug
 * @returns {void}
 */
function debugThermalGainsElements(roomElement) {
    const roomFullId = getRoomFullId(roomElement)
    console.log('üêõ DEBUG: Todos os elementos de ganhos t√©rmicos dispon√≠veis:')
    
    const selectors = [
        'total-ganhos-w', 'total-tr', 'total-externo', 'total-divisoes',
        'total-piso', 'total-iluminacao', 'total-dissi', 'total-pessoas',
        'total-ar-sensivel', 'total-ar-latente'
    ]
    
    selectors.forEach(selector => {
        const element = document.querySelector(`#${selector}-${roomFullId}`)
        console.log(`üîç ${selector}-${roomFullId}:`, element ? `ENCONTRADO - "${element.textContent}"` : 'N√ÉO ENCONTRADO')
    })
}

// =============================================================================
// EXPORTA√á√ïES - SISTEMA ATUALIZADO
// =============================================================================

export {
    // NOVO SISTEMA DE IDs SEGUROS
    generateSecureId,
    generateObraId,
    generateProjectId,
    generateRoomId,
    
    // SISTEMA DE NUMERA√á√ÉO - NOVAS FUN√á√ïES
    getNextProjectNumber,
    getNextRoomNumber,
    getNextObraNumber,
    
    // FUN√á√ïES DE NOMEA√á√ÉO CORRIGIDAS
    getRoomFullId,
    getObraName,
    getProjectName,
    getRoomName,
    
    // FUN√á√ïES UTILIT√ÅRIAS (MANTIDAS)
    extractNumberFromText,
    getMachineName,
    parseMachinePrice,
    safeNumber,
    debugThermalGainsElements
}
/* ==== FIM: data-utils-core.js ==== */

/* ==== IN√çCIO: edit.js ==== */
//edit.js

/**
 * Inicia o modo de edi√ß√£o inline para um elemento (projeto ou sala)
 * Permite que o usu√°rio edite o texto diretamente no elemento
 * @param {HTMLElement} element - Elemento a ser editado
 * @param {string} type - Tipo do elemento ('project' ou 'room')
 */
function makeEditable(element, type) {
  if (element.classList.contains("editing")) return

  const originalText = element.textContent.trim()
  element.dataset.originalText = originalText

  enableEditing(element)
  selectElementContent(element)
  attachEditingEventListeners(element, type)
}

/**
 * Habilita a edi√ß√£o do elemento configurando contentEditable
 * @param {HTMLElement} element - Elemento a ser habilitado para edi√ß√£o
 */
function enableEditing(element) {
  element.contentEditable = true
  element.classList.add("editing")
}

/**
 * Seleciona todo o conte√∫do do elemento para facilitar a edi√ß√£o
 * @param {HTMLElement} element - Elemento cujo conte√∫do ser√° selecionado
 */
function selectElementContent(element) {
  const range = document.createRange()
  const selection = window.getSelection()
  range.selectNodeContents(element)
  selection.removeAllRanges()
  selection.addRange(range)
  element.focus()
}

/**
 * Anexa event listeners para tratar teclas e perda de foco durante edi√ß√£o
 * @param {HTMLElement} element - Elemento em edi√ß√£o
 * @param {string} type - Tipo do elemento ('project' ou 'room')
 */
function attachEditingEventListeners(element, type) {
  element.addEventListener("keydown", function handleKeydown(e) {
    if (e.key === "Enter") {
      e.preventDefault()
      saveInlineEdit(element, type)
      element.removeEventListener("keydown", handleKeydown)
    } else if (e.key === "Escape") {
      e.preventDefault()
      cancelInlineEdit(element)
      element.removeEventListener("keydown", handleKeydown)
    }
  })

  element.addEventListener(
    "blur",
    function handleBlur() {
      saveInlineEdit(element, type)
      element.removeEventListener("blur", handleBlur)
    },
    { once: true },
  )
}

/**
 * Salva as altera√ß√µes feitas durante a edi√ß√£o inline
 * @param {HTMLElement} element - Elemento sendo editado
 * @param {string} type - Tipo do elemento ('project' ou 'room')
 */
function saveInlineEdit(element, type) {
  const newText = element.textContent.trim()
  const originalText = element.dataset.originalText

  disableEditing(element)

  if (!validateEditedText(newText, originalText, element)) return

  if (newText !== originalText) {
    element.textContent = newText
    const entityType = type === "project" ? "Projeto" : "Sala"
    console.log(` ${entityType} renomeado para: ${newText}`)
  }

  delete element.dataset.originalText
}

/**
 * Desabilita o modo de edi√ß√£o do elemento
 * @param {HTMLElement} element - Elemento a ser desabilitado
 */
function disableEditing(element) {
  element.contentEditable = false
  element.classList.remove("editing")
}

/**
 * Valida o texto editado pelo usu√°rio
 * @param {string} newText - Novo texto inserido
 * @param {string} originalText - Texto original
 * @param {HTMLElement} element - Elemento sendo validado
 * @returns {boolean} True se o texto √© v√°lido
 */
function validateEditedText(newText, originalText, element) {
  if (newText === "") {
    element.textContent = originalText
    alert("O nome n√£o pode estar vazio.")
    return false
  }
  return true
}

/**
 * Cancela a edi√ß√£o e restaura o texto original
 * @param {HTMLElement} element - Elemento cuja edi√ß√£o ser√° cancelada
 */
function cancelInlineEdit(element) {
  const originalText = element.dataset.originalText

  disableEditing(element)
  element.textContent = originalText
  delete element.dataset.originalText

  console.log(" Edi√ß√£o cancelada")
}

export {
  makeEditable,
  enableEditing,
  selectElementContent,
  attachEditingEventListeners,
  saveInlineEdit,
  disableEditing,
  validateEditedText,
  cancelInlineEdit
}
/* ==== FIM: edit.js ==== */

/* ==== IN√çCIO: helpers.js ==== */
// helpers.js

/**
 * Converte valores de entrada de forma segura para n√∫meros
 * @param {any} value - Valor a ser convertido
 * @param {number} defaultValue - Valor padr√£o caso a convers√£o falhe
 * @returns {number} Valor num√©rico convertido
 */
function safeNumber(value, defaultValue = 0) {
  return (value !== "" && value !== undefined && value !== null) 
    ? Number(value) 
    : defaultValue;
}

/**
 * Aguarda carregamento ass√≠ncrono das constantes do sistema
 * @returns {Promise<boolean>} True quando as constantes est√£o dispon√≠veis
 * @throws {Error} Se as constantes n√£o carregarem dentro do tempo limite
 */
async function waitForSystemConstants() {
  let attempts = 0;
  const maxAttempts = 100;
  
  while ((!window.systemConstants || !window.systemConstants.VARIAVEL_PD) && attempts < maxAttempts) {
    console.log(" Aguardando constantes do sistema...", attempts);
    await new Promise((resolve) => setTimeout(resolve, 200));
    attempts++;
  }
  
  if (attempts >= maxAttempts) {
    console.error(" TIMEOUT: Constantes do sistema n√£o carregadas ap√≥s", maxAttempts, "tentativas");
    console.error(" systemConstants atual:", window.systemConstants);
    throw new Error("Constantes do sistema n√£o carregadas");
  }
  
  console.log(" Constantes do sistema dispon√≠veis ap√≥s", attempts, "tentativas");
  return true;
}

/**
 * Valida integridade das constantes do sistema necess√°rias para c√°lculos
 * @returns {boolean} True se todas as constantes necess√°rias est√£o dispon√≠veis
 */
function validateSystemConstants() {
  if (!window.systemConstants) {
    console.error(" systemConstants √© null ou undefined");
    return false;
  }
  
  const requiredConstants = [
    'VARIAVEL_PD', 'VARIAVEL_PS', 'AUX_U_Value_Piso', 'AUX_Fator_Iluminacao',
    'AUX_Fs_Iluminacao', 'AUX_Fator_Conver_Painel', 'AUX_Fs_Paineis',
    'AUX_OCp_Csp', 'AUX_OCp_Clp', 'Densi_ar', 'AUX_c_ArExterno',
    'AUX_deltaT_ArExterno', 'AUX_f_ArExterno', 'AUX_deltaUa_ArExterno',
    'deltaT_piso', 'deltaT_teto', 'deltaT_parede_Oes', 'deltaT_parede_Les',
    'deltaT_parede_Nor', 'deltaT_parede_Sul', 'deltaT_divi_N_clim1',
    'deltaT_divi_N_clim2', 'deltaT_divi_clim1', 'deltaT_divi_clim2'
  ];
  
  const missingConstants = requiredConstants.filter(constant => 
    window.systemConstants[constant] === undefined || window.systemConstants[constant] === null
  );
  
  if (missingConstants.length > 0) {
    console.error(" Constantes faltando:", missingConstants);
    return false;
  }
  
  console.log(" Todas as constantes necess√°rias est√£o dispon√≠veis");
  return true;
}

/**
 * Coleta dados de entrada da interface para processamento de climatiza√ß√£o
 * @param {HTMLElement} climaSection - Elemento HTML da se√ß√£o de climatiza√ß√£o
 * @param {string} roomId - ID √∫nico da sala (formato: obra_w12_proj_t34_1_sala_r21_1)
 * @returns {Object} Dados coletados dos inputs
 */
function collectClimatizationInputs(climaSection, roomId) {
  console.log(`üìù [COLLECT] Coletando inputs para sala: ${roomId}`);
  
  const inputs = climaSection.querySelectorAll(".clima-input, input[data-field], select[data-field]");
  const data = {};

  inputs.forEach((input) => {
    const field = input.dataset.field;
    let value;
    
    // ‚úÖ CORRE√á√ÉO: Tratar diferentes tipos de input
    if (input.type === 'checkbox') {
      value = input.checked;
    } else if (input.type === 'number' || input.type === 'text') {
      value = input.value !== "" ? (input.type === 'number' ? Number.parseFloat(input.value) : input.value) : "";
    } else if (input.tagName === 'SELECT') {
      value = input.value !== "" ? input.value : "";
    }
    
    if (field) {
      data[field] = value;
    }
  });

  // ‚úÖ CORRE√á√ÉO: Garantir que pressurizacao e setpointPressurizacao estejam presentes
  if (data.pressurizacao === undefined) {
    const pressurizacaoCheckbox = climaSection.querySelector('input[data-field="pressurizacao"]');
    data.pressurizacao = pressurizacaoCheckbox ? pressurizacaoCheckbox.checked : false;
  }
  
  if (data.setpointPressurizacao === undefined) {
    const setpointInput = climaSection.querySelector('input[data-field="setpointPressurizacao"]');
    data.setpointPressurizacao = setpointInput ? safeNumber(setpointInput.value) : 0;
  }

  console.log(`‚úÖ [COLLECT] ${Object.keys(data).length} dados coletados para ${roomId}:`, data);
  return data;
}

/**
 * Encontra a se√ß√£o de climatiza√ß√£o de uma sala pelo ID √∫nico
 * @param {string} roomId - ID √∫nico da sala
 * @returns {HTMLElement|null} Elemento da se√ß√£o de climatiza√ß√£o
 */
function findClimatizationSection(roomId) {
  // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
  const roomElement = document.querySelector(`[data-room-id="${roomId}"]`);
  if (!roomElement) {
    console.error(`‚ùå [FIND] Sala n√£o encontrada: ${roomId}`);
    return null;
  }
  
  const climaSection = roomElement.querySelector('#section-content-' + roomId + '-clima');
  if (!climaSection) {
    console.error(`‚ùå [FIND] Se√ß√£o de climatiza√ß√£o n√£o encontrada para: ${roomId}`);
    return null;
  }
  
  console.log(`‚úÖ [FIND] Se√ß√£o encontrada para: ${roomId}`);
  return climaSection;
}

/**
 * Atualiza elemento de texto gen√©rico no DOM
 * @param {string} elementId - ID do elemento a ser atualizado
 * @param {any} value - Novo valor a ser definido
 * @returns {void}
 */
function updateElementText(elementId, value) {
  const element = document.getElementById(elementId);
  if (element) {
    element.textContent = value;
  } else {
    console.log(`‚ö†Ô∏è  [DEBUG] Elemento ${elementId} n√£o encontrado`);
  }
}

/**
 * Atualiza display de vaz√£o de ar para sala espec√≠fica
 * @param {string} roomId - ID √∫nico da sala
 * @param {number} flowRate - Valor da vaz√£o calculada
 * @returns {void}
 */
function updateAirFlowDisplay(roomId, flowRate) {
  const flowElement = document.getElementById(`vazao-ar-${roomId}`);
  if (flowElement) {
    flowElement.textContent = Math.round(flowRate);
    console.log(`‚úÖ [AIR FLOW] Vaz√£o atualizada para ${roomId}: ${Math.round(flowRate)} l/s`);
  } else {
    console.error(`‚ùå [AIR FLOW] Elemento de vaz√£o n√£o encontrado para: ${roomId}`);
  }
}

/**
 * Atualiza display de ganhos t√©rmicos para sala espec√≠fica
 * @param {string} roomId - ID √∫nico da sala
 * @param {Object} thermalData - Dados de ganhos t√©rmicos
 * @returns {void}
 */
function updateThermalGainsDisplay(roomId, thermalData) {
  console.log(`üî• [THERMAL] Atualizando ganhos para: ${roomId}`, thermalData);
  
  // Mapeamento de campos para elementos
  const thermalElements = {
    'total-ganhos-w': `total-ganhos-w-${roomId}`,
    'total-tr': `total-tr-${roomId}`,
    'total-externo': `total-externo-${roomId}`,
    'total-divisoes': `total-divisoes-${roomId}`,
    'total-piso': `total-piso-${roomId}`,
    'total-iluminacao': `total-iluminacao-${roomId}`,
    'total-dissi': `total-dissi-${roomId}`,
    'total-pessoas': `total-pessoas-${roomId}`,
    'total-ar-sensivel': `total-ar-sensivel-${roomId}`,
    'total-ar-latente': `total-ar-latente-${roomId}`
  };
  
  Object.entries(thermalElements).forEach(([key, elementId]) => {
    const element = document.getElementById(elementId);
    if (element && thermalData[key] !== undefined) {
      element.textContent = Math.round(thermalData[key]);
    }
  });
  
  console.log(`‚úÖ [THERMAL] Ganhos atualizados para: ${roomId}`);
}

export {
  safeNumber,
  waitForSystemConstants,
  validateSystemConstants,
  collectClimatizationInputs,
  findClimatizationSection,
  updateElementText,
  updateAirFlowDisplay,
  updateThermalGainsDisplay
};
/* ==== FIM: helpers.js ==== */

/* ==== IN√çCIO: interface.js ==== */
/**
 * interface.js - CORRE√á√ÉO DO SISTEMA DE TOGGLE
 * SISTEMA CORRIGIDO COM IDs √öNICOS
 */

import { 
    showSystemStatus,
    removeExistingStatusBanner,
    createStatusBanner,
    insertStatusBanner,
    scheduleStatusBannerRemoval,
} from './intr-files/status-manager.js'

import { 
    toggleElementVisibility,
    expandElement,
    collapseElement,
    calculateRoomCompletionStats,
    removeEmptyObraMessage,
    showEmptyObraMessageIfNeeded,
    removeEmptyProjectMessage,
    showEmptyProjectMessageIfNeeded,
} from './intr-files/ui-helpers.js'

import { 
    createEmptyObra,
    buildObraHTML,
    buildObraActionsFooter,
    insertObraIntoDOM,
    updateObraButtonAfterSave,
    deleteObra,
    getNextObraNumber,
    addNewObra,
} from './intr-files/obra-manager.js'

import { 
    createEmptyProject,
    buildProjectHTML,
    addNewProjectToObra
} from './intr-files/project-manager.js'

import{getNextProjectNumber} from '../data/data-files/data-utils-core.js'

import { createEmptyRoom } from '../data/modules/room-operations.js'

// Re-exporta√ß√µes para manter compatibilidade
export {
    showSystemStatus,
    removeExistingStatusBanner,
    createStatusBanner,
    insertStatusBanner,
    scheduleStatusBannerRemoval,
    toggleElementVisibility,
    expandElement,
    collapseElement,
    calculateRoomCompletionStats,
    removeEmptyObraMessage,
    showEmptyObraMessageIfNeeded,
    removeEmptyProjectMessage,
    showEmptyProjectMessageIfNeeded,
    createEmptyObra,
    buildObraHTML,
    buildObraActionsFooter,
    insertObraIntoDOM,
    updateObraButtonAfterSave,
    deleteObra,
    getNextObraNumber,
    addNewObra,
    createEmptyProject,
    buildProjectHTML,
    addNewProjectToObra,
    getNextProjectNumber,
    createEmptyRoom,
}

/**
 * Adiciona um novo projeto √† obra mais recente
 * @returns {void}
 * 
 * @example
 * addNewProject() // Cria uma nova obra e adiciona um projeto nela
 */
function addNewProject() {
  addNewObra().then(() => {
    const obraNumber = getNextObraNumber() - 1
    const obraName = `Obra${obraNumber}`
    addNewProjectToObra(obraName)
  })
}

// =============================================================================
// SISTEMA DE TOGGLE CORRIGIDO - IDs √öNICOS
// =============================================================================

/**
 * Alterna a visibilidade do conte√∫do de uma obra (expandir/recolher) - CORRE√á√ÉO COMPLETA
 * @param {string} obraId - ID √∫nico da obra a ser alternada
 * @param {Event} event - Evento de clique do usu√°rio
 * @returns {void}
 * 
 * @example
 * toggleObra('obra_a42', event) // Expande ou recolhe a obra com ID 'obra_a42'
 */
function toggleObra(obraId, event) {
    console.log(`üîß Toggle Obra chamado: ${obraId}`);
    
    // ‚úÖ CORRE√á√ÉO: Validar ID √∫nico
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
        console.error(`ERRO FALBACK (toggleObra) interface.js [ID de obra inv√°lido: ${obraId}]`);
        return;
    }
    
    // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
    const contentId = `obra-content-${obraId}`;
    const content = document.getElementById(contentId);
    
    if (!content) {
        console.error(`‚ùå Conte√∫do da obra ${obraId} n√£o encontrado`);
        console.log('üîç Conte√∫dos de obra dispon√≠veis:');
        document.querySelectorAll('[id^="obra-content-"]').forEach(content => {
            console.log(`  - ${content.id}`);
        });
        return;
    }

    const isCollapsed = content.classList.contains("collapsed");
    const minimizer = event.target;

    if (isCollapsed) {
        content.classList.remove("collapsed");
        minimizer.textContent = "‚àí";
        console.log(`üìÇ Obra ${obraId} expandida`);
    } else {
        content.classList.add("collapsed");
        minimizer.textContent = "+";
        console.log(`üìÅ Obra ${obraId} recolhida`);
    }
}

/**
 * Alterna a visibilidade do conte√∫do de um projeto (expandir/recolher) - CORRE√á√ÉO COMPLETA
 * @param {string} projectId - ID √∫nico do projeto a ser alternado
 * @param {Event} event - Evento de clique do usu√°rio
 * @returns {void}
 * 
 * @example
 * toggleProject('obra_a42_proj1', event) // Expande ou recolhe o projeto com ID 'obra_a42_proj1'
 */
function toggleProject(projectId, event) {
    console.log(`üîß Toggle Project chamado: ${projectId}`);
    
    // ‚úÖ CORRE√á√ÉO: Validar ID √∫nico
    if (!projectId || projectId === 'undefined' || projectId === 'null') {
        console.error(`ERRO FALBACK (toggleProject) interface.js [ID de projeto inv√°lido: ${projectId}]`);
        return;
    }
    
    // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
    const contentId = `project-content-${projectId}`;
    const content = document.getElementById(contentId);
    
    if (!content) {
        console.error(`‚ùå Conte√∫do do projeto ${projectId} n√£o encontrado`);
        console.log('üîç Conte√∫dos de projeto dispon√≠veis:');
        document.querySelectorAll('[id^="project-content-"]').forEach(content => {
            console.log(`  - ${content.id}`);
        });
        return;
    }

    const isCollapsed = content.classList.contains("collapsed");
    const minimizer = event.target;

    if (isCollapsed) {
        content.classList.remove("collapsed");
        minimizer.textContent = "‚àí";
        console.log(`üìÇ Projeto ${projectId} expandido`);
    } else {
        content.classList.add("collapsed");
        minimizer.textContent = "+";
        console.log(`üìÅ Projeto ${projectId} recolhido`);
    }
}

/**
 * Alterna a visibilidade do conte√∫do de uma sala (expandir/recolher) - CORRE√á√ÉO COMPLETA
 * @param {string} roomId - ID √∫nico da sala
 * @param {Event} event - Evento de clique do usu√°rio
 * @returns {void}
 * 
 * @example
 * toggleRoom('obra_a42_proj1_sala1', event) // Expande ou recolhe a sala com ID 'obra_a42_proj1_sala1'
 */
function toggleRoom(roomId, event) {
    console.log(`üîß Toggle Sala chamado: ID ${roomId}`, event);
    
    // ‚úÖ CORRE√á√ÉO: Validar ID √∫nico
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (toggleRoom) interface.js [ID de sala inv√°lido: ${roomId}]`);
        return;
    }
    
    // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
    const contentId = `room-content-${roomId}`;
    const content = document.getElementById(contentId);
    
    if (!content) {
        console.error(`‚ùå Conte√∫do da sala ${roomId} n√£o encontrado`);
        console.log(`üîç Procurando por: ${contentId}`);
        console.log('üîç Conte√∫dos de sala dispon√≠veis:');
        document.querySelectorAll('[id^="room-content-"]').forEach(content => {
            console.log(`  - ${content.id}`);
        });
        return;
    }

    const isCollapsed = content.classList.contains("collapsed");
    const minimizer = event.target;

    console.log(`üìÇ Estado da sala ${roomId}: ${isCollapsed ? 'recolhida' : 'expandida'}`);

    if (isCollapsed) {
        content.classList.remove("collapsed");
        minimizer.textContent = "‚àí";
        console.log(`üìÇ Sala ${roomId} EXPANDIDA`);
    } else {
        content.classList.add("collapsed");
        minimizer.textContent = "+";
        console.log(`üìÅ Sala ${roomId} RECOLHIDA`);
    }
}

/**
 * Alterna a visibilidade de uma se√ß√£o
 * @param {string} sectionId - ID da se√ß√£o
 * @returns {void}
 * 
 * @example
 * toggleSection('materiais') // Alterna visibilidade da se√ß√£o de materiais
 */
function toggleSection(sectionId) {
    // ‚úÖ CORRE√á√ÉO: Validar ID
    if (!sectionId || sectionId === 'undefined' || sectionId === 'null') {
        console.error(`ERRO FALBACK (toggleSection) interface.js [ID de se√ß√£o inv√°lido: ${sectionId}]`);
        return;
    }
    toggleElementVisibility(`section-content-${sectionId}`, event.target);
}

/**
 * Alterna a visibilidade de uma subse√ß√£o
 * @param {string} subsectionId - ID da subse√ß√£o
 * @returns {void}
 * 
 * @example
 * toggleSubsection('pintura') // Alterna visibilidade da subse√ß√£o de pintura
 */
function toggleSubsection(subsectionId) {
    // ‚úÖ CORRE√á√ÉO: Validar ID
    if (!subsectionId || subsectionId === 'undefined' || subsectionId === 'null') {
        console.error(`ERRO FALBACK (toggleSubsection) interface.js [ID de subse√ß√£o inv√°lido: ${subsectionId}]`);
        return;
    }
    toggleElementVisibility(`subsection-content-${subsectionId}`, event.target);
}

// =============================================================================
// FUN√á√ïES DE DOWNLOAD E SALVAMENTO
// =============================================================================

/**
 * Gera e inicia o download de um PDF para uma obra ou projeto espec√≠fico
 * @param {string} obraId - ID da obra
 * @param {string|null} projectName - Nome do projeto (opcional)
 * @returns {void}
 * 
 * @example
 * downloadPDF('obra_a64') // Gera PDF para a obra com ID obra_a64
 * downloadPDF('obra_a64', 'ProjetoA') // Gera PDF para o ProjetoA da obra
 */
function downloadPDF(obraId, projectName = null) {
    // ‚úÖ CORRE√á√ÉO: Buscar obra por ID em vez de nome
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID "${obraId}" n√£o encontrada para PDF`);
        showSystemStatus(`ERRO: Obra n√£o encontrada`, "error");
        return;
    }

    const obraName = obraBlock.dataset.obraName;
    const target = projectName ? `projeto ${projectName} da obra ${obraName}` : `obra ${obraName}`;
    
    console.log(`üìÑ Gerando PDF para ${target} (ID: ${obraId})`);
    showSystemStatus(`Gerando PDF para ${target}...`, "info");
    
    // ‚úÖ Aqui voc√™ implementaria a gera√ß√£o real do PDF
    // generatePDF(obraId, projectName);
}

/**
 * Gera e inicia o download de um documento Word para uma obra ou projeto espec√≠fico
 * @param {string} obraId - ID da obra
 * @param {string|null} projectName - Nome do projeto (opcional)
 * @returns {void}
 * 
 * @example
 * downloadWord('obra_a64') // Gera Word para a obra com ID obra_a64
 * downloadWord('obra_a64', 'ProjetoA') // Gera Word para o ProjetoA da obra
 */
function downloadWord(obraId, projectName = null) {
    // ‚úÖ CORRE√á√ÉO: Buscar obra por ID em vez de nome
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (!obraBlock) {
        console.error(`‚ùå Obra com ID "${obraId}" n√£o encontrada para Word`);
        showSystemStatus(`ERRO: Obra n√£o encontrada`, "error");
        return;
    }

    const obraName = obraBlock.dataset.obraName;
    const target = projectName ? `projeto ${projectName} da obra ${obraName}` : `obra ${obraName}`;
    
    console.log(`üìù Gerando Word para ${target} (ID: ${obraId})`);
    showSystemStatus(`Gerando documento Word para ${target}...`, "info");
    
    // ‚úÖ Aqui voc√™ implementaria a gera√ß√£o real do Word
    // generateWord(obraId, projectName);
}

/**
 * Salva ou atualiza os dados de uma obra no sistema
 * @param {string} obraName - Nome da obra a ser salva/atualizada
 * @param {Event} event - Evento que triggered a a√ß√£o
 * @returns {void}
 * 
 * @example
 * saveOrUpdateObra('Obra1', event) // Salva/atualiza a Obra1
 */
function saveOrUpdateObra(obraParam, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    console.log(`üíæ SALVANDO/ATUALIZANDO OBRA pelo par√¢metro: "${obraParam}"`);

    // ‚úÖ CORRE√á√ÉO: Converter automaticamente nome para ID
    let obraId = obraParam;
    
    // Se for nome (n√£o come√ßa com "obra_" e n√£o √© num√©rico)
    if (!obraParam.startsWith('obra_') && !/^\d+$/.test(obraParam)) {
        console.warn(`‚ö†Ô∏è  Par√¢metro "${obraParam}" parece ser um nome, convertendo para ID...`);
        
        // Busca ALL obras com este nome
        const obrasComEsteNome = Array.from(document.querySelectorAll('[data-obra-id]'))
            .filter(obra => obra.dataset.obraName === obraParam);
            
        if (obrasComEsteNome.length === 1) {
            obraId = obrasComEsteNome[0].dataset.obraId;
            console.log(`‚úÖ Convertido nome "${obraParam}" ‚Üí ID "${obraId}"`);
        } else if (obrasComEsteNome.length > 1) {
            console.error(`‚ùå M√∫ltiplas obras com nome "${obraParam}", usando a primeira`);
            obraId = obrasComEsteNome[0].dataset.obraId;
        } else {
            console.error(`‚ùå Nenhuma obra encontrada com nome "${obraParam}"`);
            showSystemStatus(`ERRO: Obra "${obraParam}" n√£o encontrada`, "error");
            return;
        }
    }

    // Agora busca pelo ID corrigido
    const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    
    if (!obraBlock) {
        console.error(`‚ùå ERRO: Obra com ID "${obraId}" n√£o encontrada no DOM`);
        
        // Debug detalhado
        const availableObras = document.querySelectorAll('[data-obra-id]');
        console.log(`üîç Obras dispon√≠veis: ${availableObras.length}`);
        availableObras.forEach((obra, idx) => {
            console.log(`   ${idx + 1}. ID: "${obra.dataset.obraId}", Nome: "${obra.dataset.obraName}"`);
        });
        
        showSystemStatus(`ERRO: Obra n√£o encontrada`, "error");
        return;
    }

    console.log(`‚úÖ Obra encontrada:`, obraBlock.dataset);

    if (typeof window.saveObra === 'function') {
        // ‚úÖ Agora passa o ID correto para a fun√ß√£o interna
        window.saveObra(obraId, event);
    } else {
        console.error('‚ùå Fun√ß√£o saveObra n√£o encontrada');
        showSystemStatus("ERRO: Funcionalidade de salvar n√£o dispon√≠vel", "error");
    }
}

// =============================================================================
// FUN√á√ïES DE EDI√á√ÉO (COMPATIBILIDADE)
// =============================================================================

/**
 * Torna um elemento edit√°vel - FUN√á√ÉO DE COMPATIBILIDADE
 * @param {HTMLElement} element - Elemento a ser editado
 * @param {string} type - Tipo do elemento ('obra', 'project', 'room')
 * @returns {void}
 */
function makeEditable(element, type) {
    console.log(`‚úèÔ∏è Tornando ${type} edit√°vel:`, element);
    // Implementa√ß√£o b√°sica - pode ser expandida conforme necess√°rio
    if (element.isContentEditable) {
        element.contentEditable = false;
        element.blur();
    } else {
        element.contentEditable = true;
        element.focus();
    }
}



// =============================================================================
// EXPORTA√á√ïES ADICIONAIS
// =============================================================================

export {
    addNewProject,
    toggleObra,
    toggleProject,
    toggleRoom,
    downloadPDF,
    downloadWord,
    saveOrUpdateObra,
    toggleSubsection,
    toggleSection,
    makeEditable,
}

// =============================================================================
// DISPONIBILIZA√á√ÉO GLOBAL DAS FUN√á√ïES
// =============================================================================

if (typeof window !== 'undefined') {
    window.addNewObra = addNewObra;
    window.addNewProjectToObra = addNewProjectToObra;
    window.toggleObra = toggleObra;
    window.toggleProject = toggleProject;
    window.toggleRoom = toggleRoom;
    window.toggleSubsection = toggleSubsection;
    window.toggleSection = toggleSection;
    window.getNextObraNumber = getNextObraNumber;
    window.deleteObra = deleteObra;
    window.saveOrUpdateObra = saveOrUpdateObra;
    window.downloadPDF = downloadPDF;
    window.downloadWord = downloadWord;
    window.addNewProject = addNewProject;
    window.createEmptyProject = createEmptyProject;
    window.makeEditable = makeEditable;
}
/* ==== FIM: interface.js ==== */

/* ==== IN√çCIO: machineManagement.js ==== */
// machineManagement.js

import { loadMachinesData } from './machinesBuilder.js'
import { updateElementText, removeEmptyMessage, showEmptyMessage } from './utilities.js'

/**
 * Gera um ID √∫nico para m√°quina baseado na sala e timestamp
 * @param {string} roomId - ID da sala
 * @returns {string} ID √∫nico da m√°quina
 */
function generateUniqueMachineId(roomId) {
    return `machine-${roomId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Adiciona uma nova m√°quina de climatiza√ß√£o √† sala especificada - CORRE√á√ÉO
 * @param {string} roomId - ID da sala onde a m√°quina ser√° adicionada
 * @returns {Promise<void>}
 */
async function addMachine(roomId) {
    console.log(`‚ûï [ADD MACHINE] Iniciando para sala: ${roomId}`);
    
    const machinesContainer = document.getElementById(`machines-${roomId}`);
    if (!machinesContainer) {
        console.error(`‚ùå Container de m√°quinas n√£o encontrado para sala: ${roomId}`);
        return;
    }

    // ‚úÖ CORRE√á√ÉO: Contar m√°quinas APENAS desta sala espec√≠fica
    const roomMachineCount = machinesContainer.querySelectorAll(".climatization-machine").length;
    
    // ‚úÖ CORRE√á√ÉO: Usar ID √∫nico baseado na sala
    const uniqueMachineId = generateUniqueMachineId(roomId);
    const machineDisplayNumber = roomMachineCount + 1;

    removeEmptyMessage(machinesContainer);

    console.log(`‚ûï Adicionando m√°quina ${machineDisplayNumber} (sala: ${roomId}, ID √∫nico: ${uniqueMachineId})`);

    try {
        if (!window.machinesData || window.machinesData.length === 0) {
            console.log("üîÑ Cache n√£o encontrado, carregando dados das m√°quinas...");
            await loadMachinesData();
        }

        if (!window.machinesData || window.machinesData.length === 0) {
            throw new Error("Nenhum dado de m√°quina dispon√≠vel ap√≥s carregamento");
        }

        // ‚úÖ CORRE√á√ÉO: Passar roomId e ID √∫nico para a constru√ß√£o
        const machineHTML = buildClimatizationMachineHTML(uniqueMachineId, machineDisplayNumber, window.machinesData, roomId);
        machinesContainer.insertAdjacentHTML("beforeend", machineHTML);
        
        console.log(`‚úÖ M√°quina ${machineDisplayNumber} adicionada √† sala ${roomId} (ID: ${uniqueMachineId})`);

        // ‚úÖ NOVO: Atualizar TOTAL GERAL ap√≥s adicionar m√°quina
        updateAllMachinesTotalDisplay(roomId);

    } catch (error) {
        console.error("‚ùå Erro ao adicionar m√°quina:", error);
        showEmptyMessage(machinesContainer, "Erro ao carregar dados das m√°quinas");
    }
}

/**
 * Constr√≥i o HTML completo para uma m√°quina de climatiza√ß√£o - CORRE√á√ÉO
 * @param {string} machineId - ID √∫nico da m√°quina
 * @param {number} displayNumber - N√∫mero de exibi√ß√£o (1, 2, 3...)
 * @param {Array} machines - Lista de m√°quinas dispon√≠veis
 * @param {string} roomId - ID da sala (para refer√™ncia)
 * @returns {string} HTML da m√°quina de climatiza√ß√£o
 */
function buildClimatizationMachineHTML(machineId, displayNumber, machines, roomId) {
    const machineTypes = machines.map((m) => m.type);

    return `
        <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${roomId}">
            <div class="machine-header">
              <button class="minimizer" onclick="toggleMachineSection(this)">‚àí</button>
              <input type="text" class="machine-title-editable" value="Maquina${displayNumber}" 
                    onchange="updateMachineTitle(this, '${machineId}')" 
                    onclick="this.select()">
              <div class="machine-actions">
                <button class="btn btn-delete-small" onclick="deleteClimatizationMachine(this)">Remover</button>
              </div>
            </div>
            <div class="machine-content" id="machine-content-${machineId}">
                <div class="climatization-form-grid">
                    ${buildFormGroup(
                        "Tipo de Equipamento:",
                        buildSelectWithDefault(machineTypes, machineId, "machine-type-select", "updateMachineOptions(this)", "Selecionar M√°quina"),
                    )}
                    ${buildFormGroup(
                        "Capacidade:",
                        buildSelectWithDefault([], machineId, "machine-power-select", `handlePowerChange('${machineId}')`, "Selecionar capacidade", true),
                    )}
                    ${buildFormGroup(
                        "Tens√£o:",
                        buildSelectWithDefault([], machineId, "machine-voltage-select", `calculateMachinePrice('${machineId}')`, "Selecionar Tens√£o", true),
                    )}
                    <div class="form-group">
                        <label>Pre√ßo Base:</label>
                        <div class="price-display" id="base-price-${machineId}">
                            R$ 0,00
                        </div>
                    </div>
                    <div class="form-group"> <!-- Pre√ßo final desta m√°quina -->
                        <label>Pre√ßo Total desta M√°quina: </label>
                          <div class="price-display" id="total-price-${machineId}"">
                            R$ 0,00
                          </div>
                    </div>
                </div>
                <div class="machine-options-section">
                    <h6>Op√ß√µes Adicionais:</h6>
                    <div class="options-grid" id="options-container-${machineId}">
                        <p class="empty-options-message">Selecione um tipo de m√°quina e sua capacidade para ver as op√ß√µes e seus valores</p>
                    </div>
                </div>
                <!-- ‚ùå REMOVIDO: N√ÉO colocar all-machines-total-price aqui -->
            </div>
        </div>
    `;
}

/**
 * Constr√≥i um grupo de formul√°rio com label e conte√∫do
 * @param {string} label - Texto do label
 * @param {string} content - Conte√∫do HTML do campo
 * @returns {string} HTML do grupo de formul√°rio
 */
function buildFormGroup(label, content) {
  return `
    <div class="form-group">
      <label>${label}</label>
      ${content}
    </div>
  `
}

/**
 * Constr√≥i um elemento select com op√ß√µes e handlers
 * @param {Array} options - Lista de op√ß√µes do select
 * @param {number} machineId - ID √∫nico da m√°quina
 * @param {string} className - Classe CSS do select
 * @param {string} onchangeHandler - Fun√ß√£o a ser executada onchange
 * @param {string} defaultText - Texto padr√£o para op√ß√£o vazia
 * @param {boolean} disabled - Se o select deve iniciar desabilitado
 * @returns {string} HTML do elemento select
 */
function buildSelectWithDefault(options, machineId, className, onchangeHandler, defaultText = "Selecionar", disabled = false) {
  const disabledAttr = disabled ? 'disabled' : ''
  return `
    <select class="form-input ${className}" 
            data-machine-id="${machineId}"
            onchange="${onchangeHandler}"
            ${disabledAttr}>
      <option value="">${defaultText}</option>
      ${options.map((opt) => `<option value="${opt}">${opt}</option>`).join("")}
    </select>
  `
}

/**
 * Constr√≥i a interface de op√ß√µes adicionais da m√°quina
 * @param {Array} options - Lista de op√ß√µes dispon√≠veis
 * @param {number} machineId - ID √∫nico da m√°quina
 * @param {string} selectedPower - Pot√™ncia selecionada (TR)
 * @param {Array} selectedOptions - Op√ß√µes pr√©-selecionadas
 * @returns {string} HTML das op√ß√µes
 */
function buildOptionsHTML(options, machineId, selectedPower = null, selectedOptions = []) {
  if (!options || options.length === 0) {
    return '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel para esta m√°quina</p>'
  }

  return options
    .map((option) => {
      const isSelected = selectedOptions.some(selected => selected.id === option.id);
      const selectedClass = isSelected ? 'option-selected' : '';
      
      let optionValue = 0;
      if (selectedPower && option.values && option.values[selectedPower] !== undefined) {
        optionValue = option.values[selectedPower];
      }
      
      const optionDisplayValue = `+R$ ${optionValue.toLocaleString("pt-BR")}`;

      return `
        <div class="option-item ${selectedClass}" onclick="handleOptionClick('${machineId}', ${option.id})">
          <div class="option-checkbox">
            <input type="checkbox" 
                  value="${optionValue}" 
                  data-option-id="${option.id}"
                  data-option-name="${option.name}"
                  onchange="updateOptionSelection('${machineId}', '${option.id}'); calculateMachinePrice('${machineId}')"
                  id="option-${machineId}-${option.id}"
                  ${isSelected ? 'checked' : ''}>
            <div class="option-content">
              <div class="option-name">${option.name}</div>
              <div class="option-price">${optionDisplayValue}</div>
            </div>
          </div>
        </div>
      `;
    })
    .join("")
}

/**
 * Manipula a mudan√ßa de pot√™ncia (TR) da m√°quina
 * Atualiza pre√ßo base e valores das op√ß√µes
 * @param {number} machineId - ID √∫nico da m√°quina
 * @returns {void}
 */
function handlePowerChange(machineId) {
    console.log(`üîß Mudan√ßa de pot√™ncia na m√°quina ${machineId}`);
    
    // Atualizar pre√ßo base
    calculateMachinePrice(machineId);
    
    // Atualizar valores das op√ß√µes
    updateOptionValues(machineId);
}

/**
 * Atualiza os valores das op√ß√µes quando a pot√™ncia √© alterada
 * @param {number} machineId - ID √∫nico da m√°quina
 * @returns {void}
 */
function updateOptionValues(machineId) {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`);
    if (!machineElement) {
        console.error(`‚ùå M√°quina ${machineId} n√£o encontrada`);
        return;
    }
    
    const typeSelect = machineElement.querySelector('.machine-type-select');
    const powerSelect = machineElement.querySelector('.machine-power-select');
    
    const selectedType = typeSelect?.value;
    const selectedPower = powerSelect?.value;
    
    console.log(`üîß Atualizando op√ß√µes para m√°quina ${machineId}:`, { selectedType, selectedPower });
    
    if (!selectedType || !selectedPower || !window.machinesData) {
        console.log('‚ö†Ô∏è Tipo ou pot√™ncia n√£o selecionados');
        return;
    }
    
    const machine = window.machinesData.find(m => m.type === selectedType);
    if (!machine || !machine.options) {
        console.error(`‚ùå M√°quina ${selectedType} n√£o encontrada nos dados`);
        return;
    }
    
    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (!optionsContainer) {
        console.error(`‚ùå Container de op√ß√µes n√£o encontrado para m√°quina ${machineId}`);
        return;
    }
    
    console.log(`üîß Atualizando ${machine.options.length} op√ß√µes para TR ${selectedPower}`);
    
    // Atualizar valores e display de todas as op√ß√µes
    machine.options.forEach(option => {
        const checkbox = document.getElementById(`option-${machineId}-${option.id}`);
        if (checkbox) {
            let optionValue = 0;
            if (selectedPower && option.values && option.values[selectedPower] !== undefined) {
                optionValue = option.values[selectedPower];
                console.log(`üí∞ Op√ß√£o ${option.name}: R$ ${optionValue} para ${selectedPower}`);
            }
            
            // Atualizar valor do checkbox
            checkbox.value = optionValue;
            
            // Atualizar display do pre√ßo
            const priceDisplay = checkbox.closest('.option-item')?.querySelector('.option-price');
            if (priceDisplay) {
                const optionDisplayValue = `+R$ ${optionValue.toLocaleString("pt-BR")}`;
                priceDisplay.textContent = optionDisplayValue;
                console.log(`üìù Atualizado display: ${option.name} = ${optionDisplayValue}`);
            }
        } else {
            console.warn(`‚ö†Ô∏è Checkbox n√£o encontrado para op√ß√£o ${option.id}`);
        }
    });
    
    // Recalcular pre√ßo total
    calculateMachinePrice(machineId);
    console.log(`‚úÖ Op√ß√µes atualizadas para TR ${selectedPower}`);
}

/**
 * Manipula o clique na op√ß√£o para alternar sele√ß√£o
 * @param {number} machineId - ID √∫nico da m√°quina
 * @param {number} optionId - ID da op√ß√£o
 * @returns {void}
 */
function handleOptionClick(machineId, optionId) {
  const checkbox = document.getElementById(`option-${machineId}-${optionId}`)
  if (checkbox) {
    checkbox.checked = !checkbox.checked
    // Disparar o evento change manualmente para garantir que todos os handlers sejam executados
    const event = new Event('change', { bubbles: true })
    checkbox.dispatchEvent(event)
  }
}

/**
 * Atualiza a apar√™ncia visual da op√ß√£o quando selecionada/deselecionada
 * @param {number} machineId - ID √∫nico da m√°quina
 * @param {number} optionId - ID da op√ß√£o
 * @returns {void}
 */
function updateOptionSelection(machineId, optionId) {
  const checkbox = document.getElementById(`option-${machineId}-${optionId}`)
  const optionItem = checkbox?.closest('.option-item')
  
  if (optionItem) {
    if (checkbox.checked) {
      optionItem.classList.add('option-selected')
    } else {
      optionItem.classList.remove('option-selected')
    }
    console.log(`üîß Op√ß√£o ${optionId} ${checkbox.checked ? 'selecionada' : 'deselecionada'} na m√°quina ${machineId}`)
  }
}

/**
 * Alterna a exibi√ß√£o da se√ß√£o da m√°quina (expandir/recolher)
 * @param {HTMLButtonElement} button - Bot√£o que acionou a fun√ß√£o
 * @returns {void}
 */
function toggleMachineSection(button) {
  const machineContent = button.closest(".climatization-machine").querySelector(".machine-content")
  const isCollapsed = machineContent.classList.toggle("collapsed")
  button.textContent = isCollapsed ? "+" : "‚àí"
}

/**
 * Atualiza o t√≠tulo da m√°quina quando editado pelo usu√°rio
 * @param {HTMLInputElement} input - Campo de input do t√≠tulo
 * @param {number} machineId - ID √∫nico da m√°quina
 * @returns {void}
 */
function updateMachineTitle(input, machineId) {
  const newTitle = input.value.trim()
  if (!newTitle) {
    input.value = `Maquina${machineId}`
  }
}

/**
 * Atualiza as op√ß√µes da m√°quina quando o tipo √© alterado
 * Carrega novos dados de pot√™ncia, tens√£o e op√ß√µes
 * @param {HTMLSelectElement} selectElement - Select do tipo de m√°quina
 * @returns {Promise<void>}
 */
async function updateMachineOptions(selectElement) {
    const machineId = selectElement.getAttribute("data-machine-id");
    const selectedType = selectElement.value;

    console.log(`üîÑ Atualizando op√ß√µes para m√°quina ${machineId}, tipo: ${selectedType}`);

    if (!selectedType) {
        resetMachineFields(machineId);
        return;
    }

    try {
        // Buscar nos dados em cache
        if (window.machinesData && window.machinesData.length > 0) {
            const selectedMachine = window.machinesData.find((m) => m.type === selectedType);
            if (selectedMachine) {
                console.log(`‚úÖ M√°quina encontrada no cache: ${selectedType}`);
                updateMachineUI(machineId, selectedMachine);
                return;
            }
        }

        // Carregar dados do servidor
        console.log("üöÄ Carregando dados do servidor...");
        const response = await fetch('/machines');
        if (response.ok) {
            const data = await response.json();
            const machines = Array.isArray(data) ? data : data.machines;
            window.machinesData = machines;
            
            const selectedMachine = machines.find((m) => m.type === selectedType);
            if (selectedMachine) {
                console.log(`‚úÖ M√°quina encontrada no servidor: ${selectedType}`);
                updateMachineUI(machineId, selectedMachine);
            } else {
                console.error(`‚ùå M√°quina n√£o encontrada: ${selectedType}`);
                resetMachineFields(machineId);
            }
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

    } catch (error) {
        console.error("‚ùå Erro ao atualizar op√ß√µes:", error);
        resetMachineFields(machineId);
    }
}

/**
 * Atualiza a UI da m√°quina com novos dados
 * @param {number} machineId - ID √∫nico da m√°quina
 * @param {Object} selectedMachine - Dados da m√°quina selecionada
 * @returns {void}
 */
function updateMachineUI(machineId, selectedMachine) {
    console.log(`üéØ Atualizando UI completa para m√°quina ${machineId}`);
    
    // Atualizar pot√™ncias
    const potencies = Object.keys(selectedMachine.baseValues || {});
    updateSelect(`.machine-power-select[data-machine-id="${machineId}"]`, potencies, "Selecionar Capacidade", false);

    // Atualizar tens√µes
    const voltageNames = (selectedMachine.voltages || []).map(v => v.name);
    updateSelect(`.machine-voltage-select[data-machine-id="${machineId}"]`, voltageNames, "Selecionar Tens√£o", false);

    // Atualizar op√ß√µes
    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    
    if (optionsContainer) {
        console.log(`üîß Container de op√ß√µes encontrado para m√°quina ${machineId}`);
        
        // Limpar completamente o container
        optionsContainer.innerHTML = '';
        
        const options = selectedMachine.options || [];
        console.log(`üîß Renderizando ${options.length} op√ß√µes para m√°quina ${machineId}`);
        
        if (options.length > 0) {
            const optionsHTML = buildOptionsHTML(options, machineId, null, []);
            optionsContainer.innerHTML = optionsHTML;
            console.log(`‚úÖ ${options.length} op√ß√µes HTML inseridas no container da m√°quina ${machineId}`);
            
            // Garantir que as op√ß√µes sejam vis√≠veis
            setTimeout(() => {
                const renderedOptions = optionsContainer.querySelectorAll('.option-item');
                console.log(`üëÅÔ∏è ${renderedOptions.length} op√ß√µes vis√≠veis no DOM para m√°quina ${machineId}`);
                
                // Atualizar sele√ß√£o visual de todas as op√ß√µes
                options.forEach(option => {
                    updateOptionSelection(machineId, option.id);
                });
            }, 50);
        } else {
            optionsContainer.innerHTML = '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel para esta m√°quina</p>';
        }
    } else {
        console.error(`‚ùå Container de op√ß√µes n√£o encontrado para m√°quina ${machineId}`);
    }

    // Resetar pre√ßos
    updateElementText(`base-price-${machineId}`, `R$ 0,00`);
    updateElementText(`total-price-${machineId}`, `R$ 0,00`);

    console.log(`‚úÖ UI completamente atualizada para m√°quina ${machineId}`);
}

/**
 * Reseta os campos da m√°quina para o estado inicial
 * @param {number} machineId - ID √∫nico da m√°quina
 * @returns {void}
 */
function resetMachineFields(machineId) {
    console.log(`üîÑ Resetando campos da m√°quina ${machineId}`);
    
    updateSelect(`.machine-power-select[data-machine-id="${machineId}"]`, [], "Selecionar Capacidade", true);
    updateSelect(`.machine-voltage-select[data-machine-id="${machineId}"]`, [], "Selecionar Tens√£o", true);

    const optionsContainer = document.getElementById(`options-container-${machineId}`);
    if (optionsContainer) {
        optionsContainer.innerHTML = '<p class="empty-options-message">Selecione um tipo de m√°quina para ver as op√ß√µes</p>';
    }

    updateElementText(`base-price-${machineId}`, `R$ 0,00`);
    updateElementText(`total-price-${machineId}`, `R$ 0,00`);
}

/**
 * Atualiza as op√ß√µes de um elemento select
 * @param {string} selector - Seletor do elemento select
 * @param {Array} options - Novas op√ß√µes a serem adicionadas
 * @param {string} defaultText - Texto da op√ß√£o padr√£o
 * @param {boolean} disabled - Se deve desabilitar o select
 * @returns {void}
 */
function updateSelect(selector, options, defaultText = "Selecionar", disabled = false) {
    const select = document.querySelector(selector);
    if (select) {
        select.innerHTML = `
            <option value="">${defaultText}</option>
            ${options.map((opt) => `<option value="${opt}">${opt}</option>`).join("")}
        `;
        select.disabled = disabled;
        console.log(`üîß Select ${selector} atualizado com ${options.length} op√ß√µes`);
    } else {
        console.error(`‚ùå Select n√£o encontrado: ${selector}`);
    }
}

// === FUN√á√ïES PARA C√ÅLCULO TOTAL GERAL === //

/**
 * Extrai valor num√©rico do texto de pre√ßo
 * @param {string} priceText - Texto do pre√ßo (ex: "R$ 1.234,56")
 * @returns {number} Valor num√©rico
 */
function extractPriceValue(priceText) {
    if (!priceText) return 0;
    
    // Remove "R$", espa√ßos e converte para n√∫mero
    const cleanText = priceText.replace('R$', '').replace(/\./g, '').replace(',', '.').trim();
    return Number.parseFloat(cleanText) || 0;
}

/**
 * Calcula a soma total de TODAS as m√°quinas de uma sala
 * @param {string} roomId - ID da sala
 * @returns {number} Soma total em reais
 */
function calculateTotalAllMachinesPrice(roomId) {
    const machinesContainer = document.getElementById(`machines-${roomId}`);
    if (!machinesContainer) return 0;

    const machineElements = machinesContainer.querySelectorAll('.climatization-machine');
    let totalGeral = 0;

    machineElements.forEach(machineElement => {
        const machineId = machineElement.dataset.machineId;
        const totalPriceElement = document.getElementById(`total-price-${machineId}`);
        
        if (totalPriceElement) {
            const priceText = totalPriceElement.textContent;
            const priceValue = extractPriceValue(priceText);
            totalGeral += priceValue;
            
            console.log(`‚ûï M√°quina ${machineId}: R$ ${priceValue.toLocaleString('pt-BR')}`);
        }
    });

    console.log(`üí∞ TOTAL GERAL sala ${roomId}: R$ ${totalGeral.toLocaleString('pt-BR')} (${machineElements.length} m√°quinas)`);
    return totalGeral;
}

/**
 * Atualiza o display do total geral de TODAS as m√°quinas
 * @param {string} roomId - ID da sala
 * @returns {void}
 */
function updateAllMachinesTotalDisplay(roomId) {
    const totalGeral = calculateTotalAllMachinesPrice(roomId);
    const totalDisplay = document.getElementById(`total-all-machines-price-${roomId}`);
    
    if (totalDisplay) {
        totalDisplay.textContent = `R$ ${totalGeral.toLocaleString('pt-BR')}`;
        console.log(`üìä Display atualizado: Total Geral = R$ ${totalGeral.toLocaleString('pt-BR')}`);
    }
    
    // Salvar no JSON da sala
    saveTotalAllMachinesPriceToRoom(roomId, totalGeral);
}

/**
 * Salva o total geral das m√°quinas no JSON da sala
 * @param {string} roomId - ID da sala
 * @param {number} totalGeral - Valor total geral
 * @returns {void}
 */
function saveTotalAllMachinesPriceToRoom(roomId, totalGeral) {
    try {
        console.log(`üíæ Salvando TOTAL GERAL m√°quinas para sala ${roomId}: R$ ${totalGeral.toLocaleString('pt-BR')}`);
        
        // Buscar todas as obras
        fetch('/obras')
            .then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return response.json();
            })
            .then(obras => {
                let obraUpdated = false;
                let obraParaAtualizar = null;
                
                // Buscar pela sala usando roomId
                for (const obra of obras) {
                    for (const projeto of obra.projetos || []) {
                        for (const sala of projeto.salas || []) {
                            if (sala.id === roomId) {
                                // Atualizar o campo somavaloresmaquinatotal (TOTAL GERAL)
                                sala.somavaloresmaquinatotal = totalGeral;
                                obraUpdated = true;
                                obraParaAtualizar = obra;
                                console.log(`‚úÖ TOTAL GERAL salvo: R$ ${totalGeral.toLocaleString('pt-BR')} na obra ${obra.nome}, sala ${sala.nome}`);
                                break;
                            }
                        }
                        if (obraUpdated) break;
                    }
                    if (obraUpdated) break;
                }

                if (obraUpdated && obraParaAtualizar) {
                    // Atualizar no servidor
                    return fetch(`/obras/${obraParaAtualizar.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(obraParaAtualizar)
                    });
                }
            })
            .then(response => {
                if (response && response.ok) {
                    console.log(`‚úÖ TOTAL GERAL das m√°quinas salvo com sucesso para sala ${roomId}`);
                }
            })
            .catch(error => {
                console.error('‚ùå Erro ao salvar TOTAL GERAL das m√°quinas:', error);
            });
            
    } catch (error) {
        console.error('‚ùå Erro inesperado ao salvar TOTAL GERAL:', error);
    }
}

/**
 * Calcula o pre√ßo total da m√°quina considerando pre√ßo base e op√ß√µes selecionadas
 * @param {number} machineId - ID √∫nico da m√°quina a ser calculada
 * @returns {void}
 */
function calculateMachinePrice(machineId) {
  try {
    const machineElement = document.querySelector(`[data-machine-id="${machineId}"]`)
    if (!machineElement) return

    // Obter tipo, pot√™ncia e tens√£o selecionados
    const typeSelect = machineElement.querySelector('.machine-type-select')
    const powerSelect = machineElement.querySelector('.machine-power-select')
    const voltageSelect = machineElement.querySelector('.machine-voltage-select')

    const selectedType = typeSelect?.value
    const selectedPower = powerSelect?.value
    const selectedVoltage = voltageSelect?.value

    let basePrice = 0
    let voltageValue = 0

    // Calcular pre√ßo base apenas se tipo e pot√™ncia estiverem selecionados
    if (selectedType && selectedPower && window.machinesData) {
      const machine = window.machinesData.find(m => m.type === selectedType)
      if (machine && machine.baseValues) {
        basePrice = machine.baseValues[selectedPower] || 0
        console.log(`üí∞ Pre√ßo base para ${selectedType} ${selectedPower}: R$ ${basePrice}`)
      }
    }

    // Calcular valor da tens√£o apenas se tens√£o estiver selecionada
    if (selectedType && selectedVoltage && window.machinesData) {
      const machine = window.machinesData.find(m => m.type === selectedType)
      if (machine && machine.voltages) {
        const voltageObj = machine.voltages.find(v => v.name === selectedVoltage)
        voltageValue = voltageObj ? voltageObj.value : 0
        console.log(`‚ö° Tens√£o ${selectedVoltage}: R$ ${voltageValue}`)
      }
    }

    // Atualizar display do pre√ßo base
    updateElementText(`base-price-${machineId}`, `R$ ${basePrice.toLocaleString("pt-BR")}`)

    // Calcular total das op√ß√µes
    const optionsContainer = document.getElementById(`options-container-${machineId}`)
    let optionsTotal = 0

    if (optionsContainer) {
      const selectedOptions = optionsContainer.querySelectorAll('input[type="checkbox"]:checked')
      console.log(`üìã ${selectedOptions.length} op√ß√µes selecionadas`)
      
      selectedOptions.forEach((option) => {
        const optionValue = Number.parseFloat(option.value) || 0
        optionsTotal += optionValue
        console.log(`‚úÖ Op√ß√£o: ${option.getAttribute('data-option-name')} - R$ ${optionValue}`)
      })
    }

    // Calcular pre√ßo total
    const totalPrice = basePrice + optionsTotal + voltageValue

    // Atualizar display do pre√ßo total
    updateElementText(`total-price-${machineId}`, `R$ ${totalPrice.toLocaleString("pt-BR")}`)

    console.log(`üßÆ Pre√ßo total calculado: R$ ${totalPrice} = Base: R$ ${basePrice} + Op√ß√µes: R$ ${optionsTotal} + Tens√£o: R$ ${voltageValue}`)

    // ‚úÖ NOVO: Atualizar TOTAL GERAL da sala
    const roomId = machineElement.dataset.roomId;
    if (roomId) {
        updateAllMachinesTotalDisplay(roomId);
    }

  } catch (error) {
    console.error("Erro ao calcular pre√ßo:", error)
  }
}

/**
 * Remove uma m√°quina de climatiza√ß√£o ap√≥s confirma√ß√£o do usu√°rio
 * @param {HTMLButtonElement} button - Bot√£o de remover que acionou a fun√ß√£o
 * @returns {void}
 */
function deleteClimatizationMachine(button) {
  const machineItem = button.closest(".climatization-machine")
  const machinesContainer = machineItem.closest(".machines-container")
  const roomId = machineItem.dataset.roomId;

  machineItem.remove()

  // ‚úÖ NOVO: Atualizar TOTAL GERAL ap√≥s remover m√°quina
  if (roomId) {
      updateAllMachinesTotalDisplay(roomId);
  }

  // Mostrar mensagem de vazio se n√£o houver m√°quinas
  if (machinesContainer && machinesContainer.querySelectorAll('.climatization-machine').length === 0) {
    showEmptyMessage(machinesContainer, "Nenhuma m√°quina adicionada ainda.")
  }
}

// Exporta√ß√£o e disponibiliza√ß√£o global - CORRE√á√ÉO COMPLETA
if (typeof window !== 'undefined') {
    window.addMachine = addMachine;
    window.toggleMachineSection = toggleMachineSection;
    window.updateMachineTitle = updateMachineTitle;
    window.updateMachineOptions = updateMachineOptions;
    window.calculateMachinePrice = calculateMachinePrice;
    window.deleteClimatizationMachine = deleteClimatizationMachine;
    window.deleteMachine = deleteClimatizationMachine; 
    window.handleOptionClick = handleOptionClick;
    window.updateOptionSelection = updateOptionSelection;
    window.updateOptionValues = updateOptionValues;
    window.handlePowerChange = handlePowerChange;
    
    // ‚úÖ NOVAS FUN√á√ïES GLOBAIS para TOTAL GERAL
    window.calculateTotalAllMachinesPrice = calculateTotalAllMachinesPrice;
    window.updateAllMachinesTotalDisplay = updateAllMachinesTotalDisplay;
    window.saveTotalAllMachinesPriceToRoom = saveTotalAllMachinesPriceToRoom;
}

export {
    addMachine,
    buildClimatizationMachineHTML,
    toggleMachineSection,
    updateMachineTitle,
    updateMachineOptions,
    calculateMachinePrice,
    deleteClimatizationMachine,
    handleOptionClick,
    updateOptionSelection,
    updateOptionValues,
    handlePowerChange,
    
    // ‚úÖ NOVAS EXPORTA√á√ïES para TOTAL GERAL
    calculateTotalAllMachinesPrice,
    updateAllMachinesTotalDisplay,
    saveTotalAllMachinesPriceToRoom
}
/* ==== FIM: machineManagement.js ==== */

/* ==== IN√çCIO: machinesBuilder.js ==== */
// machineBuilder.js
// SISTEMA CORRIGIDO COM IDs √öNICOS

import { buildCapacityCalculationTable } from './capacityCalculator.js'
import { removeEmptyMessage } from './utilities.js'
import { generateSecureId } from '../../data-files/data-utils-core.js' // ‚úÖ NOVA IMPORT

if (typeof window !== 'undefined' && !window.machinesDataCache) {
    window.machinesDataCache = null;
}

/**
 * Constr√≥i a se√ß√£o completa de m√°quinas para uma sala
 * Inclui tabela de capacidade e container para m√°quinas
 * @param {string} obraId - ID √∫nico da obra
 * @param {string} projectId - ID √∫nico do projeto
 * @param {string} roomName - Nome da sala
 * @param {string} finalRoomId - ID √∫nico da sala
 * @returns {string} HTML da se√ß√£o de m√°quinas
 */
function buildMachinesSection(obraId, projectId, roomName, finalRoomId) {
  const roomId = finalRoomId;

  if (!roomId || roomId === 'undefined' || roomId === 'null') {
      console.error(`ERRO FALBACK (buildMachinesSection) machineBuilder.js [Room ID inv√°lido: ${roomId}]`);
      return '';
  }

  return `
    <div class="section-block">
      <div class="section-header-machine">
        <button class="minimizer" onclick="toggleSection('${roomId}-maquinas')">+</button>
        <h4 class="section-title">M√°quinas</h4>
        <button class="btn btn-add-small" onclick="addMachine('${roomId}')">+ Adicionar </button>
      </div>
      <div class="section-content collapsed" id="section-content-${roomId}-maquinas">
        ${buildCapacityCalculationTable(roomId)}
        
        <div class="machines-container" id="machines-${roomId}">
          <p class="empty-message">Nenhuma m√°quina adicionada ainda.</p>
        </div>
        
        <!-- ‚úÖ TOTAL GERAL: FORA do machines-container, DENTRO da section-content -->
        <div class="all-machines-total-price">
          <strong>Total Geral de Todas as M√°quinas da Sala: 
            <span id="total-all-machines-price-${roomId}">R$ 0,00</span>
          </strong>
        </div>
      </div>
    </div>
  `;
}

/**
 * Carrega os dados das m√°quinas do servidor com cache - CORRIGIDA
 * @returns {Promise<Object>} Dados das m√°quinas dispon√≠veis
 */
async function loadMachinesData() {
    // Verificar se o cache √© v√°lido (n√£o apenas se existe)
    if (window.machinesDataCache && Array.isArray(window.machinesDataCache.machines) && window.machinesDataCache.machines.length > 0) {
        console.log("üì¶ Retornando dados das m√°quinas do cache GLOBAL (v√°lido)");
        return window.machinesDataCache;
    }

    try {
        console.log("üîÑ Carregando dados das m√°quinas do servidor...");
        const response = await fetch(`/machines`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        const machinesData = { machines: Array.isArray(data) ? data : data.machines };
        
        // Cache GLOBAL - dispon√≠vel para todas as m√°quinas de todas as salas
        window.machinesDataCache = machinesData;
        window.machinesData = machinesData.machines;
        
        console.log(`‚úÖ Dados das m√°quinas carregados GLOBALMENTE: ${machinesData.machines.length} m√°quinas`);
        return machinesData;
        
    } catch (error) {
        console.error("‚ùå Erro ao carregar dados das m√°quinas:", error);

        // Se houver cache antigo, usar mesmo que incompleto
        if (window.machinesDataCache) {
            console.log("üîÑ Usando cache antigo devido ao erro");
            return window.machinesDataCache;
        }

        // Retorna dados vazios apenas se n√£o houver cache
        const emptyData = { machines: [] };
        window.machinesDataCache = emptyData;
        return emptyData;
    }
}

/**
 * Gera ID √∫nico para m√°quina baseado na sala - CORRE√á√ÉO COMPLETA
 * @param {string} roomId - ID √∫nico da sala
 * @returns {string} ID √∫nico da m√°quina
 */
function generateMachineId(roomId) {
    // ‚úÖ CORRE√á√ÉO: Validar roomId
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (generateMachineId) machineBuilder.js [Room ID inv√°lido: ${roomId}]`);
        return generateSecureId('machine');
    }
    
    const machinePrefix = generateSecureId('machine').replace('machine_', '');
    return `${roomId}_machine_${machinePrefix}_${Date.now()}`;
}

/**
 * Carrega m√°quinas salvas previamente para uma sala - CORRE√á√ÉO COMPLETA
 * @param {string} roomId - ID √∫nico da sala
 * @param {Array} savedMachines - Lista de m√°quinas salvas
 */
async function loadSavedMachines(roomId, savedMachines) {
    // ‚úÖ CORRE√á√ÉO: Validar roomId
    if (!roomId || roomId === 'undefined' || roomId === 'null') {
        console.error(`ERRO FALBACK (loadSavedMachines) machineBuilder.js [Room ID inv√°lido: ${roomId}]`);
        return;
    }
    
    const machinesContainer = document.getElementById(`machines-${roomId}`);
    
    if (!savedMachines?.length) {
        console.log(`üì≠ Nenhuma m√°quina salva para a sala ${roomId}`);
        return;
    }

    if (!machinesContainer) {
        console.error(`‚ùå Container de m√°quinas n√£o encontrado: machines-${roomId}`);
        return;
    }

    removeEmptyMessage(machinesContainer);

    try {
        const machinesData = await loadMachinesData();
        console.log(`üîÑ Carregando ${savedMachines.length} m√°quinas salvas para ${roomId}`);
        
        savedMachines.forEach((savedMachine, index) => {
            // ‚úÖ CORRE√á√ÉO: Gerar ID √∫nico para cada m√°quina
            const machineId = generateMachineId(roomId);
            const machineHTML = buildClimatizationMachineFromSavedData(machineId, savedMachine, machinesData.machines);
            machinesContainer.insertAdjacentHTML("beforeend", machineHTML);
            console.log(`‚úÖ M√°quina carregada: ${savedMachine.nome} (ID: ${machineId})`);
        });

        // Aguardar a DOM atualizar e ent√£o for√ßar atualiza√ß√£o dos valores
        setTimeout(() => {
            const machineElements = machinesContainer.querySelectorAll('.climatization-machine');
            machineElements.forEach((machineElement, index) => {
                const machineId = machineElement.dataset.machineId;
                const savedMachine = savedMachines[index];
                
                if (savedMachine) {
                    console.log(`üîß Processando m√°quina ${machineId} com TR: ${savedMachine.potencia} e Tens√£o: ${savedMachine.tensao}`);
                    
                    // For√ßar atualiza√ß√£o dos valores baseados na TR salva
                    if (savedMachine.potencia && window.updateOptionValues) {
                        console.log(`üîÑ Atualizando op√ß√µes para TR ${savedMachine.potencia}`);
                        window.updateOptionValues(machineId);
                    }
                    
                    // Recalcular pre√ßo total
                    if (window.calculateMachinePrice) {
                        window.calculateMachinePrice(machineId);
                    }
                }
            });

            // ‚úÖ NOVO: Calcular TOTAL GERAL ap√≥s carregar todas as m√°quinas
            if (window.updateAllMachinesTotalDisplay) {
                window.updateAllMachinesTotalDisplay(roomId);
            }

        }, 200);

    } catch (error) {
        console.error("‚ùå Erro ao carregar m√°quinas salvas:", error);
    }
}

/**
 * Constr√≥i uma m√°quina de climatiza√ß√£o a partir de dados salvos - CORRE√á√ÉO COMPLETA
 * @param {string} machineId - ID √∫nico da m√°quina
 * @param {Object} savedMachine - Dados da m√°quina salvos
 * @param {Array} allMachines - Lista de todas as m√°quinas dispon√≠veis
 * @returns {string} HTML da m√°quina reconstru√≠da
 */
function buildClimatizationMachineFromSavedData(machineId, savedMachine, allMachines) {
    // ‚úÖ CORRE√á√ÉO: Validar machineId
    if (!machineId || machineId === 'undefined' || machineId === 'null') {
        console.error(`ERRO FALBACK (buildClimatizationMachineFromSavedData) machineBuilder.js [Machine ID inv√°lido: ${machineId}]`);
        machineId = generateSecureId('machine');
    }

    const machineType = allMachines.find((m) => m.type === savedMachine.tipo);

    if (!machineType) {
        console.error("‚ùå ERRO: Tipo de M√°quina n√£o encontrado:", savedMachine.tipo);
        return '';
    }

    // Obter pot√™ncias e tens√µes dispon√≠veis
    const potencies = Object.keys(machineType.baseValues || {});
    const voltageNames = (machineType.voltages || []).map(v => v.name);
    
    // Calcular pre√ßo base atual - usar valores espec√≠ficos por TR
    const basePrice = calculateBasePrice(machineType, savedMachine.potencia);

    return `
    <div class="climatization-machine" data-machine-id="${machineId}" data-room-id="${savedMachine.roomId || ''}">
      <div class="machine-header">
        <button class="minimizer" onclick="toggleMachineSection(this)">‚àí</button>
        <input type="text" 
               class="machine-title-editable" 
               value="${savedMachine.nome || `Maquina`}"
               onchange="updateMachineTitle(this, '${machineId}')"
               onclick="this.select()">
        <button class="btn btn-delete-small" onclick="deleteClimatizationMachine(this)">Remover</button>
      </div>
      <div class="machine-content" id="machine-content-${machineId}">
        <div class="climatization-form-grid">
          ${buildFormGroup(
            "Tipo de Equipamento:",
            buildSelectWithSelected(
              allMachines.map((m) => m.type),
              machineId,
              "machine-type-select",
              "updateMachineOptions(this)",
              savedMachine.tipo,
            ),
          )}
          ${buildFormGroup(
            "Capacidade:",
            buildSelectWithSelected(
              potencies,
              machineId,
              "machine-power-select",
              `handlePowerChange('${machineId}')`,
              savedMachine.potencia,
            ),
          )}
          ${buildFormGroup(
            "Tens√£o:",
            buildSelectWithSelected(
              voltageNames,
              machineId,
              "machine-voltage-select",
              `calculateMachinePrice('${machineId}')`,
              savedMachine.tensao,
            ),
          )}
          <div class="form-group">
              <label>Pre√ßo Base:</label>
              <div class="price-display" id="base-price-${machineId}">
                  R$ 0,00
              </div>
          </div>
          <div class="form-group"> <!-- Pre√ßo final desta m√°quina -->
              <label>Pre√ßo Total desta M√°quina: </label>
                <div class="price-display" id="total-price-${machineId}"">
                  R$ ${savedMachine.precoTotal.toLocaleString("pt-BR")}
                </div>
          </div>

          </div>
        </div>
        <div class="machine-options-section">
          <h6>Op√ß√µes Adicionais:</h6>
          <div class="options-grid" id="options-container-${machineId}">
            ${buildSavedOptionsHTML(machineType.options, machineId, savedMachine.opcoesSelecionadas, savedMachine.potencia)}
          </div>
        </div>
        <!-- ‚ùå REMOVIDO: total-all-machines-price N√ÉO deve estar aqui dentro -->
      </div>
    </div>
  `;
}

/**
 * Constr√≥i um grupo de formul√°rio com label e conte√∫do
 * @param {string} label - Texto do label
 * @param {string} content - Conte√∫do HTML do campo
 * @returns {string} HTML do grupo de formul√°rio
 */
function buildFormGroup(label, content) {
  return `
    <div class="form-group">
      <label>${label}</label>
      ${content}
    </div>
  `;
}

/**
 * Constr√≥i um elemento select com op√ß√£o pr√©-selecionada - CORRE√á√ÉO COMPLETA
 * @param {Array} options - Lista de op√ß√µes
 * @param {string} machineId - ID √∫nico da m√°quina
 * @param {string} className - Classe CSS
 * @param {string} onchangeHandler - Handler de change
 * @param {string} selectedValue - Valor pr√©-selecionado
 * @returns {string} HTML do select com sele√ß√£o
 */
function buildSelectWithSelected(options, machineId, className, onchangeHandler, selectedValue) {
  return `
    <select class="form-input ${className}" 
            data-machine-id="${machineId}"
            onchange="${onchangeHandler}">
      <option value="">Selecionar</option>
      ${options
        .map((opt) => `<option value="${opt}" ${opt === selectedValue ? "selected" : ""}>${opt}</option>`)
        .join("")}
    </select>
  `;
}

/**
 * Constr√≥i op√ß√µes com sele√ß√µes pr√©-definidas a partir de dados salvos - CORRE√á√ÉO COMPLETA
 * @param {Array} options - Lista de op√ß√µes dispon√≠veis
 * @param {string} machineId - ID √∫nico da m√°quina
 * @param {Array} selectedOptions - Op√ß√µes que estavam selecionadas
 * @param {string} selectedPower - Pot√™ncia selecionada (para calcular valores espec√≠ficos)
 * @returns {string} HTML das op√ß√µes com checkboxes marcados
 */
function buildSavedOptionsHTML(options, machineId, selectedOptions = [], selectedPower = null) {
  if (!options || options.length === 0) {
    return '<p class="empty-options-message">Nenhuma op√ß√£o dispon√≠vel para esta m√°quina</p>';
  }

  return options
    .map((option) => {
      const isChecked = selectedOptions.some((selected) => selected.id === option.id);
      
      let optionValue = 0;
      if (selectedPower && option.values && option.values[selectedPower] !== undefined) {
        optionValue = option.values[selectedPower];
        console.log(`üí∞ Op√ß√£o ${option.name} para TR ${selectedPower}: R$ ${optionValue}`);
      }
      
      const optionDisplayValue = `+R$ ${optionValue.toLocaleString("pt-BR")}`;

      return `
      <div class="option-item" onclick="handleOptionClick('${machineId}', ${option.id})">
        <div class="option-checkbox">
          <input type="checkbox" 
                 value="${optionValue}" 
                 data-option-id="${option.id}"
                 data-option-name="${option.name}"
                 onchange="updateOptionSelection('${machineId}', '${option.id}'); calculateMachinePrice('${machineId}')"
                 id="option-${machineId}-${option.id}"
                 ${isChecked ? "checked" : ""}>
          <div class="option-content">
            <div class="option-name">${option.name}</div>
            <div class="option-price">${optionDisplayValue}</div>
          </div>
        </div>
      </div>
    `;
    })
    .join("");
}

/**
 * Calcula o pre√ßo base baseado no tipo de m√°quina e pot√™ncia selecionada
 * @param {Object} machineType - Tipo da m√°quina
 * @param {string} potencia - Pot√™ncia selecionada
 * @returns {number} Pre√ßo base calculado
 */
function calculateBasePrice(machineType, potencia) {
  if (!machineType || !machineType.baseValues) return 0;
  return machineType.baseValues[potencia] || 0;
}

/**
 * Atualiza os c√°lculos de capacidade quando os ganhos t√©rmicos mudam
 * @param {string} roomId - ID da sala
 */
function updateCapacityFromThermalGains(roomId) {
  if (window.calculateCapacitySolution) {
    window.calculateCapacitySolution(roomId);
  }
}

/**
 * Inicializa os c√°lculos de capacidade com m√∫ltiplas tentativas
 * Usa timeouts progressivos para garantir que a DOM esteja pronta
 */
function initializeCapacityCalculations() {
  const attempts = [100, 500, 1000, 2000];
  attempts.forEach((delay) => {
    setTimeout(() => {
      document.querySelectorAll(".room-block").forEach((roomBlock) => {
        const roomId = roomBlock.dataset.roomId; // ‚úÖ CORRE√á√ÉO: Usar data attribute
        if (roomId) {
          const capacityTable = roomBlock.querySelector(".capacity-calculation-table");
          if (capacityTable) {
            const fatorSegurancaInput = document.getElementById(`fator-seguranca-${roomId}`);
            const capacidadeUnitariaSelect = document.getElementById(`capacidade-unitaria-${roomId}`);
            if (fatorSegurancaInput && capacidadeUnitariaSelect && window.calculateCapacitySolution) {
              window.calculateCapacitySolution(roomId);
            }
          }
        }
      });
    }, delay);
  });
}

/**
 * Atualiza todos os c√°lculos de capacidade em todas as salas
 * √ötil para rec√°lculos em lote
 */
function refreshAllCapacityCalculations() {
  document.querySelectorAll(".room-block").forEach((roomBlock) => {
    const roomId = roomBlock.dataset.roomId; // ‚úÖ CORRE√á√ÉO: Usar data attribute
    if (roomId && window.calculateCapacitySolution) {
      window.calculateCapacitySolution(roomId);
    }
  });
}

// Exporta√ß√£o das fun√ß√µes do m√≥dulo
export {
  buildMachinesSection,
  loadMachinesData,
  loadSavedMachines,
  updateCapacityFromThermalGains,
  initializeCapacityCalculations,
  refreshAllCapacityCalculations,
  generateMachineId // ‚úÖ NOVA EXPORT
}

// Disponibiliza√ß√£o global das fun√ß√µes necess√°rias
if (typeof window !== 'undefined') {
    window.loadSavedMachines = loadSavedMachines;
    window.generateMachineId = generateMachineId; // ‚úÖ NOVA GLOBAL
}
/* ==== FIM: machinesBuilder.js ==== */

/* ==== IN√çCIO: projects.js ==== */
// projects.js
import { ensureStringId } from "../utils/utils.js"
import { buildObraData } from "./data-utils.js"
import { showSystemStatus} from '../ui/intr-files/status-manager.js'
import{ updateObraButtonAfterSave } from "../ui/intr-files/obra-manager.js"
import { isSessionActive, startSessionOnFirstSave } from "./server.js";

/**
 * Busca todas as obras do servidor
 * @returns {Promise<Array>} Lista de obras
 */
async function fetchObras() {
  try {
    const response = await fetch('/obras')

    if (!response.ok) {
      // Se o endpoint n√£o existir, retorna array vazio (para obras novas)
      if (response.status === 404) {
        return [];
      }
      throw new Error(`Erro HTTP: ${response.status}`)
    }

    const obras = await response.json()
    return obras || [];
  } catch (error) {
    console.error("‚ùå Erro ao buscar obras:", error)

    // Em caso de erro, assumir que n√£o h√° obras (para desenvolvimento)
    return [];
  }
}

/**
 * Atualiza uma obra existente no servidor
 * @param {string|number} obraId - ID da obra
 * @param {Object} obraData - Dados atualizados da obra
 * @returns {Promise<Object|null>} Obra atualizada ou null em caso de erro
 */
async function atualizarObra(obraId, obraData) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de processar
    if (!obraId || obraId === 'undefined' || obraId === 'null') {
      console.error(`ERRO FALBACK (atualizarObra) projects.js [ID de obra inv√°lido: ${obraId}]`);
      showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
      return null;
    }

    // S√≥ atualizar se sess√£o estiver ativa
    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° atualizada");
      showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o atualizada.", "error");
      return null;
    }

    obraId = ensureStringId(obraId);

    console.log(`üîç Verificando se obra ${obraId} existe no servidor...`);
    
    // Buscar TODAS as obras usando o novo endpoint
    const todasObrasResponse = await fetch('/api/backup-completo');
    if (!todasObrasResponse.ok) {
      throw new Error('Falha ao carregar backup para verifica√ß√£o');
    }
    
    const backupData = await todasObrasResponse.json();
    const todasObras = backupData.obras || [];
    const obraExistente = todasObras.find(obra => String(obra.id) === String(obraId));
    
    console.log(`üìä Verifica√ß√£o: Obra ${obraId} existe? ${!!obraExistente}`);
    console.log(`üìã TODAS as obras no backup:`, todasObras.map(o => ({ id: o.id, nome: o.nome })));

    if (!obraExistente) {
      console.log(`‚ùå Obra ${obraId} n√£o encontrada no backup, criando nova...`);

      // ‚úÖ CORRE√á√ÉO: Se obra n√£o existe, criar como nova preservando ID seguro
      console.log(`üÜï Criando nova obra com ID seguro preservado: ${obraId}`);
      obraData.id = obraId; // ‚úÖ PRESERVAR ID SEGUR
      return await salvarObra(obraData);
    }

    // ‚úÖ CORRE√á√ÉO: Garantir que o ID nos dados seja o correto (j√° est√° correto)
    console.log('üîÑ ATUALIZANDO OBRA EXISTENTE:', {
      id: obraData.id,
      nome: obraData.nome,
      projetos: obraData.projetos?.length || 0
    });

    // Usar PUT para /obras/{id}
    const url = `/obras/${obraId}`;
    console.log(`üéØ Fazendo PUT para: ${url}`);
    
    const response = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(obraData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao atualizar obra: ${errorText}`);
    }

    const updatedObra = await response.json();
    showSystemStatus("Obra atualizada com sucesso!", "success");
    
    console.log('‚úÖ OBRA ATUALIZADA:', {
      id: updatedObra.id,
      nome: updatedObra.nome,
      projetos: updatedObra.projetos?.length || 0
    });
    return updatedObra;
  } catch (error) {
    console.error("‚ùå Erro ao ATUALIZAR obra:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel atualizar a obra", "error");
    return null;
  }
}

/**
 * Salva uma nova obra no servidor e adiciona √† sess√£o atual
 * @param {Object} obraData - Dados da obra a ser salva
 * @returns {Promise<Object|null>} Obra criada ou null em caso de erro
 */
async function salvarObra(obraData) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar dados da obra antes de salvar
    if (!obraData || !obraData.nome) {
      console.error(`ERRO FALBACK (salvarObra) projects.js [Dados da obra inv√°lidos: ${JSON.stringify(obraData)}]`);
      showSystemStatus("ERRO: Dados da obra inv√°lidos", "error");
      return null;
    }

    // S√≥ salvar se sess√£o estiver ativa
    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
      showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
      return null;
    }

    // ‚úÖ CORRE√á√ÉO: Garantir que obra tenha ID seguro
    if (!obraData.id || obraData.id === 'undefined' || obraData.id === 'null') {
      console.error(`ERRO FALBACK (salvarObra) projects.js [Obra sem ID seguro: ${obraData.id}]`);
      showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
      return null;
    }

    console.log('üì§ SALVANDO NOVA OBRA:', {
      id: obraData.id,
      nome: obraData.nome,
      projetos: obraData.projetos?.length || 0,
      timestamp: obraData.timestamp
    });

    // Sempre usar POST para nova obra
    const response = await fetch('/obras', {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(obraData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao salvar obra: ${errorText}`);
    }

    const createdObra = await response.json();
    
    // Adicionar obra √† sess√£o
    console.log(`üìù Adicionando obra ${createdObra.id} √† sess√£o...`);
    await fetch('/api/sessions/add-obra', {
      method: 'POST',
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ obra_id: createdObra.id })
    });
    
    showSystemStatus("Obra salva com sucesso!", "success");
    
    console.log('‚úÖ NOVA OBRA SALVA E ADICIONADA √Ä SESS√ÉO:', {
      id: createdObra.id,
      nome: createdObra.nome,
      projetos: createdObra.projetos?.length || 0
    });
    return createdObra;
  } catch (error) {
    console.error("‚ùå Erro ao SALVAR obra:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel salvar a obra", "error");
    return null;
  }
}


/**
 * Encontra o elemento HTML de uma obra pelo ID
 * @param {string} obraId - ID da obra a ser encontrada
 * @returns {HTMLElement|null} Elemento da obra ou null se n√£o encontrado
 */
function findObraBlock(obraId) {
    console.log(`üîç Buscando obra pelo ID: "${obraId}"`);
    
    // ‚úÖ CORRE√á√ÉO: Buscar APENAS por ID √∫nico
    // 1. Tentar pelo ID exato (mais espec√≠fico)
    let obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
    if (obraBlock) {
        console.log(`‚úÖ Obra encontrada por ID exato: "${obraId}"`);
        return obraBlock;
    }
    
    
    // 3. Listar todas as obras dispon√≠veis para debug
    const todasObras = document.querySelectorAll('[data-obra-id]');
    console.log(`üìã Obras encontradas no DOM: ${todasObras.length}`);
    
    todasObras.forEach((obra, index) => {
        console.log(`  ${index + 1}.`, {
            id: obra.dataset.obraId,
            name: obra.dataset.obraName,
            classes: obra.className
        });
    });
    
    // ‚ùå REMOVIDO: NUNCA retornar obra errada como fallback
    console.log(`‚ùå Obra com ID "${obraId}" n√£o encontrada no DOM`);
    return null;
}


/**
 * Aguarda at√© que um elemento esteja dispon√≠vel no DOM
 * @param {string} selector - Seletor do elemento
 * @param {number} timeout - Timeout em milissegundos
 * @returns {Promise<HTMLElement>}
 */
function waitForElement(selector, timeout = 3000) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        function check() {
            const element = document.querySelector(selector);
            if (element) {
                console.log(`‚úÖ Elemento encontrado: ${selector}`);
                resolve(element);
                return;
            }
            
            if (Date.now() - startTime > timeout) {
                reject(new Error(`Timeout: Elemento n√£o encontrado - ${selector}`));
                return;
            }
            
            setTimeout(check, 100);
        }
        
        check();
    });
}

/**
 * Verifica se uma obra existe no DOM com retry
 * @param {string} obraId - ID da obra
 * @param {number} maxAttempts - N√∫mero m√°ximo de tentativas
 * @returns {Promise<HTMLElement|null>}
 */
async function findObraBlockWithRetry(obraId, maxAttempts = 10) {
    console.log(`üîç Buscando obra com retry: "${obraId}"`);
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
        
        if (obraBlock) {
            console.log(`‚úÖ Obra encontrada na tentativa ${attempt}/${maxAttempts}`);
            return obraBlock;
        }
        
        console.log(`‚è≥ Tentativa ${attempt}/${maxAttempts} - obra n√£o encontrada, aguardando...`);
        
        if (attempt < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    console.log(`‚ùå Obra n√£o encontrada ap√≥s ${maxAttempts} tentativas`);
    return null;
}






/**
 * Salva ou atualiza uma obra no servidor (fun√ß√£o principal)
 * @param {string} obraId - ID da obra
 * @param {Event} event - Evento do clique
 * @returns {Promise<void>}
 */
async function saveObra(obraId, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    console.log(`üíæ SALVANDO OBRA pelo ID: "${obraId}"`);

    // ‚úÖ CORRE√á√ÉO 1: AGUARDAR obra estar no DOM antes de qualquer opera√ß√£o
    console.log(`‚è≥ Aguardando obra "${obraId}" estar no DOM...`);
    
    let obraBlock = await findObraBlockWithRetry(obraId, 15);
    
    if (!obraBlock) {
        console.error('‚ùå Obra n√£o encontrada no DOM ap√≥s m√∫ltiplas tentativas:', obraId);
        
        // Debug detalhado
        const todasObras = document.querySelectorAll('[data-obra-id]');
        console.log('üìã Obras dispon√≠veis no DOM:', Array.from(todasObras).map(o => ({
            id: o.dataset.obraId,
            name: o.dataset.obraName
        })));
        
        showSystemStatus("ERRO: Obra n√£o encontrada na interface", "error");
        return;
    }

    // ‚úÖ CORRE√á√ÉO CR√çTICA: SALVAR REFER√äNCIA ANTES de buildObraData
    const obraOriginalReference = obraBlock;
    const obraContainer = obraBlock.parentElement;
    
    console.log('üîí REFER√äNCIA SALVA:', {
        obra: obraOriginalReference,
        container: obraContainer,
        obraNoContainer: obraContainer.contains(obraOriginalReference)
    });

    // ‚úÖ CORRE√á√ÉO 2: Verificar se a sess√£o est√° ativa AP√ìS confirmar que a obra existe
    if (!isSessionActive()) {
        console.log("üÜï Iniciando sess√£o para primeira obra...");
        await startSessionOnFirstSave();
    }

    // Log para sess√£o ativa
    if (!isSessionActive()) {
        console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° salva");
        showSystemStatus("ERRO: Sess√£o n√£o est√° ativa. Obra n√£o salva.", "error");
        return;
    }

    console.log('‚úÖ Obra confirmada no DOM:', {
        element: obraBlock,
        dataset: obraBlock.dataset,
        id: obraBlock.dataset.obraId,
        name: obraBlock.dataset.obraName
    });

    console.log('üî® Construindo dados da obra...');
    const obraData = buildObraData(obraBlock);

    if (!obraData) {
        console.error('‚ùå Falha ao construir dados da obra');
        showSystemStatus("ERRO: Falha ao construir dados da obra", "error");
        return;
    }

    // ‚úÖ CORRE√á√ÉO 3: L√≥gica MELHORADA para determinar se √© nova obra
    const obraIdFromDOM = obraBlock.dataset.obraId;
    const obraIdFromData = obraData.id;
    
    // ‚úÖ VERIFICA√á√ÉO MAIS ROBUSTA - usar o ID que veio do DOM como fonte da verdade
    const finalObraId = obraIdFromDOM || obraIdFromData;
    
    console.log('üîç VERIFICA√á√ÉO DE OBRA MELHORADA:');
    console.log('- ID no DOM:', obraIdFromDOM);
    console.log('- ID nos dados:', obraIdFromData);
    console.log('- ID final para uso:', finalObraId);
    console.log('- √â ID seguro?:', finalObraId?.startsWith('obra_'));
    
    // ‚úÖ CORRE√á√ÉO: Determinar se √© nova obra baseado na presen√ßa no servidor
    let isNewObra = true; // Assume que √© nova por padr√£o
    
    try {
        // Verificar se a obra j√° existe no servidor
        const todasObrasResponse = await fetch('/api/backup-completo');
        if (todasObrasResponse.ok) {
            const backupData = await todasObrasResponse.json();
            const todasObras = backupData.obras || [];
            const obraExistente = todasObras.find(obra => String(obra.id) === String(finalObraId));
            
            isNewObra = !obraExistente;
            console.log(`- J√° existe no servidor?: ${!isNewObra}`);
        }
    } catch (error) {
        console.log('- N√£o foi poss√≠vel verificar servidor, assumindo como nova obra');
    }

    console.log('- √â nova obra?:', isNewObra);

    let result = null;
    
    if (isNewObra) {
        console.log('üÜï SALVANDO COMO NOVA OBRA COM ID SEGURO:', finalObraId);
        
        // ‚úÖ CORRE√á√ÉO: Garantir que obraData tenha o ID correto
        obraData.id = finalObraId;
        
        if (!obraData.id || !obraData.id.startsWith('obra_')) {
            console.error('‚ùå Obra n√£o possui ID seguro v√°lido para salvar');
            showSystemStatus("ERRO: Obra n√£o possui ID v√°lido", "error");
            return;
        }
        
        result = await salvarObra(obraData);
    } else {
        console.log('üìù ATUALIZANDO OBRA EXISTENTE, ID SEGURO:', finalObraId);
        
        // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de atualizar
        if (!finalObraId.startsWith('obra_')) {
            console.error(`ERRO: ID n√£o seguro para atualiza√ß√£o: ${finalObraId}`);
            showSystemStatus("ERRO: ID da obra inv√°lido para atualiza√ß√£o", "error");
            return;
        }
        
        result = await atualizarObra(finalObraId, obraData);
    }

    if (result) {
        const finalId = ensureStringId(result.id);
        
        // ‚úÖ CORRE√á√ÉO CR√çTICA: VERIFICAR SE OBRA AINDA EXISTE NO DOM
        let obraBlockAtual = document.querySelector(`[data-obra-id="${finalId}"]`);
        
        if (!obraBlockAtual) {
            console.error('‚ùå CR√çTICO: Obra desapareceu do DOM durante salvamento!');
            console.log('üîç Tentando recuperar da refer√™ncia original...');
            
            // Tentar recuperar do container original
            if (obraContainer && document.body.contains(obraContainer)) {
                const obrasNoContainer = obraContainer.querySelectorAll('[data-obra-id]');
                console.log(`üì¶ Obras no container original: ${obrasNoContainer.length}`);
                
                // Se a obra original ainda existe no container
                if (obraContainer.contains(obraOriginalReference)) {
                    obraBlockAtual = obraOriginalReference;
                    console.log('‚úÖ Obra recuperada da refer√™ncia original');
                } else {
                    console.error('‚ùå Obra n√£o est√° mais no container original');
                    showSystemStatus("ERRO: Obra perdida durante salvamento", "error");
                    return;
                }
            } else {
                console.error('‚ùå Container original n√£o encontrado');
                showSystemStatus("ERRO: Obra perdida durante salvamento", "error");
                return;
            }
        }

        // ‚úÖ ATUALIZAR DOM com o ID seguro correto
        obraBlockAtual.dataset.obraId = finalId;
        obraBlockAtual.dataset.obraName = obraData.nome;
        
        // Atualizar t√≠tulo se necess√°rio
        const titleElement = obraBlockAtual.querySelector('.obra-title');
        if (titleElement && titleElement.textContent !== obraData.nome) {
            titleElement.textContent = obraData.nome;
        }

        // ‚úÖ CORRE√á√ÉO: VERIFICAR NOVAMENTE antes de atualizar bot√£o
        if (typeof updateObraButtonAfterSave === 'function' && document.body.contains(obraBlockAtual)) {
            console.log("‚úÖ Obra confirmada no DOM, atualizando bot√£o...");
            updateObraButtonAfterSave(obraData.nome, finalId);
        } else {
            console.error('‚ùå Obra n√£o est√° no DOM para atualizar bot√£o');
        }

        console.log(`‚úÖ OBRA SALVA/ATUALIZADA COM SUCESSO! ID SEGURO: ${finalId}`);
        
        showSystemStatus("Obra salva com sucesso!", "success");
    } else {
        console.error('‚ùå FALHA AO SALVAR OBRA NO SERVIDOR');
        showSystemStatus("ERRO: Falha ao salvar obra no servidor", "error");
    }
}


/**
 * Deleta uma obra do servidor
 * @param {string} obraName - Nome da obra
 * @param {string} obraId - ID da obra
 * @returns {Promise<void>}
 */
async function deleteObraFromServer(obraName, obraId) {
  try {
    // ‚úÖ CORRE√á√ÉO: Validar ID seguro antes de deletar
    if (!obraId || obraId === 'undefined' || obraId === 'null' || !obraId.startsWith('obra_')) {
      console.error(`ERRO FALBACK (deleteObraFromServer) projects.js [ID de obra inv√°lido: ${obraId}]`);
      showSystemStatus("ERRO: ID da obra inv√°lido para remo√ß√£o", "error");
      return;
    }

    if (!isSessionActive()) {
      console.warn("‚ö†Ô∏è Sess√£o n√£o est√° ativa - obra n√£o ser√° removida do servidor");
      return;
    }

    obraId = ensureStringId(obraId);

    console.log(`üóëÔ∏è Removendo obra ${obraId} do servidor...`);

    const response = await fetch(`/obras/${obraId}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao remover obra: ${errorText}`);
    }

    console.log(`‚úÖ Obra ${obraId} removida do servidor`);
    showSystemStatus("Obra removida do servidor com sucesso", "success");
  } catch (error) {
    console.error("‚ùå Erro ao remover obra do servidor:", error);
    showSystemStatus("ERRO: N√£o foi poss√≠vel remover a obra do servidor", "error");
  }
}

/**
 * Verifica os dados de uma obra e gera relat√≥rio de completude
 * @param {string} obraId - ID da obra
 * @returns {void}
 */
function verifyObraData(obraId) {
  const obraBlock = document.querySelector(`[data-obra-id="${obraId}"]`);
  if (!obraBlock) {
    console.error(`‚ùå Obra com ID "${obraId}" n√£o encontrada para verifica√ß√£o`);
    alert(`ERRO: Obra com ID "${obraId}" n√£o encontrada`);
    return;
  }

  const obraName = obraBlock.dataset.obraName;
  const projects = obraBlock.querySelectorAll(".project-block");
  let totalRooms = 0;
  
  let report = `Verifica√ß√£o da Obra "${obraName}" (ID: ${obraId}):\n\n`;
  report += `Total de projetos: ${projects.length}\n\n`;

  projects.forEach((project, index) => {
    const projectName = project.dataset.projectName;
    const rooms = project.querySelectorAll(".room-block");
    totalRooms += rooms.length;
    
    report += `Projeto ${index + 1}: ${projectName}\n`;
    report += `  - Salas: ${rooms.length}\n`;
    
    rooms.forEach((room, roomIndex) => {
      const roomName = room.querySelector(".room-title")?.textContent || `Sala ${roomIndex + 1}`;
      const stats = calculateRoomCompletionStats(room);
      report += `    - ${roomName}: ${stats.filled}/${stats.total} campos (${stats.percentage}%)\n`;
    });
    report += '\n';
  });

  report += `RESUMO: ${projects.length} projetos, ${totalRooms} salas`;

  console.log(`üîç Relat√≥rio gerado para obra: ${obraName} (ID: ${obraId})`);
  alert(report);
}

/**
 * Calcula estat√≠sticas de preenchimento de uma sala
 * @param {HTMLElement} room - Elemento da sala
 * @returns {Object} Estat√≠sticas de preenchimento
 */
function calculateRoomCompletionStats(room) {
  const inputs = room.querySelectorAll(".form-input, .clima-input");
  const filledInputs = Array.from(inputs).filter((input) => {
    if (input.type === 'checkbox' || input.type === 'radio') {
      return input.checked;
    }
    return input.value && input.value.trim() !== "";
  }).length;
  
  const totalInputs = inputs.length;
  const percentage = totalInputs > 0 ? ((filledInputs / totalInputs) * 100).toFixed(1) : 0;

  return {
    filled: filledInputs,
    total: totalInputs,
    percentage: percentage,
  };
}


// Exporta√ß√µes para compatibilidade
window.saveObra = saveObra;
window.verifyObraData = verifyObraData;

export {
  fetchObras,
  salvarObra,
  atualizarObra,
  saveObra,

  deleteObraFromServer,
  verifyObraData,
  calculateRoomCompletionStats,
  findObraBlock,
}
/* ==== FIM: projects.js ==== */

/* ==== IN√çCIO: ui-helpers.js ==== */
// ui-helpers.js

import { UI_CONSTANTS } from '../../config/config.js'

/**
 * Utilit√°rios de interface do usu√°rio
 */

/**
 * Alterna a visibilidade de um elemento (expandir/recolher)
 * @param {string} contentId - ID do elemento a ser alternado
 * @param {HTMLElement} minimizerElement - Bot√£o minimizador
 */
function toggleElementVisibility(contentId, minimizerElement) {
  const content = document.getElementById(contentId)
  if (!content) {
    console.error(`‚ùå Elemento ${contentId} n√£o encontrado para toggle`)
    return
  }

  const isCollapsed = content.classList.contains(UI_CONSTANTS.COLLAPSED_CLASS)

  if (isCollapsed) {
    expandElement(content, minimizerElement)
  } else {
    collapseElement(content, minimizerElement)
  }
}

/**
 * Expande um elemento na interface
 * @param {HTMLElement} element - Elemento a ser expandido
 * @param {HTMLElement} minimizerElement - Bot√£o minimizador
 */
function expandElement(element, minimizerElement) {
  element.classList.remove(UI_CONSTANTS.COLLAPSED_CLASS)
  minimizerElement.textContent = UI_CONSTANTS.EXPANDED_SYMBOL
}

/**
 * Recolhe um elemento na interface
 * @param {HTMLElement} element - Elemento a ser recolhido
 * @param {HTMLElement} minimizerElement - Bot√£o minimizador
 */
function collapseElement(element, minimizerElement) {
  element.classList.add(UI_CONSTANTS.COLLAPSED_CLASS)
  minimizerElement.textContent = UI_CONSTANTS.MINIMIZED_SYMBOL
}

/**
 * Calcula estat√≠sticas de preenchimento de uma sala
 * @param {HTMLElement} room - Elemento da sala
 * @returns {Object} Estat√≠sticas de preenchimento
 */
function calculateRoomCompletionStats(room) {
  const inputs = room.querySelectorAll(".form-input, .clima-input")
  const filledInputs = Array.from(inputs).filter((input) => {
    if (input.type === 'checkbox' || input.type === 'radio') {
      return input.checked
    }
    return input.value && input.value.trim() !== ""
  }).length

  const totalInputs = inputs.length
  const percentage = totalInputs > 0 ? ((filledInputs / totalInputs) * 100).toFixed(1) : 0

  return {
    filled: filledInputs,
    total: totalInputs,
    percentage: percentage,
  }
}

/**
 * Remove a mensagem de "obra vazia" quando projetos s√£o adicionados
 * @param {string} obraName - Nome da obra
 */
function removeEmptyObraMessage(obraName) {
  const projectsContainer = document.getElementById(`projects-${obraName}`)
  if (projectsContainer) {
    const emptyMessage = projectsContainer.querySelector(".empty-message")
    if (emptyMessage) {
      console.log(`üóëÔ∏è Removendo mensagem de obra vazia: ${obraName}`)
      emptyMessage.remove()
    }
  }
}

/**
 * Exibe mensagem de "obra vazia" se n√£o houver projetos
 * @param {string} obraName - Nome da obra
 */
function showEmptyObraMessageIfNeeded(obraName) {
  const projectsContainer = document.getElementById(`projects-${obraName}`)
  if (projectsContainer) {
    const projects = projectsContainer.querySelectorAll(".project-block")
    
    if (projects.length === 0) {
      // Verifica se j√° existe uma mensagem
      const existingMessage = projectsContainer.querySelector(".empty-message")
      if (!existingMessage) {
        console.log(`üìù Exibindo mensagem de obra vazia: ${obraName}`)
        const emptyMessage = document.createElement('p')
        emptyMessage.className = 'empty-message'
        emptyMessage.textContent = 'Adicione projetos a esta obra...'
        projectsContainer.appendChild(emptyMessage)
      }
    } else {
      // Se h√° projetos, garante que a mensagem seja removida
      removeEmptyObraMessage(obraName)
    }
  }
}

/**
 * Remove a mensagem de "projeto vazio" quando salas s√£o adicionadas
 * @param {HTMLElement} projectContent - Elemento do conte√∫do do projeto
 */
function removeEmptyProjectMessage(projectContent) {
  const emptyMessage = projectContent.querySelector(".empty-message")
  if (emptyMessage) {
    console.log(`üóëÔ∏è Removendo mensagem de projeto vazio`)
    emptyMessage.remove()
  }
}

/**
 * Exibe mensagem de "projeto vazio" se n√£o houver salas
 * @param {HTMLElement} projectContent - Elemento do conte√∫do do projeto
 */
function showEmptyProjectMessageIfNeeded(projectContent) {
  const remainingRooms = projectContent.querySelectorAll(".room-block")

  if (remainingRooms.length === 0) {
    const existingMessage = projectContent.querySelector(".empty-message")
    if (!existingMessage) {
      console.log(`üìù Exibindo mensagem de projeto vazio`)
      const addRoomSection = projectContent.querySelector(".add-room-section")
      if (addRoomSection) {
        addRoomSection.insertAdjacentHTML("beforebegin", '<p class="empty-message">Adicione salas a este projeto...</p>')
      }
    }
  } else {
    // Se h√° salas, garante que a mensagem seja removida
    removeEmptyProjectMessage(projectContent)
  }
}

export {
    toggleElementVisibility,
    expandElement,
    collapseElement,
    calculateRoomCompletionStats,
    removeEmptyObraMessage,
    showEmptyObraMessageIfNeeded,
    removeEmptyProjectMessage,
    showEmptyProjectMessageIfNeeded,
}
/* ==== FIM: ui-helpers.js ==== */
